---
title: Fuzzing Embedded Systems Using Debug Interfaces
date: 2023/11/27
categories:
  - 论文
tags:
  - 论文翻译
---
# Fuzzing Embedded Systems Using Debug Interfaces
## 信息
使用调试接口模糊化嵌入式系统

![](Fuzzing%20Embedded%20Systems%20Using%20Debug%20Interfaces/image-20231127144025910.png)

发布于2023 ISSTA

## 摘要
对嵌入式系统进行模糊测试是困难的。它们的关键组件——微控制器——是高度多样化的，不容易虚拟化;他们的软件不能被更改或检测。然而，我们观察到，许多(如果不是大多数的话)微控制器都具有调试接口，调试探针(通常通过GNU调试器GDB进行控制)可以通过该接口设置有限数量的硬件断点。使用这些，我们提取部分覆盖反馈，甚至对于未插桩的二进制代码;从而能够通过通用的、广泛的机制对嵌入式系统进行有效的模糊测试。在四种不同的微控制器板上进行评估时，我们的原型实现GDBFuzz快速达到高代码覆盖率并检测已知和新的漏洞。因为它可以应用于GDB可以调试的任何程序和系统，所以GDBFuzz是要求最低和最通用的覆盖引导的fuzzers之一。

关键字：嵌入式系统；固件；安全；自动化软件测试；模糊测试；GDB

## 1.引言
模糊测试——生成大量输入来测试系统的健壮性——已经成为检测程序漏洞的首选方法。大多数现代模糊器都遵循AFL模糊模型[36]，从一群种子输入开始，在被测系统或软件的覆盖范围的指导下，通过小规模的突变不断进化。然而，将这种模糊器应用于嵌入式系统是很困难的。原因之一是微处理器、体系结构和操作系统的高度多样性。然而，最重要的是，微控制器板上的软件不容易更改，从而阻止插桩。即使可以进行插桩，板子也需要提供存储空间来捕获覆盖率和其他运行时信息;最后，这些信息需要通过某些硬件接口找到返回模糊器的方法[7]。因此，在硬件上设置常见的fuzzers(如AFL)需要为每个电路板实现单独的覆盖收集解决方案。

因此，最近发表的嵌入式模糊测试方法中有很大一部分是虚拟化嵌入式系统的[15,59]。然而，这种虚拟化需要在速度和保真度之间进行权衡[17,58]。更糟糕的是，它不仅需要对微处理器本身进行虚拟化，还需要对电路板上的所有其他硬件组件进行虚拟化，并对它们之间的通信方式进行虚拟化。考虑到可用硬件外围设备的巨大多样性[26]，这需要相当大的安装成本，如果可能的话[17,58]。所谓的外设建模方法[18]试图自动模拟外设，但在我们的经验中，对于串行端口以外的任何接口都失败了。

在本文中，我们提出了一种替代方法来对嵌入式系统进行模糊测试，不需要虚拟化，但使用一种适用于各种嵌入式系统的统一方法。大多数微控制器都包含调试单元，通过调试单元，调试探针可以设置断点，执行程序直到断点，并检查当前程序状态，包括程序计数器和内存值。硬件断点是调试单元中的专用寄存器，当程序计数器等于寄存器值时，它停止执行，即使代码是只读的也可以设置;它们既不改变也不降低程序代码的速度。

本文的关键思想是，通过基于程序的控制流图系统地在代码中设置断点，并通过检查哪些输入触发哪些断点，我们可以检索覆盖率信息，从而为反馈驱动的模糊测试策略提供必要的指导。由于微控制器内硬件断点的数量有限，我们将它们仅设置为程序代码块的子集，并定期重新设置它们。由于许多调试探针都可以通过GNU调试器(GDB)寻址，因此我们在名为GDBFuzz的模糊器中实现了上述策略，它可以利用任何系统中的GDB接口，系统地生成由覆盖率指导的测试输入。所需的设置如图1所示。

![](Fuzzing%20Embedded%20Systems%20Using%20Debug%20Interfaces/image-20231127150817020.png)

图2总结了GDBFuzz操作。基于目标程序的CFG, GDBFuzz将可用的硬件断点设置为从CFG中随机选择的尚未到达的节点。然后GDBFuzz重复生成输入，将其发送到目标设备，并检查它是否触发了指示新代码覆盖的断点，或者是否使目标系统崩溃。

![](Fuzzing%20Embedded%20Systems%20Using%20Debug%20Interfaces/image-20231127150916538.png)

在我们的实验中，GDBFuzz显示很容易适用于许多微控制器板甚至普通用户应用程序。它实现了比黑盒模糊测试和基于虚拟化的解决方案更高的覆盖率，并且还检测了许多已知的和新的错误。总而言之，据我们所知，GDBFuzz是第一个基于硬件的、与架构无关的、源代码独立的、非侵入性的、易于应用的方法，用于覆盖引导的嵌入式系统模糊测试，我们很高兴向任何想要系统地测试嵌入式系统健壮性的人推荐它。

本文的其余部分组织如下。第2节讨论了技术的现状。第3节解释CFG算法和二进制文件的CFG提取。第4节介绍了GDBFuzz的设计;第5节描述了实现细节。我们在第6节评估我们的工作，并在第7节进一步讨论结果。第8节以结论和今后的工作结束。GDBFuzz是开源的。

## 2.背景
### 2.1 覆盖率引导的模糊测试
几十年前，Miller等[37]用随机数据测试Unix命令行工具，观察到软件bug导致的崩溃，并将这种方法称为“模糊测试”(fuzzing)。根据设计，模糊测试只能检测实际执行的代码中的错误，这就是为什么需要达到高代码覆盖率的原因。目前，已经开发了大量不同的模糊测试技术，主要分为基于模型的模糊测试和基于突变的模糊测试，前者是根据输入语言的规范生成测试数据，后者是程序的已知输入随机突变。基于突变的模糊测试很有吸引力，因为目标程序只需要很少的样本输入(种子)。种子最初被添加到基本输入(语料库)的集合中，从中生成突变的测试输入。当将触发目标先前未见行为的测试输入添加到语料库中时，基于突变的模糊测试特别有效，称为反馈驱动模糊测试。对于覆盖率引导的模糊测试，新代码路径或代码块的执行被认为是以前未见过的行为。

考虑清单1中process_data函数的代码，当输入的前四个字符匹配“bug!”且长度大于20时，该函数会导致堆栈溢出。当黑盒模糊器需要一次从28 * 4 = 2 32个组合中正确猜出前四个字符时，覆盖引导的模糊器可以在每个比较步骤中分别与28个可能的组合进行比较，从而增加了在模糊测试期间产生触发堆栈溢出的输入的总体概率。

![](Fuzzing%20Embedded%20Systems%20Using%20Debug%20Interfaces/image-20231127151507843.png)

典型的用户程序是通过利用源代码工具进行模糊测试的，这样代码覆盖率就会通过额外插入的代码反馈给模糊测试器。另外，当没有源代码时，模拟器用于获取代码覆盖率反馈，因此在编译时没有可用的代码插装。

### 2.2 嵌入式系统的覆盖率引导的模糊测试
许多方法使用仿真对嵌入式系统进行模糊测试。模拟器允许目标执行的高透明度。从模拟器中收集代码覆盖率是微不足道的，并且可以很容易地扩展模拟器中的模糊测试。然而，将嵌入式软件重新托管到模拟器中是几十年来一个开放的研究问题[17,58]。虽然模拟微处理器及其指令集是可行的，但模拟硬件外设的确切行为仍然具有挑战性。如果没有精确地模拟硬件外设，那么模拟的执行可能与实际硬件上的执行不一致，甚至完全失败。
