---
title: Fuzzing Embedded Systems Using Debug Interfaces
date: 2023/11/27
categories:
  - 论文
tags:
  - 论文翻译
---
# Fuzzing Embedded Systems Using Debug Interfaces
## 信息
使用调试接口模糊化嵌入式系统

![](Fuzzing%20Embedded%20Systems%20Using%20Debug%20Interfaces/image-20231127144025910.png)

发布于2023 ISSTA

## 摘要
对嵌入式系统进行模糊测试是困难的。它们的关键组件——微控制器——是高度多样化的，不容易虚拟化;他们的软件不能被更改或检测。然而，我们观察到，许多(如果不是大多数的话)微控制器都具有调试接口，调试探针(通常通过GNU调试器GDB进行控制)可以通过该接口设置有限数量的硬件断点。使用这些，我们提取部分覆盖反馈，甚至对于未插桩的二进制代码;从而能够通过通用的、广泛的机制对嵌入式系统进行有效的模糊测试。在四种不同的微控制器板上进行评估时，我们的原型实现GDBFuzz快速达到高代码覆盖率并检测已知和新的漏洞。因为它可以应用于GDB可以调试的任何程序和系统，所以GDBFuzz是要求最低和最通用的覆盖引导的fuzzers之一。

关键字：嵌入式系统；固件；安全；自动化软件测试；模糊测试；GDB

## 1.引言
模糊测试——生成大量输入来测试系统的健壮性——已经成为检测程序漏洞的首选方法。大多数现代模糊器都遵循AFL模糊模型[36]，从一群种子输入开始，在被测系统或软件的覆盖范围的指导下，通过小规模的突变不断进化。然而，将这种模糊器应用于嵌入式系统是很困难的。原因之一是微处理器、体系结构和操作系统的高度多样性。然而，最重要的是，微控制器板上的软件不容易更改，从而阻止插桩。即使可以进行插桩，板子也需要提供存储空间来捕获覆盖率和其他运行时信息;最后，这些信息需要通过某些硬件接口找到返回模糊器的方法[7]。因此，在硬件上设置常见的fuzzers(如AFL)需要为每个电路板实现单独的覆盖收集解决方案。

因此，最近发表的嵌入式模糊测试方法中有很大一部分是虚拟化嵌入式系统的[15,59]。然而，这种虚拟化需要在速度和保真度之间进行权衡[17,58]。更糟糕的是，它不仅需要对微处理器本身进行虚拟化，还需要对电路板上的所有其他硬件组件进行虚拟化，并对它们之间的通信方式进行虚拟化。考虑到可用硬件外围设备的巨大多样性[26]，这需要相当大的安装成本，如果可能的话[17,58]。所谓的外设建模方法[18]试图自动模拟外设，但在我们的经验中，对于串行端口以外的任何接口都失败了。

在本文中，我们提出了一种替代方法来对嵌入式系统进行模糊测试，不需要虚拟化，但使用一种适用于各种嵌入式系统的统一方法。大多数微控制器都包含调试单元，通过调试单元，调试探针可以设置断点，执行程序直到断点，并检查当前程序状态，包括程序计数器和内存值。硬件断点是调试单元中的专用寄存器，当程序计数器等于寄存器值时，它停止执行，即使代码是只读的也可以设置;它们既不改变也不降低程序代码的速度。

本文的关键思想是，通过基于程序的控制流图系统地在代码中设置断点，并通过检查哪些输入触发哪些断点，我们可以检索覆盖率信息，从而为反馈驱动的模糊测试策略提供必要的指导。由于微控制器内硬件断点的数量有限，我们将它们仅设置为程序代码块的子集，并定期重新设置它们。由于许多调试探针都可以通过GNU调试器(GDB)寻址，因此我们在名为GDBFuzz的模糊器中实现了上述策略，它可以利用任何系统中的GDB接口，系统地生成由覆盖率指导的测试输入。所需的设置如图1所示。

![](Fuzzing%20Embedded%20Systems%20Using%20Debug%20Interfaces/image-20231127150817020.png)

图2总结了GDBFuzz操作。基于目标程序的CFG, GDBFuzz将可用的硬件断点设置为从CFG中随机选择的尚未到达的节点。然后GDBFuzz重复生成输入，将其发送到目标设备，并检查它是否触发了指示新代码覆盖的断点，或者是否使目标系统崩溃。

![](Fuzzing%20Embedded%20Systems%20Using%20Debug%20Interfaces/image-20231127150916538.png)

在我们的实验中，GDBFuzz显示很容易适用于许多微控制器板甚至普通用户应用程序。它实现了比黑盒模糊测试和基于虚拟化的解决方案更高的覆盖率，并且还检测了许多已知的和新的错误。总而言之，据我们所知，GDBFuzz是第一个基于硬件的、与架构无关的、源代码独立的、非侵入性的、易于应用的方法，用于覆盖引导的嵌入式系统模糊测试，我们很高兴向任何想要系统地测试嵌入式系统健壮性的人推荐它。

本文的其余部分组织如下。第2节讨论了技术的现状。第3节解释CFG算法和二进制文件的CFG提取。第4节介绍了GDBFuzz的设计;第5节描述了实现细节。我们在第6节评估我们的工作，并在第7节进一步讨论结果。第8节以结论和今后的工作结束。GDBFuzz是开源的。

## 2.背景
### 2.1 覆盖率引导的模糊测试
几十年前，Miller等[37]用随机数据测试Unix命令行工具，观察到软件bug导致的崩溃，并将这种方法称为“模糊测试”(fuzzing)。根据设计，模糊测试只能检测实际执行的代码中的错误，这就是为什么需要达到高代码覆盖率的原因。目前，已经开发了大量不同的模糊测试技术，主要分为基于模型的模糊测试和基于突变的模糊测试，前者是根据输入语言的规范生成测试数据，后者是程序的已知输入随机突变。基于突变的模糊测试很有吸引力，因为目标程序只需要很少的样本输入(种子)。种子最初被添加到基本输入(语料库)的集合中，从中生成突变的测试输入。当将触发目标先前未见行为的测试输入添加到语料库中时，基于突变的模糊测试特别有效，称为反馈驱动模糊测试。对于覆盖率引导的模糊测试，新代码路径或代码块的执行被认为是以前未见过的行为。

考虑清单1中process_data函数的代码，当输入的前四个字符匹配“bug!”且长度大于20时，该函数会导致堆栈溢出。当黑盒模糊器需要一次从28 * 4 = 2 32个组合中正确猜出前四个字符时，覆盖引导的模糊器可以在每个比较步骤中分别与28个可能的组合进行比较，从而增加了在模糊测试期间产生触发堆栈溢出的输入的总体概率。

![](Fuzzing%20Embedded%20Systems%20Using%20Debug%20Interfaces/image-20231127151507843.png)

典型的用户程序是通过利用源代码工具进行模糊测试的，这样代码覆盖率就会通过额外插入的代码反馈给模糊测试器。另外，当没有源代码时，模拟器用于获取代码覆盖率反馈，因此在编译时没有可用的代码插装。

### 2.2 嵌入式系统的覆盖率引导的模糊测试
许多方法使用仿真对嵌入式系统进行模糊测试。模拟器允许目标执行的高透明度。从模拟器中收集代码覆盖率是微不足道的，并且可以很容易地扩展模拟器中的模糊测试。然而，将嵌入式软件重新托管到模拟器中是几十年来一个开放的研究问题[17,58]。虽然模拟微处理器及其指令集是可行的，但模拟硬件外设的确切行为仍然具有挑战性。如果没有精确地模拟硬件外设，那么模拟的执行可能与实际硬件上的执行不一致，甚至完全失败。

已经提出了几种方法来解决重新托管问题。HALucinator[8]基于HAL功能在某种程度上与设备无关的观察，在硬件抽象层(HAL)重新托管嵌入式应用程序。直接访问硬件的代码(如驱动程序)不能用这种方式进行测试，并且该方法需要手动编写所有硬件访问函数的替换。Avatar2[38]通过调试接口将所有I/O请求从模拟器转发到实际的硬件设备，称为外设代理。在模拟器和实际设备之间传输数据会导致高达80倍的执行速度减慢[39]，并且需要特定于设备的设置。

最近，Feng等人[18]与他们的工具P2IM一起提出了外设建模，其中模糊器用于迭代地对硬件外设建模。他们的想法是首先从fuzzer获取输入数据，然后在模拟器中执行嵌入式应用程序。对于每次在I/O地址空间上发生的读取，都会应答一部分模糊测试数据，直到执行卡住或输入缓冲区耗尽。因此，fuzzer了解哪些值对于固件的进一步执行是必需的，因为它随后实现了更多的代码覆盖。Jetset[28]、µEmu[60]和Fuzzware[46]采用并完善了这一理念。尽管外围建模方法被认为是开箱即用的，但尚不清楚这些发现的可转移性如何。根据我们的经验，像USB这样更复杂的输入接口会给外设建模带来巨大的问题，正如我们在评估中所示。

其他基于硬件的覆盖引导模糊测试方法仅适用于特定设置。Harzer Roller[4]将函数跟踪和堆栈粉碎（smashing）检测注入到闭源目标文件中。然而，这缺乏细粒度的代码覆盖，并且再次需要更改程序代码的能力。Boersig等人[7]使用源代码检测，并通过调试接口传输数据。同样，这需要能够更改程序代码，并且仅适用于ESP32微控制器。最后，µAFL[31]使用ARM的跟踪机制Embedded Trace Macrocell (ETM)[54]和兼容的跟踪硬件。然而，这样的跟踪硬件是昂贵的，而且很少可用。

### 2.3 调试器和断点
调试器是观察程序执行的常用工具，特别是用于理解意外的程序行为。一种流行的用户程序调试器是GDB[33]。它允许在期望的点上停止目标程序的执行，检查内存值，以及单步执行代码。微控制器具有不同类型的调试接口，例如联合测试行动组(JTAG)端口。使用这样的端口，调试探针可以直接访问硬件。调试探针可以实现GDB远程存根，这样GDB就可以通过GDB远程串行协议执行调试操作[21]。通常，GDB运行在程序员的PC上，该PC承载着开发环境和应用程序的源文件。根据我们的观察，GDB远程存根是由大多数可用的板上和板外微控制器调试器实现的[35]，例如来自Segger[47]，STMicroelectronics[49]或Lauterbach[30]。因此，它可以作为深入了解嵌入式系统执行情况的通用方法。

商业设备上的调试接口一般是关闭或禁用的，以防止攻击。然而，过去已经多次证明，使用故障注入攻击(如电源或时钟故障)可以重新打开禁用的调试接口[29,48]。此外，来自商用设备的固件可以传输到具有可访问调试接口的等效开发板，从而启用调试。

调试器使用断点在需要的位置停止执行[57]。软件断点是通过用一个不同的指令字替换软件二进制中的原始指令来实现的，该指令字在执行时触发中断。在恢复执行时，调试器重新插入原始指令。因此，软件断点需要重写目标程序的一小部分。

连续重写内存需要时间，并且会损耗设备的(闪存)内存。如果程序存储在只读存储器中，则不可能进行这种重写。因此，微控制器通常具有许多硬件断点。硬件断点对应于微处理器上的实际寄存器，一旦激活，当程序计数器值等于其寄存器值时中断程序执行。因此，可以将硬件断点设置为任何程序地址，而不管相应代码存储在哪种内存类型中。

有一些方法使用软件断点来测量代码覆盖率并获得模糊反馈，以避免源代码插桩的开销和障碍[25,40,41]。其思想是将软件断点插入到未到达的基本块中，从而允许程序以全速执行，直到到达新的覆盖范围。一旦执行遇到断点，相应的指令将从二进制文件中删除，以避免进一步的开销。Oh等人[44]使用软件断点来测量嵌入式固件中的代码覆盖率。它们在编译过程中提取程序的每个基本块的起始地址，并在每个地方插入软件断点，一旦遇到断点也将其删除。

## 3.控制流程图
由于我们希望利用硬件断点进行模糊反馈，我们首先需要确定目标程序驻留在哪个内存地址。简单地说，可以考虑设备可执行内存区域内的所有地址。然而，只有一小部分内存地址包含实际执行的指令，使得简单的解决方案对模糊反馈无效。因此，与最先进的覆盖率引导的模糊器类似，我们在目标程序的基本块级别上工作。此外，我们从目标程序中提取了一个控制流图(CFG)，它将基本块表示为节点，并将它们之间可能的过渡描述为边。正如我们在本节的其余部分中所展示的那样，这使我们能够推导出CFG的支配关系，这有助于我们减少模糊测试期间断点中断的数量，并避免不必要的开销。
### 3.1 控制流图的支配子关系
支配关系进一步描述了控制流图中节点之间的一致性。我们使用Agrawal[1]中的前后支配（pre- and postdominator）概念，并假设控制流图G恰好有一个入口点(entry point)和一个出口点(exit point)。

定义1（Predomination）。一个节点$u\in G$ 前向支配（predominates）另一个节点$v \in G$，表示为$u \xrightarrow{pre} v$，如果每一条从入口节点（entry note）到$v$的路径都包含$u$。

定义2（Postdomination）。一个节点$w \in G$ 后向支配（postdominates）另一个节点$v \in G$，表示为$w \xrightarrow{post} v$，如果每一条从$v$到退出节点（exit note）的的路径都包含$u$。

支配子关系可以表示为支配子树，并且对于函数可以有效地计算[9]。后支配树等于反向控制流图[1]中的前支配树。从任意前、后支配子树，我们可以得到关于其他节点的传递知识:

定理1(可达性)。如果节点v是可达的，所有在前支配树中的所有父节点先前已经被到达，并且所有后支配树种的父节点之后将被到达。

### 3.2 过程间控制流程图和支配子关系
过程间控制流程图描述了整个程序中基本块的可能转换，而不仅仅是函数。原则上，我们可以通过添加所有调用和返回指令作为边来连接程序中每个函数的控制流图(local CFG)。但是，当函数有多个调用者时，这会引入歧义，因为它创建了从每个调用函数到每个返回点的路径。当遍历生成的过程间控制流图以计算支配图时，返回边必须只指向当前函数的实际调用位置，这需要上下文敏感算法[2,10]。已发布的上下文敏感算法很复杂，而且实现很少可用。GDBFuzz使用支配关系来减少开销，因此我们开发了以下简单的方法。

我们构造了一个半过程间控制流图，其中我们通过将所有调用作为从调用点到被调用方的边插入来连接函数控制流图。在构建半程序间CFG时省略了返回边，因此不会引入错误的流。

对于反转的半过程间控制流图，我们反转local CFG，跳过调用边，只添加返回边。同样，我们通过移除上下文敏感的调用边来避免插入歧义。利用局部控制流图算法，可以有效地计算出相应的半过程间支配树。与完整的过程间支配图相比，在最坏的情况下，我们可能会错过每个调用边缘的一个支配关系，这应该不会真正损害模糊性能。

为方便起见，我们合并前后支配图:${(u,v)|u \xrightarrow{pre} v \vee u post \xrightarrow{post} v}$，要求我们只处理整个目标程序的一个主图。

## 4.设计
如图2所示，GDBFuzz利用目标程序的控制流图将可用的硬件断点设置为随机选择的尚未到达的基本块。然后，它通过对语料库中随机选择的输入应用突变来重复地生成测试用例，并将测试用例发送到目标输入接口。如果调试探针发出命中断点的信号，GDBFuzz将相应节点及其主导节点标记为已到达，并将负责的测试用例添加到语料库中。导致崩溃或超时的测试用例被单独保存。如果在预定义数量的运行测试用例之后没有发生断点中断，GDBFuzz将硬件断点重新定位到新选择的节点。每次重新定位之后，GDBFuzz首先再次测试语料库中的所有输入，以检查它们是否已经到达了新的目标基本块。与使用完整代码插装的覆盖引导模糊测试一样，进化算法使输入语料库随着时间的推移而增长，输入到达不同的代码区域。

![](Fuzzing%20Embedded%20Systems%20Using%20Debug%20Interfaces/image-20231127150916538.png)

本节的其余部分将介绍如何提取CFG，如何在目标应用程序中找到模糊测试入口点，以及如何在执行期间检测和处理错误。

### 4.1 提取控制流图
由于编译器知道整个控制流程，所以在程序编译过程中可以很容易地得到控制流程图。然而，GDBFuzz设计用于二进制文件，以扩大其适用性，因为源代码可能不适用于嵌入式系统上的所有软件组件。Ghidra[42]是一个开源的逆向工程工具，它支持大多数常见的处理器架构，是可编写脚本的，因此非常适合我们的需求。像所有的二进制反汇编方法一样，Ghidra不能保证检测到所有的控制流，特别是当涉及到间接分支或激进的编译器优化时[45]。因此，我们在模糊过程中迭代地改进和更新控制流图，我们在第5节中描述。

### 4.2 寻找入口点
我们将模糊测试集中在固件中的一个区域，在那里我们的目标输入接口的输入处理发生。因此，提取的CFG应该从输入处理的开始处开始，称为入口点。选择入口点是测试工程师的任务，因此他们需要了解目标。然而，下面这种半自动化的寻找合适入口点的方法在我们的分析中被证明是有用的。

(1)向目标设备发送测试输入，并立即中断执行。

(2)使用gdb find在设备内存中重新发现发送的输入。

(3)将数据观察点设置为重新发现的输入数据的第一个地址。

(4)重新发送测试输入。

(5)当前发生中断上的所有程序计数器地址都是入口点的候选地址。

这些步骤执行一次，作为GDBFuzz设置的一部分。

GDBFuzz还可以使用包含在二进制文件中的符号名作为入口点，以避免每次重新编译后都需要搜索入口点。这在持续集成设置中特别有用，这样新的软件版本可以无缝地模糊化。

### 4.3 检测Bugs
Bug oracle检测在执行过程中是否触发了一个Bug。由于模糊测试起源于测试用户应用程序，一个常见的错误预测是观察目标进程的错误信号，例如：分割的缺点。为了找到不直接触发错误的bug，使用了sanitizers和assertions。这些通常在编译时部署，但也有直接将杀毒器注入二进制文件的方法[11]。然而，更复杂的bug oracles仍然是一个开放的研究问题[5]，超出了本工作的范围。

