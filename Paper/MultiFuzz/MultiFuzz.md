# MultiFuzz: A Coverage-Based Multiparty-Protocol Fuzzer for IoT Publish/Subscribe Protocols

# 翻译
## 摘要
发布/订阅模型在物联网(IoT)网络中得到了突出的应用，消息队列遥测传输(MQTT)和约束应用协议(CoAP)都支持该模型。然而，现有的基于覆盖率的模糊器在对此类发布/订阅协议进行模糊测试时可能会遗漏一些路径，因为它们隐式地假设协议中只有两方，而现在这是不正确的，因为有三方，即发布者、订阅者和代理。本文提出了一种新的基于覆盖的多方协议模糊器MultiFuzz。首先，它在单个输入中嵌入多个连接信息。其次，它使用消息突变算法来刺激协议状态转换，而不需要协议规范。第三，它使用一个新的desockmulti模块将网络消息馈送到被测程序中。desockmulti类似于社区广泛使用的工具desock (Preeny)，但它是专门为模糊测试设计的，速度快10倍。我们基于AFL实现MultiFuzz，并使用它对两个流行的项目Eclipse mosquito和libCoAP进行模糊处理。我们向项目报告发现的问题。此外，我们将MultiFuzz与AFL和两个最先进的fuzzers, MOPT和AFLNET进行比较，发现它发现了更多的路径和崩溃。
**关键词**:基于覆盖率的模糊测试;网络协议;发布/订阅;multiparty-protocol fuzzer;MQTT;CoAP;物联网;Preeny;安全;desock

## 引言
模糊测试[1,2]是发现程序漏洞的重要方法。模糊测试的基本思想是将不同的输入输入到被测程序(PUT)中，并持续监控其状态以防止任何不当行为。基于覆盖率的模糊分析[3-5]被归类为灰盒模糊分析[2,6]。与传统的黑盒模糊测试不同[7,8]，基于覆盖率的模糊测试监控输入的内部执行路径，如果输入执行了任何新的和有趣的路径，则将其保存为进一步的突变种子。尽管基于覆盖率的模糊测试通常不像白盒模糊测试那样需要复杂的程序分析或程序输入语法[9]，但事实证明，它能够逐步测试程序的不同部分，并发现许多漏洞[3]。现在，基于覆盖率的模糊测试既被安全行业使用[3,10]，也被学术界研究[5,11 - 16]。

为了适应物联网的独特需求，在物联网领域提出了不同的网络协议[17-20]，有几个重要的协议支持发布/订阅模型[19]。例如，消息队列遥测传输(MQTT)协议[21]使用发布/订阅模型作为其核心设计，约束应用协议(CoAP)[22]支持通过使用协议扩展来“观察”资源(类似的发布/订阅模型)[23]。发布/订阅模型为物联网网络提供了松耦合和可扩展性[19]:(i)发布者和订阅者不需要知道彼此的存在，也不需要同时在线;(ii)一个发布者可以向多个订阅者发布数据，一个订阅者可以从多个发布者订阅数据，即支持多对多通信模型。本文主要研究MQTT和CoAP两种发布/订阅协议的模糊测试。它们广泛应用于物联网网络，也得到亚马逊和微软等物联网云提供商的支持[24,25]。

目前，网络协议模糊测试主要有两种方法。第一种方法属于黑盒模糊[19]。它包括一般的模糊测试工具，如Boofuzz (Sulley)[26]和Peach[8]，以及为特定协议设计的工具，如tls - attack[27]。这些工具通常需要用户编写脚本或代码来描述网络消息的格式和协议状态的转换。它们需要协议方面的专业知识来获得良好的模糊测试结果，并且当协议有新版本时，脚本和代码需要相应地更新。第二种方法属于灰盒模糊，即将基于覆盖率的模糊工具应用于网络协议的模糊测试。这种方法更有前途，因为它通常不需要了解协议规范或编写代码。然而，它需要一种方法来将模糊测试输入输入到被测网络程序中。一种方法是使用desock (Preeny的一个模块)[28]来钩子套接字函数，如socket()和accept()(由AFL[3]推荐，无需修改代码)。钩子通常由LD_PRELOAD完成，然后劫持返回给PUT的套接字，将数据发送(或接收)到(或从)标准输出(或标准输入)。我们将在后面的4.4节中进一步解释desock的设计。另一种方式是通过AFLNET等普通套接字发送输入[15]。最后一种方法是修改程序源代码，使程序直接从内存缓冲区读取数据包，而不是从真实的网络接口读取数据包，如Google OSS-Fuzz项目中的模糊openssl[10]。前两种方法可能会引入性能瓶颈(稍后我们将在第5.4节中介绍)。最后一种方法可能不是微不足道的，因为修改可能需要代码重构。

> 1.黑盒模糊测试。Boofuzz (Sulley)和Peach
> 2.灰盒模糊测试。
> 2.1使用desock钩取套接字函数，将数据发送转移到标准IO
> 2.2AFLNET普通套接字发送数据
> 2.3修改程序源码，使从缓冲区读取数据包

我们可以看到，基于覆盖的模糊器在模糊之前需要较少的准备，然而，在使用它们模糊物联网中的发布/订阅协议时，还有另一个特殊的问题。现有的基于覆盖的模糊器隐含地假设网络协议中只有两方(模糊器在模糊另一方时假装是一方)，但在发布/订阅协议中有三个方。考虑图1中MQTT协议的一个典型流程[21,29]，订阅者首先订阅传感器/温度主题。当发布者向主题发布一个值时，订阅者稍后将收到发布的值。现有的基于覆盖的模糊器无法模拟这样的过程，这是因为模糊检测输入中只包含单个连接的消息，并且模糊器对每个输入只启动单个连接[3,10,15]。因此，即使模糊器成功地模拟为订阅者并在流程中发送第一条SUBSCRIBE消息，它也无法接收第三条PUBLISH消息，因为在执行模糊测试期间没有发布者发送第二条PUBLISH消息(同时，在模糊测试下的代理服务器会为每个输入重新启动)。如果模糊器碰巧订阅了一些内置主题，它可能会收到PUBLISH消息，但是它不能让代理服务器运行图1所示的整个动态发布/订阅过程。如果代理服务器中相应的执行路径中存在漏洞，则模糊器无法发现它。因此，总的来说，现有的基于覆盖范围的模糊器并不适合这种多方协议。

![](images/Pasted%20image%2020230516094933.png)

在本文中，我们提出了一个基于覆盖的多方协议模糊器，称为MultiFuzz。我们将MultiFuzz与表1中的现有fuzzers进行比较。MultiFuzz不需要任何协议规范，也不需要用户编写任何代码。它可以启动多个连接到一个PUT，这使它能够模糊物联网发布/订阅协议，如MQTT和CoAP(请注意，现有的灰盒模糊器，如AFL[3]和AFLNET[15]仍然可以用来模糊发布/订阅协议，即启动一个到PUT的连接来模拟协议中的一方，尽管它们本质上可能会错过一些路径，正如我们前面所示。像Boofuzz (Sulley)[26]这样的黑匣子模糊器在每次模糊输入后不会重新启动PUT;因此，它们自然支持多方协议，因为它们可以通过使用多个模糊测试输入来模拟到PUT的多个连接)。MultiFuzz有一个新的模块desockmulti来将网络消息馈送到PUT，并且比desock (Preeny)快10倍。为了刺激网络协议的状态转换，MultiFuzz首先使用消息突变算法在更高的级别上对输入进行突变。MultiFuzz是基于覆盖率的，因此它属于灰盒类别。

![](images/Pasted%20image%2020230516095303.png)

具体来说，我们的论文做出了以下贡献:
- 我们提出了一个多方协议模糊器MultiFuzz，以良好地支持发布/订阅协议的模糊。fuzzer可以启动多个到PUT的连接，并且具有新的种子格式，用于将连接的所有消息存储在单个种子输入中。
- 我们提出了一种消息突变算法来改变种子输入中的消息序列，以有效地刺激协议的状态转换。突变算法还考虑存储在种子中的多个连接。
- 我们设计并实现了将网络消息馈送到PUT的desockmulti。以前社区通常使用Preeny的desock模块和AFL来模糊网络服务，但是desock只支持一个连接。我们使用新的设计来支持多个连接，并进一步优化desockmulti，使其比广泛使用的desock工具快10倍(第5.4节)(我们计划在本文发表后将desockmulti开源)。
- 我们基于AFL实现MultiFuzz，并使用MultiFuzz模糊两个流行的项目，Eclipse mosquito (MQTT代理)[29]和libCoAP (CoAP库)[30]。我们向项目报告了我们发现的漏洞，并得到了认可(第5.5节)。我们还表明，MultiFuzz在查找程序路径和崩溃方面优于AFL，以及最先进的模糊器MOPT[14]和AFLNET[15](例如，在对Eclipse mosquito进行模糊测试时，查找程序路径比AFLNET高44.6%，比AFL高126.6%，比MOPT高125.4%)。

本文的其余部分组织如下。在第二节中，我们回顾了相关工作。然后，在第3节中，我们将简要介绍MQTT和CoAP。在第4节中，我们详细描述了MultiFuzz。第5节给出实验结果，第6节对论文进行总结。

## 2.相关工作
模糊测试[1,2,6,31]现在是一种广泛使用的发现程序漏洞的技术。模糊测试的基本思想是将不同甚至异常的输入输入到PUT中，并持续监控其状态，以检查程序是否崩溃或行为不当[1]。Fuzzers可以分为三类:黑箱、灰箱和白箱[2,6]。Blackbox fuzzers[7,8]只能监测PUT的输入/输出，其中一些如Peach可能知道输入的结构[8]。大多数传统的模糊器都属于这一类[2]。白盒模糊器[9,32]使用更多的PUT内部信息，例如，通过符号执行。灰盒探员采取中间方式，他们从PUT收集一些内部信息。例如，基于覆盖率的fuzzers收集输入的覆盖率信息[2,6]。灰盒fuzzers通常比白盒fuzzers运行得更快，比黑盒fuzzers利用更多的信息[6]，如果我们想要更高的覆盖率和发现“隐藏的”bug[6]，灰盒fuzzers是不错的选择。AFL[3]、libFuzzer[4]等现代fuzzer就属于这一类。灰盒模糊(主要基于覆盖率)已经广泛应用于安全行业[3,10]。这也是一个热门的研究课题;提出了AFLFast[5]、CollAFL[11]、Angora[12]、QSYM[13]、MOPT[14]、IJON[16]等多种fuzzers。

对网络协议(即网络服务/程序)进行模糊测试是非常困难的[15]。这是因为输入是消息序列，而不是传统模糊测试中的单个文件，并且需要一种将输入提供给PUT的方法。现有的网络协议模糊测试方法可分为两类:

- 黑箱网络协议模糊测试[19]。它包括通用协议模糊测试工具，如SPIKE[33]、PROTOS[34]、SNOOZE[35]、LZFuzz[36]、Boofuzz (Sulley)[26]和Peach[8]，以及为某些协议专门设计的工具，如针对传输层安全(TLS)协议的TLS- attack[27]和针对Modbus协议的MTF[37]。这些工具大多需要用户告知网络消息的格式，有些工具还支持用户提供协议状态的转换规则[8]。对于通用协议模糊工具，用户需要通过脚本[26,33,34]或xml文件[8,35]提供这些信息。对于专门为某些协议设计的工具，这些信息由工具开发人员提供。这些工具中的大多数都假装客户端向网络程序提供输入，而LZFuzz[36]等一些工具充当中间人(MITM)代理来修改客户端和服务器之间的消息。黑盒模糊测试通常需要根据协议规范编写脚本、xml文件或代码，并且需要在协议有新版本时对其进行相应的更新。此外，与灰盒和白盒模糊测试相比，黑盒模糊测试可能更适合于发现“浅层”漏洞[6]。
- 灰盒网络协议模糊测试[3,10,15]。一般的基于覆盖的模糊工具，如AFL[3]和libFuzzer[4]，也用于模糊网络协议。通常用户不需要知道协议规范或编写任何脚本/代码，相反，他们准备(例如，通过记录)一些消息作为种子输入。然而，由于像AFL[3]这样的工具被用于使用文件/标准输入/内存缓冲区作为输入源来模糊化程序，它们需要一些方法来将模糊化输入馈送到网络程序中。现在有三种已知的方法。AFL建议使用基于钩子的工具Preeny (desock)[28]，将stdin直接重定向到被该工具劫持的套接字[3]，AFLNET[15]通过普通套接字向网络程序发送输入，用户也可以修改程序源代码，使程序直接从内存缓冲区读取数据包，而不是从真实的网络接口读取，就像Google的osss - fuzz项目对openssl所做的那样[10]。前两种方法可能会限制模糊测试的执行速度(与本文提出的desockmulti工具相比)。如果程序的原始开发人员不期望这样的修改，那么第三种方法可能是困难的，并且对于闭源程序也是不可能的。最近的一项工作AFLNET[15]提出将基于覆盖率的模糊与自动状态模型推理相结合。当模糊测试生成新的消息序列来覆盖新的状态时，推断的状态模型指导如何进行模糊测试。AFLNET在代码覆盖和漏洞发现[15]方面都优于Boofuzz[26]和AFL[3]。但是，它要求用户编写代码来提取部分信息，例如从消息中提取响应代码。

最近也有一些关于物联网领域的模糊测试的研究。IoTFUZZER[38]是一种新的黑匣子模糊器，它利用控制物联网设备的移动应用程序在没有协议规范的情况下进行协议模糊。它通过改变数据源间接地改变协议字段(例如，字符串常量和来自系统api的输入)。IoTFUZZER需要移动应用程序来模糊网络协议，并且也仅限于与移动应用程序相关的功能模糊。FIRM-AFL[39]使用AFL来模糊物联网固件，并使用增强过程仿真以更高的速度模糊程序。它主要关注物联网固件中普通程序的模糊测试，而不是网络协议。在[40]中，作者提出了一种基于模板的模糊方法来模糊MQTT协议。模糊器位于客户机和代理之间的中间人位置，它选择性地改变与指定类型匹配的数据包(例如，PUBLISH消息)。它为用户提供了模板来决定哪些字段需要改变，以减轻编写代码的负担，就像Boofuzz[26]一样。但是，用户仍然需要知道协议的规范(例如，数据包类型)。mqtt_fuzz[41]是一个用于模糊MQTT代理服务器的开源工具。它可以生成用于模糊测试的大多数MQTT数据包。但是，它已经五年没有更新了，不支持2019年发布的MQTT 5.0版本[21]，更不用说本文研究的CoAP协议了。

## 3. MQTT和CoAP简介
MQTT[21]和CoAP[22]是物联网中提出的两个重要的应用层网络协议[17-20]。MQTT是一个发布/订阅模型协议，而CoAP同时支持请求/应答和发布/订阅模型[19,42,43]。发布/订阅模型提供了对物联网网络至关重要的好处，如松耦合和高可扩展性[19]。这两种协议(尤其是MQTT)现在广泛应用于物联网网络[44,45]，也得到了亚马逊、微软和谷歌等物联网云提供商的支持[24,25]。

MQTT[21]是一个发布/订阅消息传输协议。它重量轻，设计简单。它需要很小的代码占用和有限的网络带宽。缺省情况下，协议运行在TCP上。它的客户机可以是发布其他客户机可能感兴趣的应用程序消息的发布者，也可以是请求自己感兴趣的应用程序消息的订阅者。它的服务器充当发布应用程序消息的客户机和进行订阅的客户机之间的中介(代理)(有关其体系结构，请参见图1)。MQTT传递的信息基于主题，主题使用主题级分隔符(即“/”)在主题名称中引入结构。当订阅者发送订阅时，他们使用主题过滤器，其中可能包含通配符(即多级通配符“#”或单级通配符“+”)，因此他们可以订阅多个主题。但是，当发布者发送发布消息时，他们只能使用主题名(不包括通配符)。

在MQTT的发布消息中，它可以指示三个QoS级别中的一个:0表示最多传递一次(消息是尽最大努力传递的，可能会发生消息丢失)，1表示至少传递一次(消息保证到达，但可能发生重复)，2表示只传递一次(消息保证只到达一次)。一个MQTT控制包由三部分组成[21]:固定头(Fixed Header)出现在所有MQTT控制包中，可变头(Variable Header)和有效载荷(Payload)出现在一些MQTT控制包中。在MQTT v5.0中，总共有15种类型的MQTT控制数据包(AUTH类型是在v5.0中新添加的)。我们将它们列在表2中。我们可以看到，大多数这些数据包都是成对的(即，一个CONTROL命令和它的ACK)，除了QoS 2，有3个ACK来确保只传递一次。

![](images/Pasted%20image%2020230516100825.png)

CoAP[22]是一种针对受限环境的专用web传输协议。它遵循Web的REST(具象状态传输)体系结构，但针对机器对机器(M2M)应用程序进行了优化。它默认绑定到UDP，但也可以绑定到TCP[46]。从逻辑上讲，它可以被视为一个两层协议，一个是用于处理UDP和异步交互的CoAP消息传递层，另一个是用于rest风格方法和响应代码的请求/响应层。在消息传递层，CoAP定义了四种类型的消息:可确认的、不可确认的、确认的、重置的。例如，将消息标记为可确认的(conmable)可以为上层提供可靠性。在请求/响应层中，CoAP像HTTP一样定义和使用GET、PUT、POST和DELETE方法，并使用令牌字段来独立于底层消息传递层匹配对请求的响应(底层消息传递层使用Message ID字段实现类似目的)。CoAP还定义了一个类似HTTP的URI方案，带有前缀“CoAP://”(或者其他变体，如tcp传输层情况下的“CoAP +tcp://”)。

CoAP协议也支持选项，它使用Observe选项使CoAP客户端可以在发布/订阅模型中“观察”资源[23]。这个过程可能如下。客户端向服务器发送扩展GET请求(Observe选项设置为0)，以注册其对资源的兴趣。每当资源的状态发生变化时(例如，来自其他人的PUT请求)，服务器通过响应通知每个观察客户端。在响应中，令牌与原始GET请求中的令牌相同，并且将Observe选项设置为用于重新排序检测的序列号。

MQTT和CoAP协议的安全性非常重要，因为它们可能部署在敌对环境中。两者都可以通过TLS或DTLS(数据报传输层安全)来保护，这取决于是使用TCP还是UDP作为传输层协议[21,22]。还可以增加客户端和服务器之间的相互认证[21]。研究人员还正式验证了协议[47]，研究了可能的攻击[48]，并提出了入侵检测[49]。

## 4. MultiFuzz
在本节中，我们首先概述MultiFuzz，并在后面的小节中详细描述其技术。

### 4.1 概述
MultiFuzz的基本思想是使模糊器在对单个种子进行模糊测试时支持多个连接。因此，它可以模拟物联网发布/订阅协议(以及其他多方协议)的过程，因为在模糊测试期间，每个连接可以代表协议中的任何一方。我们从种子输入到PUT的执行进行必要的更改。

我们在图2中展示了MultiFuzz的体系结构。它类似于其他基于覆盖的fuzzers，如AFL [3] (MultiFuzz是基于AFL实现的)，也可以分为四个模块。不同的部分用黄色网格突出显示。首先，种子池存储所有初始种子输入和新发现的有趣输入。MultiFuzz包含一种新的种子格式，将多个连接的信息存储在一个种子中。其次，调度模块从种子池中选择种子发送给突变模块。调度模块稍后还与执行和监视模块一起检查具有有趣路径的任何新输入，并将这些新输入保存到种子池中以供将来使用。“MultiFuzz”中的调度模块不变。第三，突变模块对种子输入进行突变，并将其发送给执行和监控模块。在AFL[3]中，突变模块可以进一步分为三个阶段:确定性阶段(使用一些预定义的操作，如“bitflip”和“arithmetic inc/dec”)，破坏阶段(使用先前的操作进行堆叠更改)，剪接阶段(将随机选择的种子与另一个种子拼接)。确定性阶段需要很长时间，可以通过使用" -d "选项跳过。MultiFuzz在浩劫阶段之前添加了一个新的消息突变阶段，以便在更高的级别上进行消息感知突变。执行和监视模块执行PUT并向其提供输入，并监视结果，如任何崩溃或其他错误行为。该模块以前可能使用desock (Preeny)[28]来挂钩套接字函数，以便将输入馈送到PUT中，但MultiFuzz使用更快且面向多连接的工具desockmulti代替。

![](images/Pasted%20image%2020230516101148.png)

### 4.2 利用多连接信息增强种子

### 4.4 desockmulti，一个快速和面向多连接的反套接工具
由于MultiFuzz的种子输入具有不同的格式，并且是面向多连接的，因此我们需要一个新的工具来将输入提供给PUT。社区通常使用Preeny[28]的desock模块与AFL[3]一起工作(AFL[3]推荐无需修改代码)。desock使用LD_PRELOAD来挂接socket()、bind()、listen()和accept()函数。它使用两个线程将套接字对同步到标准输入和标准输出。然而，它的设计使它无法接受一个服务器的多个连接(因为所有新的套接字将通过dup()调用从套接字对复制)。此外，Preeny的最初目的是与本地二进制文件交互;因此，它没有针对模糊测试进行优化。例如，desock使用poll()从stdin中读取数据。然后，首先它需要一个额外的线程来继续调用poll()。其次，这是不必要的，因为在模糊测试中，一次提供整个输入，不需要poll()调用。我们发现desock的性能在模糊测试中确实是有限的(第5.4节)。

我们设计并实现了一个新的工具，desockmulti。它有以下优点:
- desockmulti支持新的种子格式。
- desockmulti可以向PUT发起多个连接(即一个或多个)，它可以替代desock, desock只能发起一个连接。
- desockmulti针对模糊测试进行了优化，比desock快10倍。

我们详细介绍了desockmulti的设计。它也使用LD_PRELOAD来挂接主要的套接字函数socket()、bind()、listen()和accept()，并使用UNIX套接字来模拟原始的INET/INET6套接字。然而，desock和desockmulti中套接字的关系是不同的，如图5所示。在desock中，只使用socketpair()系统调用创建的单个套接字对。这对套接字中的一个被返回到PUT(尽管该套接字可以通过钩接的accept()函数中的dup()复制到其他文件描述符)，而另一个套接字的读流和写流由两个线程分别同步到标准输出和标准输入。在desockmulti中，为多个连接创建多个套接字对，并将每个套接字对中的一个套接字返回给PUT。然而，这些套接字对不是由socketpair()系统调用创建的，而是由普通的connect()和accept()调用创建的。这是因为多次accept()调用是使PUT像往常一样处理多个新连接的唯一有效方法。此外，其他钩接字函数也以更“真实”的方式工作。例如，在钩接的bind()中，我们实际上是在一个地址绑定套接字。

![](images/Pasted%20image%2020230516101725.png)

我们主要通过以下优化来提高desockmulti的性能:(i)我们阅读所有的内容一次种子不使用poll(),因为在模糊测试期间不需要交互,(ii)我们移除了调用很慢的dup2()调用,(iii)我们使用抽象的套接字地址(https://www.man7.org/linux/man-pages/man7/unix.7.html)在Linux系统中来移除套接字与普通文件系统的关系,(iv),我们删除在新的设计不必要的线程使用,即使我们使用connect()和()来创建套接字对。我们通过分析(例如，跟踪和详细日志记录)发现了一些优化(例如，(ii)和(iv))。与desock相比，desockmulti有更多的优化，如(i)， (ii)和(iv)，这使得它在模糊测试中速度提高了10倍(章节5.4)。

### 4.5 其他实现细节
## 5. 评估
### 5.1 实验设置
为了评估MultiFuzz，我们选择了两个著名的MQTT和CoAP协议实现，Eclipse mosquito[29]和libCoAP[30]。Eclipse mosquito[29]是一个实现MQTT协议5.0[21]、3.1.1和3.1版本的消息代理。它还提供了mosquito - to_pub和mosquito - to_sub命令行MQTT客户机。我们使用最新版本1.6.10进行模糊测试。我们通过不启用TLS(使WITH_TLS=no)来构建mosquito，因为我们不想模糊TLS代码。在收集模糊种子时，我们使用mosquitto_sub和mosquitto_pub客户机连接到本地代理服务器，并分别发送订阅请求和发布请求。然后，我们使用Wireshark捕获数据包，并使用自定义Python脚本转储我们前面提到的消息。我们为Mosquitto准备了10粒种子。libCoAP[30]是CoAP的c实现，为开发资源高效的CoAP服务器和客户端提供核心功能。它支持资源观察[23]、TCP[46]、块传输、FETCH/PATCH和无响应等扩展。它提供了coap客户端和coap服务器，我们使用coap服务器作为PUT。我们使用它的最新版本4.2.1进行模糊测试。我们在构建时也禁用了TLS。由于我们的desockmulti还不支持UDP (desock也不支持)，我们使用TCP作为CoAP-client和CoAP-server的传输层协议。为了收集种子，我们使用两个cap -client实例分别观察和放置资源(实现资源观察)。按照同样的方法，我们得到了libCoAP的31个种子。我们还在没有启用地址消毒器(ASan)[50]的情况下构建了两个项目，以提高模糊测试的速度，后来我们在构建它们时启用了用于分析崩溃和程序路径的ASan(我们在本文中没有考虑数据竞争或竞争条件的检测，因此我们没有使用像ThreadSanitizer这样的消毒器，也没有专门设计任何机制来提高并发性)。

与AFL类似，MultiFuzz可以在控制台中使用以下命令运:`LD_PRELOAD=/path/to/desockmulti/desockmulti.so ./afl-fuzz -l 0 -d -i testcase_dir -o findings_dir ——/path/to/program […]` ，其中“-l”表示启用前面提到的MultiFuzz，“0”表示普通初始化种子情况(“1”表示新格式初始化种子情况，即图3所示的格式)。

我们选择了AFL[3]和两个最先进的fuzzers MOPT[14]和AFLNET[15]与MultiFuzz进行比较。AFL[3]是最著名的基于覆盖的fuzzers之一，我们使用它的最新版本25.2 b。MOPT是最近提出的一种模糊器，它使用粒子群优化(Particle Swarm Optimization, PSO)算法来寻找突变算子的最优概率分布[14]。AFLNET是最近提出的一种基于AFL的模糊器，但使用自动状态模型推理来处理基于覆盖的模糊[15]。AFLNET需要用户编写代码来从消息中提取响应代码，我们根据需要实现它们。基本上，我们分别使用MQTT消息的第一个字节的较高的4位和CoAP消息的第二个字节作为响应代码[21,22]。我们使用默认设置(即-D 10000 -q 3 -s 3 -K -R)运行AFLNET。我们跳过了所有模糊器(包括MOPT模糊器，它会在一段时间后自动跳过确定性阶段[14])突变期间的确定性阶段(这是AFLNET的默认配置)。我们使用Preeny的desock模块[28]与AFL和MOPT一起工作。我们还为所有的fuzzers设置了相同的种子。

所有的实验都是在一台配置了2个Intel(R) Xeon(R) CPU E5-2640 v4 @ 2.40 GHz处理器、64 GB RAM和64位Ubuntu 20.04 LTS的服务器上进行的。所有的fuzzer在单个fuzzer实例下运行2天，因为建议运行超过24小时[31]。

### 5.4 执行速度的比较
我们非常关注MultiFuzz的性能(包括消息突变算法和desockmulti模块)，并在图11中展示了不同fuzzers的执行速度(执行数/秒)，以及MultiFuzz与其他fuzzers之间的速度比较。我们使用tmpfs (https://www.kernel.org/doc/html/latest/filesystems/tmpfs.html)来存储模糊测试输出，以便更快地执行，并且像前面提到的那样，在没有启用ASan的情况下构建用于模糊测试的二进制文件。MultiFuzz的平均执行速度为1333.9 execs (mosquito)和1412.4 execs (libCoAP)。相比之下，AFL的平均执行速度分别为128.8 execs/s和94.6 execs/s，这意味着MultiFuzz比AFL快10.4倍和14.9倍。MOPT比AFL快一点，但MultiFuzz仍然比它快10.3倍和11.6倍。由于AFL和MOPT使用了Preeny的desock模块[28]，因此MultiFuzz的速度提升主要归功于新设计的desockmulti工具。MultiFuzz (SingleConn)的执行速度。)可以作为使用AFL和desockmulti的快速参考，因为只在变体中添加了一点额外的初始化工作。MultiFuzz (SingleConn)的平均执行速度。)的运行速度为1389.9 execs, libCoAP的运行速度为983.8 execs，分别比使用desock的AFL快10.8倍和10.4倍。AFLNET的执行速度比其他fuzzers慢。蚊子的执行速度只有9.0 execs, libCoAP为22.6 execs。我们认为这主要是由于AFLNET使用真正的INET网络套接字来连接到一个PUT。众所周知，INET网络套接字比UNIX套接字慢得多。此外，正如我们提到的，我们发现AFLNET生成的种子大小(数百KB)比其他fuzzers (<1 KB)大得多，这也会减慢执行速度。

## 6. 结论
本文提出了一种基于覆盖的模糊器MultiFuzz，它可以启动多个连接到被测程序，以完善地支持物联网中发布/订阅协议等多方协议的模糊测试。MultiFuzz包含一个新的种子格式、一个消息突变算法和一个新的反套接模块desockmulti。我们使用MultiFuzz对Eclipse mosquito项目和libCoAP项目进行模糊处理，并向开发人员报告我们发现的漏洞(所有漏洞都得到了承认和修复)。我们还表明，与AFL和两个最先进的fuzzers (MOPT和AFLNET)相比，MultiFuzz发现了更多的路径和崩溃。我们认为MultiFuzz并不局限于物联网发布/订阅协议的模糊化，也可以用来模糊其他多方协议。此外，我们相信MultiFuzz的desockmulti模块在开源后可以使社区受益，因为它类似于广泛使用的工具desock (Preeny)，但速度快10倍。
