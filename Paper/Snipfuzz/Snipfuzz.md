## 摘要
物联网(IoT)设备的激增使人们的生活更加便利，但它也引发了许多安全问题。由于难以获取和仿真物联网固件，在缺乏内部执行信息的情况下，对物联网设备进行黑盒模糊测试已成为一种可行的选择。然而，现有的黑盒模糊器无法形成有效的突变优化机制来指导其测试过程，主要原因是缺乏反馈。此外，由于物联网设备中普遍使用各种非标准通信消息格式，因此很难甚至不可能应用现有的基于语法的模糊测试策略。因此，在物联网模糊测试领域需要一种有效的语法推理模糊测试方法。

为了解决这些关键问题，我们提出了一种新的物联网固件自动黑盒模糊测试，称为Snipuzz。Snipuzz作为与设备通信的客户机运行，并根据响应推断消息片段是否发生了变化。每个片段指的是一个连续的字节块，它反映了模糊测试中的大致代码覆盖率。这种基于消息片段的突变策略大大缩小了更改探测消息的搜索空间。我们将Snipuzz与四种最先进的物联网模糊方法(即IoTFuzzer, BooFuzz, Doona和Nemesys)进行了比较。snizzzz不仅继承了基于应用程序的模糊测试的优点(例如，IoTFuzzer)，而且还利用通信响应来执行有效的突变。此外，Snipuzz是轻量级的，因为它的执行不依赖于任何先决条件的操作，比如应用程序的逆向工程。我们还在20个流行的物联网设备上评估了Snipuzz。我们的结果表明，Snipuzz可以识别5个零日漏洞，其中3个只能由Snipuzz暴露。所有新发现的漏洞都得到了供应商的确认。

## 1.引言
物联网(IoT)指的是全球数十亿个连接到互联网的物理设备，它们都在收集和共享数据。早在2017年，物联网设备的数量就已经超过了世界人口[39]，到2020年，地球上每个人平均拥有4台物联网设备[23]。虽然这些设备丰富了我们的生活和行业，但不幸的是，它们也以漏洞的形式引入了盲点和安全风险。我们以Mirai[25]为例。Mirai是物联网僵尸网络恶意软件中最突出的类型之一。2016年，Mirai在一场分布式拒绝服务(DDoS)攻击中关闭了广泛使用的网站，该攻击由数千台受感染的家庭物联网设备组成。在Mirai的案例中，攻击者利用漏洞攻击物联网设备本身，然后将这些设备武器化，进行更大规模的攻击或将恶意软件传播到网络。事实上，攻击者还可以利用易受攻击的设备进行横向移动，从而达到关键目标。例如，在2019冠状病毒病期间的在家工作场景中，趋势科技报告称，将易受攻击的物联网设备引入家庭将使员工暴露于可能进入公司网络的恶意软件和攻击中[26]。考虑到物联网设备的无处不在，我们认为这些已知的安全事件和风险场景只不过是冰山一角。

物联网漏洞通常是关于设备固件中的实施缺陷。为了尽快推出新产品，开发人员在固件开发中往往倾向于使用开源组件，没有良好的更新计划[1]。这牺牲了物联网设备的安全性，并使它们暴露于安全团队无法快速修复的漏洞之下。即使供应商计划修复其产品中的漏洞，由于物联网设备不具有可靠的网络连接，无线补丁通常也是不可行的[16]。因此，据报道，市场上一半的物联网设备存在漏洞[28]。

因此，在攻击者发现这些漏洞并修复它们是至关重要的。然而，大多数物联网软件安全测试严重依赖于设备固件可用性的假设。在许多情况下，制造商倾向于不发布他们的产品固件，这使得基于代码分析[7,13,15,18,32,46](或仿真[8,10,20,50,51])的各种动态分析方法变得困难。在现有的防御技术中，模糊测试已显示出克服这些问题的希望，并已被广泛用作发现漏洞的有效方法。此外，物联网设备与外界通信的能力为我们提供了一个新的选择，那就是通过交换网络消息来测试设备固件。因此，物联网模糊器可以设计成向目标设备发送随机通信消息，以检测其是否显示任何故障症状。如果在执行过程中触发崩溃或设备被推送回异常消息，则可能暴露潜在的漏洞。

然而，使用网络通信来模糊物联网设备的固件是非常具有挑战性的。由于无法从设备获取内部执行信息，大多数现有的网络物联网模糊器[9,31,44]以黑盒方式工作。这使得优化突变策略变得非常困难。由于突变种子的选择完全是随机的，现有的黑盒物联网模糊方法可能变得非常难以处理，有时甚至变得更像暴力破解测试。此外，物联网设备对通信中的输入有严格的语法规范。大多数由随机突变生成的消息将打破输入的语法规则，并且在执行之前将在固件中的语法验证期间快速拒绝。基于语法的突变策略[2,40]可以有效地生成满足输入要求的消息。这可以通过通过文档语法规范或从标记的训练集学习语法来完成。然而，如表1所示，许多非标准的物联网设备通信格式正在实践中使用。因此，为基于语法的突变策略准备足够的学习材料是一项巨大的工作量，这使得基于语法的物联网模糊的部署变得困难。

**挑战**。在本文中，我们专注于通过向物联网设备发送消息来检测物联网固件中的漏洞。为了设计一种有效的模糊方法，必须克服几个挑战。
- 挑战1:缺乏反馈机制。如果不访问固件，几乎不可能从物联网设备获取内部执行信息来指导模糊测试过程(就像大多数典型的模糊测试一样)。因此，我们需要一个轻量级的解决方案来获取来自设备的反馈，并优化生成过程。
- 挑战2:不同的消息格式。表1显示了IoT通信中使用的一些消息格式，包括JSON、SOAP、键值对、字符串甚至自定义格式。为了应用于各种设备，解决方案应该能够从原始消息中推断出格式。
- 挑战3:反应的随机性。物联网设备的响应消息可能包含随机元素，例如时间戳或令牌。这种随机性导致对同一消息的不同响应，并且降低了模糊测试的有效性，因为Snipuzz的输入生成依赖于响应。

![](images/Pasted%20image%2020230509231008.png)

**我们的方法**。在本文中，我们提出了一种新颖的自动黑盒物联网模糊测试，名为Snipuzz，用于检测物联网固件中的漏洞。与其他现有的物联网模糊测试方法不同，Snipuzz实现了基于片段的突变策略，该策略利用来自物联网设备的反馈来指导模糊测试。具体来说，Snipuzz使用一种新颖的启发式算法来检测消息中每个字节的角色。它首先逐个改变消息中的字节以生成探测消息，并对从设备收集到的相应响应进行分类。在消息中具有相同角色的相邻字节形成初始消息片段，这是突变的基本单位。此外，Snipuzz利用分层聚类策略来优化突变策略，减少响应消息随机性和固件内部机制导致的类别错误分类。因此，Snipuzz作为一个黑盒fuzzer，在没有语法规则和设备内部执行信息支持的情况下，仍然可以有效地测试IoT设备的固件。

Snipuzz通过使用响应作为优化模糊测试过程的指导来解决挑战1。基于响应，Snipuzz设计了一种新颖的启发式算法来初步推断消息中每个字节的角色，从而解决了挑战2。Snipuzz利用编辑距离[42]和聚集分层聚类[43]来解决挑战3。我们将我们的主要贡献总结如下:
- 消息片段推理机制。物联网设备的响应与固件中的代码执行路径有关。根据响应，我们推断消息片段与固件中代码执行路径之间的关系。这种新颖的突变机制使Snipuzz不需要任何语法规则就可以通过设备响应推断输入的隐藏语法结构。与实际确定输入字符串格式的语法规则相比，Snipuzz提出的片段确定结果的相似度为87.1%。
- 更有效的物联网模糊检测。在测试物联网设备时，响应类别的数量与固件中代码执行路径的数量呈正相关。在实验中，无论分析时间有多长(10分钟还是24小时)，Snipuzz在大多数设备上探索的响应类别数量都远远超过其他方法。
- 实现和漏洞发现。我们使用它来测试20个真实世界的消费级物联网设备，同时与最先进的模糊测试工具(即IoTFuzzer, Doona, Boofuzz和Nemesys)进行比较。在20台设备中的5台中，Snipuzz成功发现了5个零日漏洞，包括空指针异常、拒绝服务和未知崩溃，其中3个漏洞只能由Snipuzz暴露。

## 2.背景
### 2.1 模糊测试
模糊测试是一种功能强大的自动测试工具，用于检测软件漏洞。经过几十年的发展，模糊测试已被广泛应用于多个安全测试领域，如操作系统内核[12,36]、服务器[33]和区块链[3]。

一般来说，模糊测试为目标程序提供大量的变异输入，并监视异常(例如，崩溃)。如果执行显示了不希望的行为，则可以检测到漏洞。为了更有效地发现漏洞，模糊算法基于执行的反馈(例如，覆盖知识)来优化突变过程，而不是使用纯粹的随机突变策略。此外，fuzzers可以从反馈机制中判断每个由种子突变生成的测试用例是否“有趣”(即，测试用例是否探索了看不见的执行状态)。如果一个测试用例是有趣的，它将被保留为一个新的种子，以参与未来的突变。有了反馈，许多fuzzers[4,5,29,41,49]将计算资源引向感兴趣的测试用例，从而提高了发现漏洞的可能性。

### 2.2物联网设备通用通信架构
为了响应外部输入，大多数物联网设备都实现了类似的高层通信架构。根据图1所示的伪代码示例，通信架构的典型实现可能由四个部分组成:1)Sanitizer，2)功能Switch,，3)功能定义，4)应答器 Replier。

当物联网设备接收到外部输入时，消毒程序开始解析输入并执行常规匹配。如果输入格式违反语法要求，或者在解析过程中出现异常，则Sanitizer将直接通过发送描述输入错误的响应消息来通知Replier，并终止对输入的处理。如果输入语法正确，Function Switch将根据从输入中提取的属性Key和相应的值val将控制转移到相应的函数。如果Key不能匹配，这个输入的处理将被终止，类似于Replier做的。当Functions使用参数val完成处理(例如setFlow())时，它通知Replier生成响应消息。请注意，函数的实现是特定于物联网设备的。如上所述，Replier负责向客户端(如用户的APP)发送响应。Replier根据调用情况(由示例中的参数代码表示)确定要发送的响应消息的内容。

![](images/Pasted%20image%2020230509231957.png)

## 3.动机
### 3.1 基于响应的反馈机制
物联网设备的交互能力使得通过网络测试设备固件的安全性成为可能。然而，在使用基于网络的模糊测试器测试物联网设备时也存在一些挑战。由于大多数网络模糊测试方法不能直接获得设备的执行状态，因此很难建立有效的反馈机制来指导模糊测试过程。如果没有反馈机制，模糊测试在突变目标的选择上是盲目的，可能会倾向于暴力随机测试。

如前所述，由于缺乏开源固件，很难甚至不可能对物联网设备进行检测。因此，固件返回的响应消息可以被视为运行时设备状态信息的宝贵来源。图1中的Replier将使用变量code的值来确定响应消息的内容。code的值来自固件中许多不同的功能块。当杀毒程序无法解析输入或触发一些异常时，传递参数;或者Function Switch不能匹配输入中的关键命令字符;或在函数中执行每个输入之后。因此，通过响应消息的内容，可以推断出在固件中执行的代码块。当固件源代码不可用时，就不能直接提取固件执行和响应消息之间的对应关系。此外，即使执行不同的功能，固件也可能返回相同的响应消息。

虽然不能将响应消息等同于设备的执行路径，但它仍然可以在物联网设备的黑盒模糊测试中发挥重要作用。虽然很难将对应于每个响应消息的代码执行路径链接起来，但如果两个输入得到不同的响应消息，我们可以推断两个输入进入不同的固件代码执行路径。

我们的方法。Snipuzz使用响应消息建立新的反馈机制。Snipuzz将收集每个响应，当发现新响应时，与响应对应的输入将作为后续突变测试的种子排队。

### 3.2消息片段推断
物联网设备的固件可以看作是一个对输入有严格语法要求的软件程序。如果在模糊测试中使用基于字节的突变策略(例如逐个改变输入中的每个字节或随机选择字节进行突变测试)，则生成的测试用例可能很少，无法满足输入语法需求。基于语法的fuzzers利用详细的文档或大型训练数据集来学习语法规则，并使用它来指导突变的产生[34,40]。在许多情况下，物联网设备中的输入语法多种多样或不标准。表1显示了来自不同供应商的20个物联网设备使用的通信格式要求。其中一些使用众所周知的格式，如JSON和SOAP，但有些使用键值对甚至自定义字符串作为通信格式。因此，很难为基于语法的突变策略提供涵盖大规模通信格式的语法规范或建立训练数据集。

最好的语法指导来自固件本身。来自物联网设备的响应建议消息的执行结果。如果我们一个字节一个字节地改变有效消息(即破坏格式)，我们将得到许多不同的响应。如果有效消息中两个不同位置的突变接收到相同的响应，则这两个位置很可能与固件中相同的功能相关。因此，那些具有相同响应的连续字节可以合并为一个片段。这个推断消息片段的方法可以清楚地反映每个字节进入固件后的效用。此外，基于消息片段的变异可以大大减少搜索空间，提高模糊测试的效率。

我们的方法。Snipuzz将具有相同响应的连续字节合并到一个片段中。我们还提出了在片段上执行不同的突变操作符。

## 4.方法
为了清楚地展示我们的方法，在解释Snipuzz的模糊过程时，我们首先引入一些概念。在高层次上，Snipuzz作为客户端执行，发送消息序列$M$ 来请求物联网设备的某些操作。任何消息$m \in M$ 都请求IoT设备执行某种功能，所有消息($\bigcup_{k} m_k = M$ )一起工作以请求一个(或多个)操作。与典型的fuzzers类似，我们用一个初始消息序列初始化种子$S$ ，以及包含所有种子的种子语料库$C$ (第4.1节)。同时，收集恢复消息序列，用于将物联网设备重置到预定义状态。

为了建立一个有效的模糊测试，如图2所示，Snipuzz首先执行一个代码片段确定过程。具体来说，snizz在一个种子$S \in C$ 中选择一条消息$m$ ，从中生成一条探测消息$p_i$ 和相应的序列$M_i$。$M_i$中的每个消息将触发响应消息$r_i$(简称响应)，其中包含有关执行输出的信息。Snipuzz为每条消息$m$分配一个响应池$R$，该响应池用于确定新响应$r_i$ 是否唯一。响应的唯一性表示该响应不属于响应池中存在的任何响应类别。如果$r_i$是唯一的，Snipuzz将把$r_i$添加到池$R$ 中，并保留相应的消息序列$M_i$作为新的种子。然后Snipuzz根据响应将消息$m$分成不同的片段(第4.2节)。在获得片段后，Snipuzz根据各种策略执行突变，例如，空，字节翻转，数据边界或浩劫havoc(详见4.3节)。在整个模糊过程中，Snipuzz设置了一个网络监视器来检测可能表明漏洞的崩溃(第4.4节)。

![](images/Pasted%20image%2020230510092005.png)

### 4.1 消息序列获取
初始种子的质量会显著影响模糊运动。因此，我们考虑获得符合物联网设备所需的高度结构化格式的高质量初始种子，因为这样的输入可能会执行复杂的执行路径，并扩大在深层代码中暴露漏洞的机会。基于配套应用逆向工程[9]或可访问规范(如3.2节所述)生成种子可能是直观的解决方案。然而，它们要么需要大量的工程工作，要么容易出错(例如，种子可能违反所需的格式或具有错误的消息顺序)。

**初始种子获取**。Snipuzz提出了一个轻量级的解决方案来获得初始有效的种子。考虑到许多物联网设备都有第一方或第三方API文档以及测试套件，双方提供的测试程序可以有效地充当客户端，向物联网设备或远程服务器发送控制命令。通信包的大多数结构信息(例如，报头、消息内容)和协议(例如，HTTP、HNAP、MQTT)在API程序中定义为消息有效负载。因此，Snipuzz利用这些测试套件与目标设备通信，同时提取消息序列作为初始种子。例如，当使用API程序打开灯泡时，该程序首先向服务器或物联网设备发送登录信息，然后发送消息以定位特定的灯泡设备，最后发送消息以控制设备打开灯。Snipuzz捕获这样一个触发物联网设备的功能的消息序列作为初始种子。

**恢复消息序列获取**。为了重播崩溃分类的测试用例，Snipuzz确保被测设备在每一轮测试中具有相同的初始状态。在向设备发送任何消息序列后，Snipuzz将发送恢复消息序列以将设备重置到预定义的状态。

**手动工作**。尽管我们尽了最大的努力来提供一个轻量级的模糊器，但是Snipuzz仍然需要一些手工工作来获得有效和可用的初始种子。首先，我们手动配置测试套件中的程序，例如设置IP地址和登录信息。请注意，我们只需要为每个设备配置一次这些程序。其次，为了动态捕获消息序列，我们需要在网络流量监视器中手动定义特定的格式和协议。最后，我们过滤掉一些会误导模糊过程的消息序列。例如，一些API程序提供可以自动更新或重新启动设备的操作。这些操作将使设备停止，因此不会发送回任何响应。这将导致假阳性崩溃，因为我们将无响应执行视为崩溃。每个设备的手工工作大约需要5个工时，并且只在Snipuzz的消息序列获取阶段需要。

### 4.2 片段确定
Snipuzz的关键思想是基于响应确定的片段来优化模糊测试过程。换句话说，Snipuzz利用片段突变来减少输入的搜索空间，而片段通过对来自物联网设备的响应进行分类而自动聚类。主要的挑战是正确理解响应的语义。例如，由于时间戳的存在，如果使用简单的字符串比较，两个语义相同的响应将被划分为不同的类别。因此，Snipuzz利用启发式算法和分层聚类方法来确定每个消息中的片段。****

#### 4.2.1初步判定
消息片段的本质是消息中的连续字节，它使固件能够执行特定的代码段。对于经验丰富的专家来说，根据官方文档中的语义定义对消息片段进行分段并不困难。然而，对于缺乏这种知识的算法，必须应用一些自动方法来识别消息中每个字节的含义。

Snipuzz首先使用启发式算法将每个消息粗略地划分为初始片段。启发式算法的核心思想是通过删除消息$m$ ($m \in seed \space S$ )中的某个字节来生成探测消息$p_i$。通过对每个探测消息的响应$r_i$进行分类，snizz初步确定了消息$m$中的片段。

例如，如表2所示，为了确定消息$m= \{"on":true\}$中的片段，Snipuzz通过逐个删除$m$中的字节来生成探测消息。当删除$m$中的第一个字节“{”时，对应的探测消息$p_1$ 为“on”:true}。类似地，当第二个字节被删除时，对应的探测消息$p_2$为{on":true}。因此，11字节的消息$m$可以生成11条不同的探测消息($p_1$ 到$p_{11}$ )。Snipuzz将包含探测消息的11个对应的消息序列($M_1$~$M_{11}$ )发送到设备并收集响应。

![](images/Pasted%20image%2020230510094640.png)

然后，Snipuzz通过对响应进行分类来区分消息$m$中的片段。具体来说，将具有相同对应响应类型的连续字节合并为相同的代码片段。根据表2中的示例，响应$r_1$、$r_2$ 和$r_5$ 合并到一个类别中，表示JSON语法错误，而响应$r_3$和$r_4$ 合并到另一个类别中，表示无效输入参数的错误。因此，响应属于同一类别的连续字节可以组成一个消息片段。通过这种启发式方法，Snipuzz可以确定消息$m$中的所有初始片段。

对响应进行分类的一种简单方法是利用字符串比较，即逐个字节比较响应的内容。然而，由于响应存在随机性(如时间戳和token)，简单的字符串比较可能会错误地将具有相同语义的响应区分为不同的类别。因此，引入了一个更高级的解决方案Edit Distance[42]来确定响应的类别。如式(1)所示，计算两个响应푟푘和푟푡之间的相似度得分푠푘푡。






