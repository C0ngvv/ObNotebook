## 个人小结
这篇论文主要针对比如像灯泡这样的物联网设备固件，它是一种黑盒模糊测试方法，主要是利用响应信息来推断消息片段，然后进行变异。它需要设备具有详细的响应消息，并能据此对不同的消息请求进行分类，如有效的和不同原因导致无效的。如果没有详细信息，如所有错误返回的状态都是相同的，那么就没有办法应用这种方法。

首先获取初始消息作为种子，然后依次将消息中每个字节去掉并向设备发送请求，根据设备不同的响应状态对每个字节的作用进行分类并划分片段，它还采用了分层聚类的方法来进一步提升分类的准确性，后续它对这些找到的片段实施变异进行模糊测试。

对于路由器httpd程序的模糊测试，这种方法可能不太行，因为错误的返回状态都是一样的。但所有的模糊测试都需要获得有效的初始种子。IoTFuzzer是通过配套的APP程序，FirmFuzz是通过利用浏览器自动框架触发web前端请求，这篇论文是通过组件API和配套测试程序生成的。对于路由器web，我觉得两种比较好的方式：一是利用前端自动化执行生成，二是利用字符串提取生成模糊测试字典，或采用静态分析方式生成模糊测试请求库。

## 摘要
物联网(IoT)设备的激增使人们的生活更加便利，但它也引发了许多安全问题。由于难以获取和仿真物联网固件，在缺乏内部执行信息的情况下，对物联网设备进行黑盒模糊测试已成为一种可行的选择。然而，现有的黑盒模糊器无法形成有效的突变优化机制来指导其测试过程，主要原因是缺乏反馈。此外，由于物联网设备中普遍使用各种非标准通信消息格式，因此很难甚至不可能应用现有的基于语法的模糊测试策略。因此，在物联网模糊测试领域需要一种有效的语法推理模糊测试方法。

为了解决这些关键问题，我们提出了一种新的物联网固件自动黑盒模糊测试，称为Snipuzz。Snipuzz作为与设备通信的客户机运行，并根据响应推断消息片段是否发生了变化。每个片段指的是一个连续的字节块，它反映了模糊测试中的大致代码覆盖率。这种基于消息片段的突变策略大大缩小了更改探测消息的搜索空间。我们将Snipuzz与四种最先进的物联网模糊方法(即IoTFuzzer, BooFuzz, Doona和Nemesys)进行了比较。snipuzz不仅继承了基于应用程序的模糊测试的优点(例如，IoTFuzzer)，而且还利用通信响应来执行有效的突变。此外，Snipuzz是轻量级的，因为它的执行不依赖于任何先决条件的操作，比如应用程序的逆向工程。我们还在20个流行的物联网设备上评估了Snipuzz。我们的结果表明，Snipuzz可以识别5个零日漏洞，其中3个只能由Snipuzz暴露。所有新发现的漏洞都得到了供应商的确认。

## 1.引言
物联网(IoT)指的是全球数十亿个连接到互联网的物理设备，它们都在收集和共享数据。早在2017年，物联网设备的数量就已经超过了世界人口[39]，到2020年，地球上每个人平均拥有4台物联网设备[23]。虽然这些设备丰富了我们的生活和行业，但不幸的是，它们也以漏洞的形式引入了盲点和安全风险。我们以Mirai[25]为例。Mirai是物联网僵尸网络恶意软件中最突出的类型之一。2016年，Mirai在一场分布式拒绝服务(DDoS)攻击中关闭了广泛使用的网站，该攻击由数千台受感染的家庭物联网设备组成。在Mirai的案例中，攻击者利用漏洞攻击物联网设备本身，然后将这些设备武器化，进行更大规模的攻击或将恶意软件传播到网络。事实上，攻击者还可以利用易受攻击的设备进行横向移动，从而达到关键目标。例如，在2019冠状病毒病期间的在家工作场景中，趋势科技报告称，将易受攻击的物联网设备引入家庭将使员工暴露于可能进入公司网络的恶意软件和攻击中[26]。考虑到物联网设备的无处不在，我们认为这些已知的安全事件和风险场景只不过是冰山一角。

物联网漏洞通常是关于设备固件中的实施缺陷。为了尽快推出新产品，开发人员在固件开发中往往倾向于使用开源组件，没有良好的更新计划[1]。这牺牲了物联网设备的安全性，并使它们暴露于安全团队无法快速修复的漏洞之下。即使供应商计划修复其产品中的漏洞，由于物联网设备不具有可靠的网络连接，无线补丁通常也是不可行的[16]。因此，据报道，市场上一半的物联网设备存在漏洞[28]。

因此，在攻击者发现这些漏洞并修复它们是至关重要的。然而，大多数物联网软件安全测试严重依赖于设备固件可用性的假设。在许多情况下，制造商倾向于不发布他们的产品固件，这使得基于代码分析[7,13,15,18,32,46](或仿真[8,10,20,50,51])的各种动态分析方法变得困难。在现有的防御技术中，模糊测试已显示出克服这些问题的希望，并已被广泛用作发现漏洞的有效方法。此外，物联网设备与外界通信的能力为我们提供了一个新的选择，那就是通过交换网络消息来测试设备固件。因此，物联网模糊器可以设计成向目标设备发送随机通信消息，以检测其是否显示任何故障症状。如果在执行过程中触发崩溃或设备被推送回异常消息，则可能暴露潜在的漏洞。

然而，使用网络通信来模糊物联网设备的固件是非常具有挑战性的。由于无法从设备获取内部执行信息，大多数现有的网络物联网模糊器[9,31,44]以黑盒方式工作。这使得优化突变策略变得非常困难。由于突变种子的选择完全是随机的，现有的黑盒物联网模糊方法可能变得非常难以处理，有时甚至变得更像暴力破解测试。此外，物联网设备对通信中的输入有严格的语法规范。大多数由随机突变生成的消息将打破输入的语法规则，并且在执行之前将在固件中的语法验证期间快速拒绝。基于语法的突变策略[2,40]可以有效地生成满足输入要求的消息。这可以通过通过文档语法规范或从标记的训练集学习语法来完成。然而，如表1所示，许多非标准的物联网设备通信格式正在实践中使用。因此，为基于语法的突变策略准备足够的学习材料是一项巨大的工作量，这使得基于语法的物联网模糊的部署变得困难。

**挑战**。在本文中，我们专注于通过向物联网设备发送消息来检测物联网固件中的漏洞。为了设计一种有效的模糊方法，必须克服几个挑战。
- 挑战1:缺乏反馈机制。如果不访问固件，几乎不可能从物联网设备获取内部执行信息来指导模糊测试过程(就像大多数典型的模糊测试一样)。因此，我们需要一个轻量级的解决方案来获取来自设备的反馈，并优化生成过程。
- 挑战2:不同的消息格式。表1显示了IoT通信中使用的一些消息格式，包括JSON、SOAP、键值对、字符串甚至自定义格式。为了应用于各种设备，解决方案应该能够从原始消息中推断出格式。
- 挑战3:反应的随机性。物联网设备的响应消息可能包含随机元素，例如时间戳或令牌。这种随机性导致对同一消息的不同响应，并且降低了模糊测试的有效性，因为Snipuzz的输入生成依赖于响应。

![](images/Pasted%20image%2020230509231008.png)

**我们的方法**。在本文中，我们提出了一种新颖的自动黑盒物联网模糊测试，名为Snipuzz，用于检测物联网固件中的漏洞。与其他现有的物联网模糊测试方法不同，Snipuzz实现了基于片段的突变策略，该策略利用来自物联网设备的反馈来指导模糊测试。具体来说，Snipuzz使用一种新颖的启发式算法来检测消息中每个字节的角色。它首先逐个改变消息中的字节以生成探测消息，并对从设备收集到的相应响应进行分类。在消息中具有相同角色的相邻字节形成初始消息片段，这是突变的基本单位。此外，Snipuzz利用分层聚类策略来优化突变策略，减少响应消息随机性和固件内部机制导致的类别错误分类。因此，Snipuzz作为一个黑盒fuzzer，在没有语法规则和设备内部执行信息支持的情况下，仍然可以有效地测试IoT设备的固件。

Snipuzz通过使用响应作为优化模糊测试过程的指导来解决挑战1。基于响应，Snipuzz设计了一种新颖的启发式算法来初步推断消息中每个字节的角色，从而解决了挑战2。Snipuzz利用编辑距离[42]和聚集分层聚类[43]来解决挑战3。我们将我们的主要贡献总结如下:
- 消息片段推理机制。物联网设备的响应与固件中的代码执行路径有关。根据响应，我们推断消息片段与固件中代码执行路径之间的关系。这种新颖的突变机制使Snipuzz不需要任何语法规则就可以通过设备响应推断输入的隐藏语法结构。与实际确定输入字符串格式的语法规则相比，Snipuzz提出的片段确定结果的相似度为87.1%。
- 更有效的物联网模糊检测。在测试物联网设备时，响应类别的数量与固件中代码执行路径的数量呈正相关。在实验中，无论分析时间有多长(10分钟还是24小时)，Snipuzz在大多数设备上探索的响应类别数量都远远超过其他方法。
- 实现和漏洞发现。我们使用它来测试20个真实世界的消费级物联网设备，同时与最先进的模糊测试工具(即IoTFuzzer, Doona, Boofuzz和Nemesys)进行比较。在20台设备中的5台中，Snipuzz成功发现了5个零日漏洞，包括空指针异常、拒绝服务和未知崩溃，其中3个漏洞只能由Snipuzz暴露。

## 2.背景
### 2.1 模糊测试
模糊测试是一种功能强大的自动测试工具，用于检测软件漏洞。经过几十年的发展，模糊测试已被广泛应用于多个安全测试领域，如操作系统内核[12,36]、服务器[33]和区块链[3]。

一般来说，模糊测试为目标程序提供大量的变异输入，并监视异常(例如，崩溃)。如果执行显示了不希望的行为，则可以检测到漏洞。为了更有效地发现漏洞，模糊算法基于执行的反馈(例如，覆盖知识)来优化突变过程，而不是使用纯粹的随机突变策略。此外，fuzzers可以从反馈机制中判断每个由种子突变生成的测试用例是否“有趣”(即，测试用例是否探索了看不见的执行状态)。如果一个测试用例是有趣的，它将被保留为一个新的种子，以参与未来的突变。有了反馈，许多fuzzers[4,5,29,41,49]将计算资源引向感兴趣的测试用例，从而提高了发现漏洞的可能性。

### 2.2物联网设备通用通信架构
为了响应外部输入，大多数物联网设备都实现了类似的高层通信架构。根据图1所示的伪代码示例，通信架构的典型实现可能由四个部分组成:1)Sanitizer，2)功能Switch,，3)功能定义，4)应答器 Replier。

当物联网设备接收到外部输入时，消毒程序开始解析输入并执行常规匹配。如果输入格式违反语法要求，或者在解析过程中出现异常，则Sanitizer将直接通过发送描述输入错误的响应消息来通知Replier，并终止对输入的处理。如果输入语法正确，Function Switch将根据从输入中提取的属性Key和相应的值val将控制转移到相应的函数。如果Key不能匹配，这个输入的处理将被终止，类似于Replier做的。当Functions使用参数val完成处理(例如setFlow())时，它通知Replier生成响应消息。请注意，函数的实现是特定于物联网设备的。如上所述，Replier负责向客户端(如用户的APP)发送响应。Replier根据调用情况(由示例中的参数代码表示)确定要发送的响应消息的内容。

![](images/Pasted%20image%2020230509231957.png)

## 3.动机
### 3.1 基于响应的反馈机制
物联网设备的交互能力使得通过网络测试设备固件的安全性成为可能。然而，在使用基于网络的模糊测试器测试物联网设备时也存在一些挑战。由于大多数网络模糊测试方法不能直接获得设备的执行状态，因此很难建立有效的反馈机制来指导模糊测试过程。如果没有反馈机制，模糊测试在突变目标的选择上是盲目的，可能会倾向于暴力随机测试。

如前所述，由于缺乏开源固件，很难甚至不可能对物联网设备进行检测。因此，固件返回的响应消息可以被视为运行时设备状态信息的宝贵来源。图1中的Replier将使用变量code的值来确定响应消息的内容。code的值来自固件中许多不同的功能块。当杀毒程序无法解析输入或触发一些异常时，传递参数;或者Function Switch不能匹配输入中的关键命令字符;或在函数中执行每个输入之后。因此，通过响应消息的内容，可以推断出在固件中执行的代码块。当固件源代码不可用时，就不能直接提取固件执行和响应消息之间的对应关系。此外，即使执行不同的功能，固件也可能返回相同的响应消息。

虽然不能将响应消息等同于设备的执行路径，但它仍然可以在物联网设备的黑盒模糊测试中发挥重要作用。虽然很难将对应于每个响应消息的代码执行路径链接起来，但如果两个输入得到不同的响应消息，我们可以推断两个输入进入不同的固件代码执行路径。

我们的方法。Snipuzz使用响应消息建立新的反馈机制。Snipuzz将收集每个响应，当发现新响应时，与响应对应的输入将作为后续突变测试的种子排队。

### 3.2消息片段推断
物联网设备的固件可以看作是一个对输入有严格语法要求的软件程序。如果在模糊测试中使用基于字节的突变策略(例如逐个改变输入中的每个字节或随机选择字节进行突变测试)，则生成的测试用例可能很少，无法满足输入语法需求。基于语法的fuzzers利用详细的文档或大型训练数据集来学习语法规则，并使用它来指导突变的产生[34,40]。在许多情况下，物联网设备中的输入语法多种多样或不标准。表1显示了来自不同供应商的20个物联网设备使用的通信格式要求。其中一些使用众所周知的格式，如JSON和SOAP，但有些使用键值对甚至自定义字符串作为通信格式。因此，很难为基于语法的突变策略提供涵盖大规模通信格式的语法规范或建立训练数据集。

最好的语法指导来自固件本身。来自物联网设备的响应建议消息的执行结果。如果我们一个字节一个字节地改变有效消息(即破坏格式)，我们将得到许多不同的响应。如果有效消息中两个不同位置的突变接收到相同的响应，则这两个位置很可能与固件中相同的功能相关。因此，那些具有相同响应的连续字节可以合并为一个片段。这个推断消息片段的方法可以清楚地反映每个字节进入固件后的效用。此外，基于消息片段的变异可以大大减少搜索空间，提高模糊测试的效率。

我们的方法。Snipuzz将具有相同响应的连续字节合并到一个片段中。我们还提出了在片段上执行不同的突变操作符。

## 4.方法
为了清楚地展示我们的方法，在解释Snipuzz的模糊过程时，我们首先引入一些概念。在高层次上，Snipuzz作为客户端执行，发送消息序列$M$ 来请求物联网设备的某些操作。任何消息$m \in M$ 都请求IoT设备执行某种功能，所有消息($\bigcup_{k} m_k = M$ )一起工作以请求一个(或多个)操作。与典型的fuzzers类似，我们用一个初始消息序列初始化种子$S$ ，以及包含所有种子的种子语料库$C$ (第4.1节)。同时，收集恢复消息序列，用于将物联网设备重置到预定义状态。

为了建立一个有效的模糊测试，如图2所示，Snipuzz首先执行一个代码片段确定过程。具体来说，snizz在一个种子$S \in C$ 中选择一条消息$m$ ，从中生成一条探测消息$p_i$ 和相应的序列$M_i$。$M_i$中的每个消息将触发响应消息$r_i$(简称响应)，其中包含有关执行输出的信息。Snipuzz为每条消息$m$分配一个响应池$R$，该响应池用于确定新响应$r_i$ 是否唯一。响应的唯一性表示该响应不属于响应池中存在的任何响应类别。如果$r_i$是唯一的，Snipuzz将把$r_i$添加到池$R$ 中，并保留相应的消息序列$M_i$作为新的种子。然后Snipuzz根据响应将消息$m$分成不同的片段(第4.2节)。在获得片段后，Snipuzz根据各种策略执行突变，例如，空，字节翻转，数据边界或浩劫havoc(详见4.3节)。在整个模糊过程中，Snipuzz设置了一个网络监视器来检测可能表明漏洞的崩溃(第4.4节)。

![](images/Pasted%20image%2020230510092005.png)

### 4.1 消息序列获取
初始种子的质量会显著影响模糊运动。因此，我们考虑获得符合物联网设备所需的高度结构化格式的高质量初始种子，因为这样的输入可能会执行复杂的执行路径，并扩大在深层代码中暴露漏洞的机会。基于配套应用逆向工程[9]或可访问规范(如3.2节所述)生成种子可能是直观的解决方案。然而，它们要么需要大量的工程工作，要么容易出错(例如，种子可能违反所需的格式或具有错误的消息顺序)。

**初始种子获取**。Snipuzz提出了一个轻量级的解决方案来获得初始有效的种子。考虑到许多物联网设备都有第一方或第三方API文档以及测试套件，双方提供的测试程序可以有效地充当客户端，向物联网设备或远程服务器发送控制命令。通信包的大多数结构信息(例如，报头、消息内容)和协议(例如，HTTP、HNAP、MQTT)在API程序中定义为消息有效负载。因此，Snipuzz利用这些测试套件与目标设备通信，同时提取消息序列作为初始种子。例如，当使用API程序打开灯泡时，该程序首先向服务器或物联网设备发送登录信息，然后发送消息以定位特定的灯泡设备，最后发送消息以控制设备打开灯。Snipuzz捕获这样一个触发物联网设备的功能的消息序列作为初始种子。

**恢复消息序列获取**。为了重播崩溃分类的测试用例，Snipuzz确保被测设备在每一轮测试中具有相同的初始状态。在向设备发送任何消息序列后，Snipuzz将发送恢复消息序列以将设备重置到预定义的状态。

**手动工作**。尽管我们尽了最大的努力来提供一个轻量级的模糊器，但是Snipuzz仍然需要一些手工工作来获得有效和可用的初始种子。首先，我们手动配置测试套件中的程序，例如设置IP地址和登录信息。请注意，我们只需要为每个设备配置一次这些程序。其次，为了动态捕获消息序列，我们需要在网络流量监视器中手动定义特定的格式和协议。最后，我们过滤掉一些会误导模糊过程的消息序列。例如，一些API程序提供可以自动更新或重新启动设备的操作。这些操作将使设备停止，因此不会发送回任何响应。这将导致假阳性崩溃，因为我们将无响应执行视为崩溃。每个设备的手工工作大约需要5个工时，并且只在Snipuzz的消息序列获取阶段需要。

### 4.2 片段确定
Snipuzz的关键思想是基于响应确定的片段来优化模糊测试过程。换句话说，Snipuzz利用片段突变来减少输入的搜索空间，而片段通过对来自物联网设备的响应进行分类而自动聚类。主要的挑战是正确理解响应的语义。例如，由于时间戳的存在，如果使用简单的字符串比较，两个语义相同的响应将被划分为不同的类别。因此，Snipuzz利用启发式算法和分层聚类方法来确定每个消息中的片段。****

#### 4.2.1初步判定
消息片段的本质是消息中的连续字节，它使固件能够执行特定的代码段。对于经验丰富的专家来说，根据官方文档中的语义定义对消息片段进行分段并不困难。然而，对于缺乏这种知识的算法，必须应用一些自动方法来识别消息中每个字节的含义。

Snipuzz首先使用启发式算法将每个消息粗略地划分为初始片段。启发式算法的核心思想是通过删除消息$m$ ($m \in seed \space S$ )中的某个字节来生成探测消息$p_i$。通过对每个探测消息的响应$r_i$进行分类，snizz初步确定了消息$m$中的片段。

例如，如表2所示，为了确定消息$m= \{"on":true\}$中的片段，Snipuzz通过逐个删除$m$中的字节来生成探测消息。当删除$m$中的第一个字节“{”时，对应的探测消息$p_1$ 为“on”:true}。类似地，当第二个字节被删除时，对应的探测消息$p_2$为{on":true}。因此，11字节的消息$m$可以生成11条不同的探测消息($p_1$ 到$p_{11}$ )。Snipuzz将包含探测消息的11个对应的消息序列($M_1$~$M_{11}$ )发送到设备并收集响应。

![](images/Pasted%20image%2020230510094640.png)

然后，Snipuzz通过对响应进行分类来区分消息$m$中的片段。具体来说，将具有相同对应响应类型的连续字节合并为相同的代码片段。根据表2中的示例，响应$r_1$、$r_2$ 和$r_5$ 合并到一个类别中，表示JSON语法错误，而响应$r_3$和$r_4$ 合并到另一个类别中，表示无效输入参数的错误。因此，响应属于同一类别的连续字节可以组成一个消息片段。通过这种启发式方法，Snipuzz可以确定消息$m$中的所有初始片段。

对响应进行分类的一种简单方法是利用字符串比较，即逐个字节比较响应的内容。然而，由于响应存在随机性(如时间戳和token)，简单的字符串比较可能会错误地将具有相同语义的响应区分为不同的类别。因此，引入了一个更高级的解决方案Edit Distance[42]来确定响应的类别。如式(1)所示，计算两个响应$r_k$和$r_t$之间的相似度得分$s_{kt}$。

![](images/Pasted%20image%2020230510100139.png)

其中，等式中的max_len()选择两个响应之间较长的字符串，而edit_distance()计算将一个字符串转换为另一个字符串所需的最小操作数，包括插入、删除和替换。因此，两个响应越相似，$s_{kt}$的值越大。

Snipuzz首先为每个探测消息$p_i$ 计算一个自相似性得分$s_{ii}$ 。注意，$p_i$是通过改变消息$m$中的第i个字节生成的。具体地说，Snipuzz在一秒的间隔内发送两次相同的探测消息$p_i$。对应地，将从IoT设备收集两个响应$r_i$，$r_i'$ 。然后根据式(1)计算两个响应$r_i$，$r_i'$ 的自相似度得分$s_{ii}$。注意，由于响应的随机性，两个响应$r_i$，$r_i'$ 之间可能存在差异，即使它们来自同一探测消息。因此，自相似得分可以小于1。

为了确定两个回答是否属于同一类别，Snipuzz计算两个响应的相似度得分，并将其与自相似度得分进行比较。例如，对于两个响应$r_i$和$r_j$ ，Snipuzz使用公式(1)来计算相似度得分$s_{ij}$。之后，$s_{ij}$将与自相似度进行比较。如果$s_{ij} \ge s{ii}$或$s_{ij} \ge s{jj}$满足要求，则认为回复$r_i$和$r_j$ 属于同一类别;否则，响应$r_i$和$r_j$ 将被分配到不同的类别。

对于新收到的响应$r_i$，Snipuzz将根据相似性得分将其与相应响应池$R$中的所有响应进行比较。如果新的响应$r_i$不属于任何现有的类别，则响应$r_i$以及相应的探测消息$p_i$将被添加到响应池中。

使用响应池$R$，Snipuzz对消息 $m$中的每个字节进行分类。具体来说，消息$m$中第i字节的类别是根据响应$r_i$的类别分配的。然后，具有相同类别的连续字节将合并为一个片段。图3显示了根据表2中的响应类别对消息m= {"on":true}进行初始代码片段确定的示例。

![](images/Pasted%20image%2020230510101256.png)

#### 4.2.2 分层聚类
尽管Snipuzz利用相似性比较来减轻响应随机性造成的错误分类，但是两个语义相同的响应仍然可能被错误地分类到不同的类别中。当响应包含从探测消息提取或复制的内容时，可能会发生这种情况。例如，由于从探测消息中引用了特定的错误内容，启发式算法不会将它们分配到一个类别。具体来说，表2中m= {"on":true}的相似度得分$s_{34}$为0.979，小于自相似度得分$s_{33}$ = 1.000和$s_{44}$ = 1.000(因为回答中没有随机性)。然而，这两个响应在语义上是相同的，应该被识别为一个类别，即它们都是错误消息，表明参数语法错误位于探测消息中，并且设备正在执行相同的代码块。

为了解决上述问题，Snipuzz使用聚合分层集群来优化消息片段。分层聚类的核心思想是不断地合并两个最相似的聚类，直到只剩下一个聚类。

如算法1所示，Snipuzz将根据第4.2.1节(第1行)确定的Initial snippets初始化片段。之后，响应池中的每个响应类别将被初始化为一个簇(第2行)。Snipuzz将将响应转换为特征向量(第3行，后面的段落将详细介绍)，用于计算每对簇之间的距离(第5-7行)。然后，两个最近的集群将被合并，集群中心将相应地更新(第8-10行)。在执行聚类过程之后，Snipuzz将根据当前聚类结果生成新的片段，并将新的片段添加到片段分割结果中(第11行)，这将进一步用于突变。

![](images/Pasted%20image%2020230510102048.png)

具体来说，Snipuzz首先从响应中提取特征，这些特征将响应向量化为自相似评分、响应长度、字母段数量、数字段数量和符号段数量的元组。每个段由具有相同类型的连续字节组成。例如，“123”是1个数字段，“a1b”有2个字母段和1个数字段。更具体地说，表2中的$r_1$ 将被矢量化为푣$v_1$  =(1,91,10,2,10)。类似地，响应$r_3$和 $r_4$将转换为v2 =(1,94,11,2,13)和v3 =(1,94,11,2,13)。

图4显示了根据表2中的消息m= {"on":true}进行聚类的示例。根据算法1，在聚类的准备轮(第0轮)中，响应池中的每个类别初始化为单个聚类。在第一轮中，簇2和3是距离最小的两个簇($|| v_2 − v_3 || = 0$)，将两个聚类合并为一个新的聚类。相应地，消息片段' o '和' n '被合并为一个新的片段，标记为索引#4。类似地，在下一轮中，两个最接近的集群(集群1和新集群)将被合并，并且还将生成一个新的代码片段。最后，消息中的所有片段合并为一个新的片段，即消息本身。所有新生成的代码片段和初始代码片段将在下一阶段的消息突变中使用。

![](images/Pasted%20image%2020230510103421.png)

### 4.3 变异方案
**片段的突变**。为了进行有效的模糊测试，Snipuzz会对片段确定阶段获得的片段进行变异。注意，突变模式是对整个代码片段执行的，而不是对消息中的单个字节执行的。
- 清空。如果数据域未被正确检查，可能会导致固件崩溃。因此，Snipuzz删除整个代码片段以清空数据域。
- 字节翻转。为了检测语法解析器和功能代码中的错误，Snipuzz翻转了代码片段中的所有字节。这将改变字符串的语法含义，并在解析器没有正确检查语法时发现错误。另一方面，Byte Flip改变数据域的值来检查固件。
- 数据边界。为了检测在赋值过程中发生的越界错误，Snipuzz将数值数据的值修改为一些边界值(例如65536)。
- 字典。对于Dictionary的方案，Snipuzz用“true”和“false”等预定义字符串替换代码片段，这样可以直接探索更多的代码覆盖率。
- 重复。为了检测语法解析器中的错误，Snipuzz会多次重复一个代码片段。同时，数据域的重复可以检测出由越界问题引起的缺陷。

**浩劫(Havoc)**。触发bug的条件可能很复杂。例如，可能需要修改同一消息中的不同数据域来触发错误。前面提到的代码段突变方案一次只突变一个代码段。然而，浩劫突变在消息中随机选择一些随机片段，并对每个选中的片段执行上述突变方案。浩劫突变不会停止，直到找到一个新的响应类别或目标物联网设备崩溃。

### 4.4 网络流量监视器
监控设备的网络通信，并设置超时时间以确定设备是否已崩溃。实际上，对设备网络通信的监控并不是一个单一的步骤，它发生在整个模糊测试过程中。在超时的情况下，Snipuzz将继续发送相同的消息序列三次，因为超时的原因可能是网络波动，而不是设备崩溃。如果超时发生三次，Snipuzz将使用控制命令物理重启设备，并再次向设备发送相同的消息序列。如果设备仍然没有按时返回消息，Snipuzz将记录崩溃和相应的消息序列。

### 4.5 实现
Snipuzz的设计包括四个步骤：消息序列获取、片段确定、突变和网络通信监控。在消息序列采集步骤中，我们在程序中使用WireShark[45]检测并记录API与物联网设备之间的通信报文，并手动清洗这些消息序列。剩下的核心功能步骤打包在一个原型中，用4000行c#代码实现。网络监视器将记录发送给设备的每条消息，当设备没有回复时，将信息重新发送给设备。日志含义使用智能插头实现目标设备的物理重启功能。当Snipuzz需要物理重新启动被测设备时，它将向智能插头发送控制消息，然后将插头关闭，然后打开。这样，被测设备将被短暂断电并重新启动。

## 5.实验评估
### 5.1 环境设置
**环境设置**。为了初始化IoT设备，我们使用制造商提供的应用程序来完成配对。为了更好地监控网络通信，所有被测设备都连接到本地路由器。我们的自动数据包提取器和Snipuzz运行在Windows 10桌面PC上，配备英特尔酷睿i7六核3.70 GHz CPU和16 GB RAM。PC机与路由器也已连接。

**测试的物联网设备**。我们从全球线上和线下市场精选了20款流行的消费类物联网设备，涵盖飞利浦、小米、TP-Link、Netgear等知名品牌。所选物联网设备类型包括智能插头、智能灯泡、路由器、家庭网桥、IP摄像头、指纹终端等。这些设备要么是亚马逊上的推荐商品，要么是超市里可以买到的最畅销产品。表1详细列出了被测物联网设备的信息。

**基准测试工具**。为了验证snipuzz在查找崩溃和消息分割方面的性能，我们使用了七种不同的模糊测试方案作为基准。

**IoTFuzzer**[9]。IotFuzzer的核心思想是通过对同伴应用的静态分析，找到向物联网设备发送控制命令的功能，在不破坏消息格式的情况下，改变特定变量的值，进行模糊测试。请注意，我们对IoTFuzzer的实现是最好的复制，因为他们的代码是不可公开的，我们承认这可能会提供与原始版本略有不同的结果。

我们将Snipuzz框架中的突变算法替换为IoTFuzzer中的突变策略来实现IoTFuzzer。考虑到IoTFuzzer中同伴应用分析的目的是确保只有通信消息中的数据域发生突变，为了使基准测试尽可能公平，我们使用与Snipuzz中使用的相同的种子，并在将每个种子消息馈送到IoTFuzzer之前手动分割数据域。我们认为这样的人工分割足以提供IoTFuzzer的上界性能。注意，我们删除了与反馈机制和片段分割相关的方法，因为这些方法在IoTFuzzer中没有使用。

**Nemesys**[22]。Nemesys是一个协议逆向工程工具，用于网络消息分析。它利用单个消息中值变化的分布来推断每个数据域的边界。考虑到Nemesys是一种协议推理方法，而不是现成的模糊测试工具，我们基于Snipuzz框架实现Nemesys的方法来推断代码段边界，取代相应的代码段确定方法(章节4.2)。

**BooFuzz**[31]。BooFuzz是Sulley[19]的继承者，是一款优秀的网络协议模糊器，最近参与了几项模糊研究[9,37,48]。与其他自动模糊器不同，BooFuzz需要人工引导的信息分割策略作为输入。在我们的研究中，我们利用这一特性并手动定义更多的模糊策略来丰富基准评估。
- BooFuzz-Default。在这个策略中，我们将输入中的每个消息设置为一个完整的字符串，也就是说，BooFuzz将把该消息作为一个字符串用于突变测试。
- BooFuzz-Byte。输入中消息的每个字节将分别用于突变测试。
- BooFuzz-Reversal。与IoTFuzzer的想法相反，在该策略中，我们关注消息中非数据域的突变，同时保持数据域不变。

**Doona**[44]。Doona是Bruterforce Exploit Detector (BED)的一个分支[6]，用于检测网络协议中与缓冲区和格式相关的潜在漏洞。与其他工具不同，Doona不将网络通信数据包作为种子。Doona的测试用例需要为被测试的每个设备或协议预先定义。

**Snipuzz-NoSnippet**。Snipuzz使用消息片段的分割来提高模糊测试的效率和查找崩溃的能力。为了验证片段确定是否确实有利于模糊测试，我们实现了基于Snipuzz的snipuzzle - nosnippet。snipuzz-nosnippet没有片段确定组件，并且在不知道响应的情况下盲目地改变消息中的字节。

除了Doona，它的测试用例是预先设置的，所有基准测试工具和Snipuzz都在相同的输入集上进行测试。这些输入集可能是不同的格式(例如，BooFuzz需要手动设置输入，而Numesys要求输入是pcap文件格式)，但内容是相同的。

还有许多其他流行的模糊测试工具能够通过网络通信测试物联网设备，如Peach[30]和AFLNET[33]。然而，由于它们是灰盒模糊测试，需要固件插桩，因此将这些工具视为黑盒方案的基线是不可行和不公平的。

### 5.2 漏洞检测
#### 5.2.1 SNIPUZZ
在使用Snipuzz对20个物联网设备中的每一个进行了24小时的模糊测试后，我们在5个设备中检测到13次崩溃。如表3所示，检测到的崩溃包括7个空指针解引用、1个拒绝服务和5个未知的崩溃，我们进一步手工验证了这些崩溃。Snipuzz发现的13个崩溃是通过提供格式错误的输入触发的。这些格式错误的输入以不同的方式破坏消息格式。例如，删除占位符、清空数据域或更改数据值的类型。

请注意，Snipuzz识别的所有崩溃都是基于JSON的设备，尽管我们成功地在20个具有各种通信格式(如JSON, SOAP和K-V对)的物联网设备上进行了实验。实验还表明，与其他fuzzers相比，snizzzz观察到更多的响应类别(详见5.3节)。

**空指针解引用**。如表3所示，在TP-Link HS110和HS100中，由snizz触发的7次崩溃都是由空指针解引用引起的。将测试用例发送到HS110和HS100后，设备崩溃，无法回复任何交互。等待几分钟后，设备会自动重启，恢复到初始状态。通过对测试用例的分析，我们发现这些漏洞都是由JSON语法中发生变异的消息触发的。换句话说，当一些重要的占位符(如花括号和冒号)或测试消息的一部分发生变化时，消息的语法结构和语义就会被破坏。如果设备不能正确处理突变的输入消息，它将使设备崩溃。我们于2020年6月13日通过电子邮件向设备供应商TP-Link报告了这些漏洞。他们已经确认了这个漏洞，并承诺通过固件更新来修复它。

**拒绝服务**。另一个有趣的发现是在飞利浦A60智能灯泡中检测到的拒绝服务漏洞。在Snipuzz测试了24小时后，飞利浦的官方配套应用程序无法正常管理该设备。具体来说，在应用中找不到设备，如果通过应用发送任何进一步的消息，应用中的响应将继续要求将设备绑定到设备组，并且没有进一步的交互可用。但是，我们观察到，如果将消息包直接发送到设备，则设备可以正常工作。这表明设备没有完全崩溃，但其通过配套应用程序的服务被拒绝。

**未知的崩溃**。Snipuzz在灯泡YLDP05YL和YLDP13YL上发现了5个崩溃。这些设备在大约一分钟内自行崩溃并重新启动。通过分析测试用例，我们发现崩溃是由于删除了某些数据域，例如表4中标记为红色的参数无效。由于这两款设备的固件尚未公开，因此无法确定漏洞的根本原因;但是，我们仍然可以推断出这个漏洞是由于设备在解析过程中读取空值，导致在分配过程中崩溃。我们还发现，使用本地网络进行通信不需要任何身份验证，这意味着设备可以被本地网络中的任何攻击者崩溃。因此，我们认为这些漏洞是“可远程利用的”。

#### 5.2.2使用最先进的工具进行基准测试
如表3所示，在每个设备上进行24小时的模糊测试，除了IoTFuzzer之外，没有任何基准测试工具发现崩溃。由于种种原因，他们没有找到崩溃。Donna更多地关注通信协议的突变。此外，Donna不能应用于所有设备，这也限制了它的容量。由于Boofuzz直接用预设字符串替换消息中的指定位置，因此它只能触发有限类型的漏洞。Nemesys提供了一种确定消息片段的新思路。然而，由于它通过消息中值的分布来确定消息片段，因此Nemesys很难准确地确定数据域和非数据域之间的边界。因此，Nemesys很难检测到只能通过突变数据或非数据域触发的漏洞。snipuzzle - nosnippet不采用Snipuzz中使用的基于片段的突变方法，它类似于经典的fuzzer AFL[24]。由于snipuzzle - nosnippet不推断消息的结构，而是直接使用单个或多个连续字节作为突变单位，因此snipuzzle - nosnippet生成的大多数测试用例都会破坏消息的结构。这种方法很难在需要高度结构化输入的设备上工作。

![](images/Pasted%20image%2020230510111004.png)

IoTFuzzer检测到2个智能灯泡设备YLDP05Y和YLDP013Y发生2次崩溃。由于IoTFuzzer的突变策略，通过清空数据域获得IoTFuzzer提供的畸形输入。根据表4中列出的突变消息，我们可以看到，IoTFuzzer突变的消息与Snipuzz生成的消息相似。表4中来自Snipuzz和IoTFuzzer的消息的突变域都在数据域中。就突变测试的效果而言，Snipuzz和IoTFuzzer在这两条消息上实现了相同的目标。但是，Snipuzz可以覆盖IoTFuzzer的突变空间，因为IoTFuzzer只关注数据域的突变，而Snipuzz可以突变数据域和非数据域。

![](images/Pasted%20image%2020230510111020.png)

为了进一步确定崩溃的根本原因，我们获得了TP-Link生产的两款典型市场消费级智能插头HS100和HS110的固件源代码，并进行了案例研究，以反映Snipuzz和IoTFuzzer的差异。我们发现Snipuzz在两个设备上触发的崩溃之一是由于破坏语法结构并在数据和非数据域上发生突变造成的。更具体地说，变异的消息成功地绕过了杀毒程序，并在函数执行期间触发了崩溃。我们推断这可能是由容易出错的第三方消毒引起的(详见附录B)。另一方面，由于IoTFuzzer的设计，模糊测试是基于语法规则的，因为IoTFuzzer倾向于优先满足语法要求，以便不被消毒程序拒绝，并确保每个测试用例都能到达固件中的功能执行部分。与Snipuzz相比，这种策略限制了模糊测试的范围及其覆盖消毒部分的能力。因此，我们认为，考虑到物联网固件测试的复杂性，一个轻量级和有效的黑盒漏洞检测工具，如Snipuzz，是一个迫切需要。

### 5.3 运行时性能
图5显示了Snipuzz和其他七个fuzzers如何在前10分钟内探索设备固件。由于篇幅的限制，我们在这里只给出了5个设备的结果，而在附录a中绘制了全部20个设备的结果。我们重复了10次模糊测试，记录了每种方法发现的响应类别数量的中值，表明已经探索了覆盖范围。我们手动审查呈现的响应类别，以消除响应随机性或设备响应机制导致的错误分类。

![](images/Pasted%20image%2020230510111233.png)

如图5所示，Doona只能检测少量的响应类别。Doona是基于协议的模糊测试方法，它的测试更偏向于协议内容。对通信协议的突变测试，很有可能被设备直接拒绝或单方面忽略，导致能够接收到的响应类别很少。

我们基于Boofuzz实现了三种模糊策略，即将整个消息作为字符串进行变异，将消息的每个字节进行变异，以及对非数据域进行变异。然而，测试结果表明，他们都在每个设备上探索了非常有限的响应类别。类别发现的局限性是由于Boofuzz的突变策略，它将目标内容替换为特定的预定义字符串。例如,使用字符串,例如  “/./././././././.，以不同的策略替换消息的内容(例如，替换整个字符串，单个字节或非数据域)，会导致消息格式的违反，并且很容易被杀毒程序拒绝。因此，Boofuzz获得的大多数响应都属于“错误响应”的范畴。

IotFuzzer探索的响应类别数量在短时间内迅速增长，然后停滞不前。在突变阶段，IotFuzzer从原始候选输入中随机选择一组输入，并随机改变一个或多个消息的数据域。它将继续重复此方法，直到设备崩溃或达到时间限制。这种基于随机性的方法有助于IotFuzzer在原始输入中对大量消息数据域进行突变和测试，并在开始时快速收集响应消息类别。然而，由于数据域的突变，IotFuzzer发现的响应类别数量很快就会达到极限。

在大多数设备中，Snipuzz在大多数情况下保持稳定的上升趋势，经过一段时间后，Snipuzz发现的响应类别数量超过了IotFuzzer。与IotFuzzer不同，Snipuzz主要通过Snippet Determination阶段搜索响应类别。根据消息片段探索策略，Snipuzz首先尽可能多地探索某个消息的所有响应类别。在获得消息片段并通过Snippet Mutation进行测试之后，将以相同的方式处理下一条消息，直到测试完初始消息序列中的所有消息为止。按照这种方法，Snipuzz可能无法在短时间内获得大量的响应类别。当Snipuzz检测到消息片段时，消息内容中的每个字节都将包含在测试中。因此，如表3中粗体数字所示，与其他最先进的物联网模糊测试工具相比，对于20个设备中的15个，Snipuzz在24小时模糊测试后覆盖了最多的响应类别。

在5个设备上，snipuzz-nosnippet在24小时内收集的响应类别比Snipuzz多。snipuzzle - nosnippet使用的突变方法类似于经典的fuzzer AFL[24]。它直接对单个字节或几个连续的字节执行变异。但是，snipuzz-nosnippet很难覆盖没有通过打破语法格式获得的响应类别(例如，数据域中的越界数据)。从理论上讲，尽管snipuzz-nosnippet突变方法效率不高，但它仍然具有探索大多数类别响应的能力。

Nemesys比BooFuzz和Doona探索了更多的响应类别，但没有超过Snipuzz。Nemesys策略依次对消息的每个数据域执行确定性突变，这使得其运行时性能趋势与Snipuzz相似。然而，Nemesys的数据域确定策略并不是基于物联网设备的响应。因此，消息中字节值的分布无法覆盖更多的响应类别。因此，Nemesys收集的回复类别数量有限。

有趣的是，在R6400的情况下，Snipuzz在只找到几个响应类别后也进入停滞状态。我们仔细检查初始输入消息序列，发现消息的平均长度超过400字节，这迫使Snipuzz生成并发送大量探测消息以确定消息片段。因此，在前10分钟，Snipuzz还在探索前几条消息的响应类别，所以没有超过IotFuzzer。

### 5.4 消息片段推理的评估
在所有策略中，Snipuzz和Nemesys利用语义分割来评估其消息片段推理的性能。我们将它们在模糊处理过程中生成的代码片段与API文档中定义的语法规则进行比较。具体来说，对于一些成熟和流行的语言，如JSON，我们根据它们的标准语法建立语法规则;对于自定义格式，如字符串或自定义字节，我们参考官方API文档并根据说明定义语法规则。

公式(2)量化了片段推断的质量，相似性表示片段确定的消息m中正确分类字节的百分比与手动从语法规则中提取的基本事实g相比。

![](images/Pasted%20image%2020230510111725.png)

其中cate()返回一系列“0”和“1”位中每个消息字节的类别，count()计算错误分类的字节数，len()表示消息的长度。注意，在基础真值消息中，“0”表示非数据域(在表5中标记为蓝色)，而“1”表示数据域(在表5中标记为红色)。因此，⊕是按位XOR运算。

此外，根据公式(2)，我们计算了Snipuzz和Nemesys对实验中获得的所有235条消息确定的片段(或数据域)的平均相似度。注意，在计算平均相似度时，对于每条消息，如果确定了多个片段集，我们将选择相似度值最高的片段推断;因此，一个片段可以尽可能多地反映语法规则，最大限度地提高消息语义分割的性能。

Snipuzz的平均相似度为87.1%，表明Snipuzz通过基于层次聚类方法的片段推理，可以有效地找到隐藏在消息中的语法规则。理想情况下，在snizz中，集群的合并消除了响应中的随机性和应答消息机制本身造成的影响。因此，消息片段会逐渐符合语法规则，从而使Snipuzz获得更高的相似度结果。

然而，在一些结果中，我们也发现了片段推理方法与语法规则之间的差异。例如，对于表5所示的示例，代码片段推断方法将语法规则中属于数据域的字符串(即' true '、' 140 '和' 254 ')与一些占位符(如双引号和花括号)组合在一起。通过对响应消息的分析，我们发现销毁这些数据域和销毁占位符后得到的响应都是无效格式。这可能是由于在固件中，当解析格式中出现错误时，响应不会报告错误的详细描述，而是返回一般格式错误。

另一方面，Nemesys利用协议中值变化的分布来确定不同数据域的边界，实现对消息的语义分割。这种方法的优点是，除了消息本身之外，它不需要任何其他附加信息，例如语法规则或大量的训练数据集。

Nemesys的平均相似度为64.5%，低于Snipuzz的结果。在表5所示的示例中，当以需要限制语法(如Json和XML)的格式分割消息时，Nemesys可以实现良好的语义分割性能，因为占位符通常使用数据域中不常用的符号。字节值的这种分布使Nemesys能够有效地找到数据域之间的边界。然而，在物联网设备中，自定义格式很普遍。例如，智能灯泡BR30使用自定义字节作为通信手段，其中每个字节对应一个特殊含义(即，“0x61”代表“CHANGE_MODE”，“0x0f”代表“TRUE”)。在这种情况下，字符的值分布不能再作为确定数据域的指导，因此Nemesys确定的消息分割容易出错。

## 6. 讨论和局限性
Snipuzz已经成功检测了20种不同的设备，并在其中5种设备上暴露了安全漏洞。然而，Snipuzz在效率和可扩展性方面仍然存在一些限制。我们将在本节中讨论局限性，并提出解决方案作为未来的工作。

**可伸缩性和手工工作**。如果知道有效的网络数据包，则可以通过Snipuzz测试物联网设备。在我们的原型中，我们通过运行API程序和监控网络通信来捕获通信数据包(注意，数据包也可以通过静态分析API程序而不运行它们来获得)。在没有API程序或文档的情况下，我们可以通过反编译和污点分析，从物联网设备的官方app中恢复消息格式。或者作为第二种方法，我们可以通过拦截应用程序和物联网设备之间的通信来解决这个问题，然后从捕获的数据包中恢复消息格式。第二种方式是可行的，我们已经在TP-Link的物联网控制APP KASA中进行了实验，可以进一步开发用于更多的物联网设备。然而，这两种方法都可能引入开销并涉及手工工作。

回想一下在4.1节中，Snipuzz需要手动工作，在消息序列获取阶段，每个设备需要5个工时来收集初始种子。手工工作主要是指清除从公开可用的第一方和第三方资源获得的API程序中的数据包。在将snizz应用于物联网设备时，为了减轻这一限制，在未来工作中可以使用爬虫等技术来自动收集API与物联网设备相关的程序。此外，还可以通过脚本对关键字进行预处理，改善数据包清洗过程，实现通信包的自动采集。

**威胁有效性**。当Snipuzz通过API程序和网络嗅探器收集初始消息序列时，第一个威胁来自API程序的缺失。在这种情况下，我们可以根据物联网设备的配套应用程序(类似于物联网Fuzzer)恢复消息格式，但可能需要更多的人工努力。其次，消息中的加密降低了片段确定的有效性，因为语义信息可能被破坏。加密问题的一个潜在解决方案是将解密模块集成到Snipuzz中。最后，固件的代码覆盖率可能取决于API程序的可访问性，因为Snipuzz只能检查API程序中涵盖的功能。重新组合来自不同种子的消息片段以生成新的有效输入可以减轻这种限制。

**加密**。在消息获取过程中，我们注意到在一些API程序中使用加密来保护通信。加密对消息序列突变过程没有影响，但片段确定过程基本失败。由于加密算法破坏了消息的原始格式，片段的分割对字符的位置很敏感。此外，由于来自设备的响应消息也是加密的，因此Snipuzz无法从中获得有用的反馈。同样，可以将API程序中的加密和解密算法集成到Snipuzz模块中来解决这一限制，或者从突变策略设计的角度来解决加密带来的困难。

**覆盖率**。Snipuzz探索的固件的代码覆盖率取决于API程序。例如，如果灯泡的API程序只支持打开电源的功能，则几乎不可能通过改变电源打开期间捕获的消息来探索调节亮度的功能。在未来的工作中，在没有语法支持的情况下，我们将考虑重新组合消息片段，以尝试生成新的有效输入。除了提供的原始输入之外，此方法还可以帮助探索更多的固件执行覆盖率。

**对详细响应的要求**。Snipuzz的检测有效性取决于消息片段的质量，而消息片段的质量取决于可以从物联网设备的响应中获得多少信息。换句话说，如果物联网设备没有提供足够详细的响应，例如用统一的消息报告所有错误，那么Snipuzz可能很难确定消息片段。幸运的是，在许多物联网设备中，可以在调试模式下获得高级错误描述，这将大大改善Snipuzz中消息片段的确定过程。

## 7. 相关工作
我们的Snipuzz以黑盒方式执行检测物联网设备中的漏洞。与现有的物联网设备的黑箱模糊测试盲目地改变消息不同，Snipuzz通过利用响应来优化黑箱模糊测试的突变过程。这个反馈机制提高了bug发现的有效性。例如，IoTFuzzer[9]获取数据域，IoTFuzzer对数据域进行盲突变。因此，IoTFuzzer对生成的输入的质量缺乏了解，导致资源浪费在低质量的输入上。还有几种动态分析方法侧重于物联网设备的网络模块。例如，SPFuzz定义了一种描述协议规范、协议状态转换及其相关性的新语言[37]。SPFuzz可以保证会话状态下消息格式的正确性和协议的依赖性。IoTHunter是一种灰盒方法来模糊物联网固件的状态协议[47]。IoTHunter可以不断切换协议状态，对物联网设备进行基于反馈的探索。在最近的一个例子中，AFLnet作为客户端，不断地重放发送到目标(即服务器或设备)的原始消息序列的变化[33]。AFLnet使用响应码(表示执行状态的数字)来识别目标的执行状态，并探索其网络模块的更多区域。

物联网设备动态分析的另一个研究方向是模拟器的使用。仿真的缺点是需要大量的工程工作和固件的要求，尽管物联网固件的仿真可以比黑盒模糊测试更彻底地分析。物联网固件仿真的两个主要挑战是可扩展性和吞吐量。因此，提高仿真性能的努力包括全系统仿真[8,27]，提高仿真成功率[21]，独立于硬件的仿真[17,38]，以及用户模式和系统模式仿真的结合[51]。基于仿真，模糊测试可以集成到这些框架中，并可以寻找固件中的缺陷[38,51]。

固件的静态分析是动态分析的补充方法。语义相似是使静态分析成功的主要技术之一。研究者通过比较文件和模块[13]、控制流图(Control Flow Graphs, CFGs)[14]、解析器和复杂处理逻辑[11]以及多二进制交互[35]来分析语义相似性。还有许多基于相似性的方法可以检测不同固件体系结构之间的漏洞。他们通常从CFG中的每个节点的固件中提取各种与体系结构无关的特征来表示一个函数，然后检查两个函数的CFG表示是否相似[15,32]。

## 8. 结论
在本文中，我们提出了一个黑盒模糊框架Snipuzz，用于检测隐藏在物联网设备中的漏洞。与其他黑箱网络模糊测试不同，Snipuzz利用设备返回的响应消息建立反馈机制，指导模糊突变过程。此外，Snipuzz根据设备的响应推断消息中每个字节的语法角色，这样Snipuzz就可以在没有语法规则指导的情况下生成符合设备语法的测试用例。我们使用了市场上的20个消费级物联网设备来测试Snipuzz，它成功地在5个不同的设备上发现了5个零日漏洞。