# UCRF: Static analyzing firmware to generate under-constrained seedfor fuzzing SOHO router


![](images/Pasted%20image%2020231114110818.png)

2023 Computers & Security

## 摘要
SOHO(小型办公室和家庭办公室)路由器是物联网的关键要素，为各种智能设备提供网络服务。近年来，针对SOHO路由器网络应用程序的攻击越来越多。web服务器在直接接收和处理外部数据的过程中引入了大量的漏洞。模糊测试是发现此类漏洞最常用的技术。以前提出的方法通过分析前端以有效格式生成模糊种子。不幸的是，生成的种子受到前端代码合法性检查的过度约束，因为恶意数据可以绕过前端检查而直接发送到后端。而且，这种种子忽略了后端的语义，使得后端的检查逻辑阻碍了模糊测试的效率。

在本文中，我们提出了一种通过静态分析后端二进制文件生成高质量测试用例来模糊SOHO路由器的新方法。具体而言，我们首先获得后端所有通信接口，以避免丢失不可见的前端接口。然后，对每个接口进行数据流分析，提取所有数据字段的约束信息。最终，有效和深入的测试用例只能在基于约束信息的有意义的测试空间中生成。我们在一个名为UCRF的工具中实现了我们的方法。为了说明UCRF的有效性，我们对来自4家供应商的10个真实固件进行了评估。UCRF在我们的5个路由器上发现了比最先进的SRFuzzer更多的内存损坏和命令注入漏洞。此外，UCRF共发现41个0天后端漏洞，其中20个只有在满足提取的约束条件时才能触发。

## 1.引言
物联网(IoT)设备越来越多地应用于人们的日常生活中(Alrawi et al, 2019)。根据全球移动通信系统协会(GSMA)的报告(the Mobile Economy, 2022)，到2021年，全球物联网设备总数已达到151亿，预计到2025年将增长到233亿。SOHO (Small office and home office)路由器被广泛用于为智能家居、笔记本电脑、智能手机等各种设备提供网络服务，因此SOHO路由器的安全性至关重要。不幸的是，由于嵌入式系统资源有限，SOHO路由器中缺少常见的安全机制(Smart Yet flaws, 2020;Thompson and Zatko, 2018;Yu et al, 2022)，并且许多漏洞可以被攻击者远程利用(Cisco Small, 2022;Dir, 2022)。例如，2016年，Mirai僵尸网络入侵了数百万台物联网设备，并对互联网基础设施公司Dyn发起了分布式拒绝服务(DDoS)攻击，导致欧洲和北美的大规模互联网服务中断(Kolias等人，2017;Mirai, 2016;结束,2018;旅行路由器，2017)。

路由器易受攻击的一个重要原因是它们内部易受攻击的web服务(Cisco Small, 2022;Costin et al, 2016)。SOHO路由器提供自定义web服务器供终端用户配置。web服务器通常包含前端(HTML和JavaScript等)和后端(如web服务器和公共网关接口)。用户数据在前端输入，并通过超文本传输协议(Hypertext Transfer Protocol, HTTP)发送到后端进行进一步处理。恶意用户网络数据很容易绕过前端检测(例如，中间人攻击)，被发送到后端进行处理。最终，该漏洞被利用来泄露信息或使设备崩溃。

近年来，人们提出了许多针对SOHO路由器的漏洞发现方法，包括静态分析(Chen et al .， 2021;Cheng等，2021;2018;Redini等人，2020)和动态测试(例如，模糊测试)(Srivastava等人，2019;Wang et al .， 2013;Zhang等，2021;2019;郑等，2019a;2019 b)。静态分析具有天然的局限性，存在许多误报(Shoshitaishvili等人，2016;Vadayath et al, 2022)。为了验证漏洞警报和编写概念验证(PoC)脚本，引入了大量的手工工作。模糊测试是一种流行的漏洞发现技术。固件仿真提供固件的运行时信息，包括代码覆盖率，这些信息可用于指导模糊测试。然而，由于外设依赖性，仿真自定义固件需要大量的手工工作(Chen等人，2016;Kim et al, 2020;Zaddach et al .， 2014)。为了避免固件仿真中的问题，一些研究工作选择直接对物理路由器进行测试。然而，如果没有有效信息的指导，生成有效的测试用例并执行深入的测试是具有挑战性的，这最终会导致大量的假阴性。

现有的物理SOHO路由器模糊测试方法基于前端生成测试用例(Srivastava et al .， 2019;Zhang et al .， 2019)。例如，这些方法模拟前端的行为，并生成请求作为模糊测试的种子。但是，前端严格验证输入数据的有效性，这使得生成的种子受到过度约束。换句话说，输入数据的合法性检查只发生在前端，而不是后端。然而，后端错误地假设所有外部数据都已经过清理，而没有检查合法性。有经验的攻击者可以绕过前端检测，将恶意数据发送到后端直接利用漏洞。此外，基于前端生成的种子缺乏后端代码的语义信息。因此，很难满足网络数据处理逻辑，并在后端触发深度路径。此外，前端的爬行通信接口可能会错过不可见的接口，这些接口只出现在后端。总之，基于前端的模糊方法限制了漏洞发现的效率和范围。

我们的关键观察是，后端代码的语义可以帮助生成具有有效格式和约束信息的种子，以便在不考虑前端的情况下进行模糊测试。然而，提取后端语义信息来指导模糊测试并不是一项简单的任务。我们面临以下挑战:i)需要正确识别潜在的通信接口，这是测试用例不被丢弃的基本条件。ii)后端代码严格检查不同通信接口的数据字段组成和内容，这是影响代码测试范围的关键因素。

本文提出了一种基于路由器固件静态分析的自动、高效模糊测试框架UCRF (underconstrained router fuzzer)。UCRF根据其特征识别后端所有通信接口，包括不可见的前端接口。然后，通过对每个接口的数据流分析，提取出所有数据字段的三种约束类型。在后端代码中对特定字段中的数据验证约束，满足约束的数据字段可以通过条件检查，并触发受检查保护的更深层代码。最后，根据约束信息，UCRF将结构良好的种子集合起来，并在有意义的测试空间中进行变异，生成测试用例。

我们实现了解决方案UCRF的原型，并在4家供应商的10台流行路由器上运行。UCRF发现了41个零日漏洞，并分配了38个CVE ID, 2个CNVD ID和1个PSV ID。在我们的5个路由器上，UCRF发现的内存损坏和命令注入漏洞明显多于最先进的SRFuzzer。此外，我们评估了接口识别和约束信息。实验结果表明，UCRF识别后端通信接口的准确率为96.3%。对于约束信息，UCRF平均可以找到36.4%的参数关键字的约束(条件计算的固定值或数值范围类型)。请注意，只有在满足约束的情况下才能触发20个漏洞。

综上所述，我们在本文中做出了以下贡献:
- 我们提出了一种新的方法来生成有效的路由器模糊测试用例。我们首先通过对后端二进制文件的静态分析生成结构良好的种子，而不分析前端。进一步，提取数据字段的三种约束类型，仅在有意义的测试空间中引导种子突变，实现有效的测试空间探索。
- 我们实现了原型系统UCRF，这是一个用于SOHO路由器发现后端漏洞的自动模糊测试框架。UCRF在后端识别所有潜在的通信接口，以避免丢失不可见的前端接口，并生成特定于接口的种子。然后，UCRF利用轻量级数据流分析以低开销提取后端二进制数据字段的约束。
- 我们在4家厂商的10台SOHO路由器上对UCRF进行了评估。共发现41个0天漏洞，其中20个只有满足提取的约束条件才能触发，说明基于后端语义生成的种子对漏洞发现是有效的。

在第2节中，我们介绍了SOHO路由器的背景知识，并通过一个示例说明了当前模糊器的局限性。第3节概述了UCRF并描述了详细的设计。在第4节中，我们描述了UCRF的实现，并在第5节中使用真实设备评估了UCRF。在第6节中，我们讨论了UCRF的局限性并提出了未来的工作。在第7节中介绍了与本文相关的研究工作，最后在第8节中对本文进行了总结。

## 2. 背景与动机
### 2.1. SOHO路由器系统
SOHO路由器被广泛用于为各种设备提供网络服务。SOHO路由器通常通过web服务器为最终用户提供一个交互界面，以便正确地连接到Internet并启用网络服务。web服务器通常包含两个组件:前端和后端，它们都包含在固件中。前端是用于用户交互的网页，包括HTML、Javascript等文件。用户在前端输入的数据通过HTTP发送到后端进行处理。在后端，特定的二进制文件(例如httpd)接收和解析来自网络的用户请求，然后根据请求完成预定义的任务。我们将这种二进制称为边界二进制(Redini et al, 2020)。通过这种方式，攻击者控制的数据被引入到固件中。后端可以假定所有接收到的数据在前端验证之后都是可信的。但是，攻击者可以绕过这种验证并直接发送恶意数据以使后端崩溃。最终，外部网络数据的滥用会导致安全漏洞。

为了调用边界二进制中的特定函数进行数据处理，前端向后端发送的请求包括一个action关键字和可能的多个参数关键字。action关键字用于触发不同的句柄函数，根据action关键字在边界二进制文件中注册一系列回调函数。参数关键字是用于标识请求中的数据字段值的键。这种数据传输模式也称为KEY-VALUE模型。前端和后端使用共享关键字描述相同的数据字段(Chen et al, 2021)。边界二进制使用key-value函数(Cheng et al .， 2021)(也称为input entry (Chen et al .， 2021))获取key - value模型的结构化数据，根据给定的键获取数据。

### 2.2. 激励的例子
图1(b)显示了一个例子，这是Netgear R8500中的缓冲区溢出漏洞。为了清楚地说明这个问题，我们简化了代码，而实际情况要复杂得多。websGetVar函数用于根据key - value模型在网络数据中按键获取相应的值。在第12行中，如果网络数据中的主机名长度大于缓冲区长度，则会触发该bug。为了触发此漏洞，攻击者控制的网络数据需要满足以下几个条件:(1)在第8行和第10行，result需要等于apply而不等于cancel。(2)在第21行，号码长度的范围应小于2。

![](images/Pasted%20image%2020231115152023.png)

当前SOHO路由器模糊检测方法(Srivastava等，2019;Zhang et al .， 2019)基于前端生成测试用例很难满足上述约束。由于缺乏后端代码语义，它们很难通过随机突变绕过这些条件(Li et al, 2017;Rawat et al, 2017)。另外，前端严格检查输入数据的合法性，防止恶意数据被发送到后端。这些工具很难生成正确的值来通过前端检查，或者需要引入大量的手工工作。此外，一些数据验证只发生在前端，而不发生在后端，这意味着基于前端生成的种子可能会受到过度约束，从而限制了后端测试的范围。最后，前端的爬行动作关键词可能会错过不可见的界面，并且在后端识别相应的句柄函数仍然是一个挑战。

我们观察到后端代码的语义可以帮助生成具有有效格式和约束信息的种子，用于模糊测试。为了弥合上述差距，一方面，我们可以在后端识别所有接口及其相应的数据字段，以生成有效的格式种子。另一方面，提取特定字段的数据验证有助于生成测试用例，这些测试用例有可能探索更深的路径并缩小突变空间。例如，我们可以使用确定的动作关键字fwSchedule.cgi和相应的参数关键字来生成如图1(a)所示的测试用例。在测试用例中，结果的有效范围是cancel和apply，长度的有效范围小于2，显著提高了模糊效率。

## 3.详细设计
我们开创了UCRF，它通过静态分析固件来指导SOHO路由器模糊检测，以组装结构良好且约束不足的种子。如图2所示，UCRF由三个核心模块组成:(1)动作句柄识别，(2)约束收集，(3)基于约束的模糊测试。固件在分析之前进行预处理以获得文件系统和边界二进制文件。预处理模块是基于当前的研究工作(见第4节)实现的。

- 动作句柄标识。UCRF首先识别后端所有的通信接口，即动作句柄，并使用action关键字来触发它们，这便于在随后的分析中为每个动作句柄生成特定于接口的种子(章节3.1)。
- 约束集合。对于每个操作句柄，UCRF使用轻量级数据流分析提取所有数据字段的约束信息。我们观察到固件主要包括三种类型的数据验证约束，包括类strcmp、类number和类network(章节3.2)。
- 基于约束的模糊测试。UCRF根据识别的动作和参数关键字组装有效格式化的种子。然后，在参数关键字的约束下，对测试用例进行高效、深入的变异。同时，UCRF监控设备的运行状态以检测漏洞(第3.3节)。

![](images/Pasted%20image%2020231115155015.png)

### 3.1. 操作句柄标识
操作句柄是由后端不同操作关键字调用的一系列函数，用于处理前端发送的请求。动作句柄的标识决定了前端和后端交互之间的所有通信接口。爬取前端可以找到动作关键字(Srivastava等人，2019;Zhang et al .， 2019)。但是，如果后端操作关键字没有出现在前端，可能会错过后端一些不可见的界面。清单1显示了Tenda G1中一个不可见接口的示例。在第8行中，操作关键字telnet用于注册一个名为TendaTelnet的操作句柄，该操作句柄用于启动一个shell，该shell允许攻击者执行任意命令。然而，action关键字并没有出现在前端。此外，在前端抓取动作关键字后，在后端仍然难以识别相应的动作句柄。

我们观察到，动作句柄通常在后端注册为一系列回调函数。通过action关键字注册回调函数主要有两种方法。

- 模型1。如清单1第6行至第8行所示，后端使用统一的注册函数使用action关键字注册操作句柄。
- 模型2。如图1(b)第1 ~ 2行所示，动作关键字和动作句柄以边界二进制的形式连续存储在数据段中，通过函数调用表中的不同偏移量间接调用。

![](images/Pasted%20image%2020231115154448.png)

我们的见解是，可以通过分析后端函数指针的数据引用来识别操作句柄。对函数指针的数据引用表明间接调用了操作句柄。所有操作句柄都可以在后端识别，因为action关键字调用一个具有唯一常量字符串的操作句柄。为了进一步过滤误报，我们从多个候选列表中选择调用最多键值函数的函数表。key-value函数用于获取网络数据，如websGetVar。

算法1列出了我们方法的伪代码。我们首先识别边界二进制中的所有函数作为算法的输入。然后，我们根据每个函数指针的数据引用分别分析这两种情况(第4-6行)。对于模型1，函数指针的数据引用属于text段，即函数指针被用作函数参数。对于每个引用位置，我们首先找到它的所有调用者和调用点(第14-16行)。然后，我们发现调用地点的一个参数是否是表示action关键字的常量字符串(第17行)。最后，我们认为真实的注册函数调用频率最高，并收集与之对应的动作关键字和动作句柄(第9-10行)。对于模型2，数据引用属于data段或load段。我们在函数指针的引用地址附近搜索一个常量字符串，作为action关键字的候选对象(第24行)。这种方法可能会找到不用作通信接口的其他函数调用表。我们认为在正确的函数调用表中，有些函数会使用key-value函数来获取网络数据。我们使用它作为一个特性过滤器来获取真实的函数表，并收集action关键字和action句柄(第9-10行)。

![](images/Pasted%20image%2020231115154907.png)

### 3.2. 约束集合
如我们的动机示例(图1)所示，一些参数关键字在后端用于数据验证。只有通过检查后，执行才能触发更深层次的代码路径。我们将参数关键字需要满足的验证条件称为约束。UCRF首先识别action句柄中的所有参数关键字，然后执行数据流分析，收集参数关键字对应的约束。

**参数关键字**。参数关键字根据KEY-VALUE模型标记请求中对应的数据。之前的工作(Cheng et al .， 2021)观察到后端key-value函数被显式地用于解析结构化数据，如key-value模型。根据key-value函数的五个特征，可以将key-value函数定位在后端。当然，在键-值函数中用于获取数据的关键字是参数关键字。但在实际分析中，我们发现有些关键字是在使用前动态生成的，比如使用格式化字符串。为了找到所有参数关键字，我们使用key-value函数开始反向数据流分析，直到找到一个表示参数关键字的常量字符串。对于一些用“%d”格式化的关键字，我们保守地假设它们只对应一个参数关键字。

**约束**。约束是后端对参数关键字的条件比较判断，只有满足约束时才会激活相应的代码路径。收集参数关键字的约束有助于生成不受约束的种子，以达到更深层次的代码，并仅在有意义的测试空间中进行突变。我们总结了后端中三种主要约束类型的案例。

- Strcmp-like.用于条件比较的固定字符串，由类似strcmp的约束函数获得。
- Number-like.数字范围的条件比较，由类似number的约束函数获得。
- Network-like.确定字符串是否是由类似network的约束函数获得的合法网络地址

考虑到嵌入式系统的固件是用内存不安全的低级语言(Szekeres et al, 2013)实现的，例如C/ C++。条件比较代码大量使用C标准库提供的库函数或基于库包装器的函数。我们可以通过分析这些库函数的语义来获得约束条件。我们使用三种类型的约束函数(如表1所示)来收集parameter关键字对数据流的约束:(1)类strcmp函数;(2)类number函数;(3)类network功能。此外，如果一个参数关键字在其数据流中没有访问任何约束函数，即在分析中没有发现该参数关键字被用于条件比较，则我们认为该参数关键字是无约束的。无约束参数关键字通常用于传输终端用户自定义的配置数据，如果后端缺乏清理，可能会导致潜在的漏洞。最后，一些固件使用供应商定义的函数在语义上等同于C标准库中的函数，并且一些函数无法根据名称在剥离的二进制文件中找到。UCRF可以很容易地扩展到第6节中讨论的这样的固件。

**代码遍历**。UCRF 跟踪从key-value函数取出参数关键字的值开始的数据流，并收集约束函数的附加约束。我们分析整个动作句柄函数和它的被调用函数直到最后。我们使用了以前工作中的数据流分析方法(Cheng et al, 2021)，这是一种基于VEX IR的细粒度数据流分析方法(Nethercote and Seward, 2007)。为了实现跨进程通信，在后端使用环境变量或非易失性随机存取存储器(NVRAM)进行数据传输。唯一键用于读取和写入相同的数据。这种通信也存在于边界二进制中，并中断数据流分析(例如，参见5.1节)。我们将基于环境变量或NVRAM写入数据的函数称为setter，将读取数据的相应函数称为getter。UCRF记录用于向setter写入数据的键，并继续从用于从同一键读取数据的getter进行数据流分析，从而使数据流分析不间断地进行。

算法2演示了UCRF的代码遍历策略。首先，我们获得CFG中入度为0的所有节点作为我们分析的开始节点(第11行)。这些节点表示调用链的起点，对于开始节点，我们获得其后续节点作为调用链(第12行)。我们确定key-value函数是否位于每个调用链中。如果是，我们从key-value函数开始的地方初始化数据流分析(第16行)。否则，我们不分析这个调用链，认为这些路径与处理网络数据无关。在数据流分析期间，我们记录了访问setter时用于写入数据的参数关键字和唯一键(第3-6行)。同时，当数据流到达约束函数时，我们将该函数和相应的约束条件记录为对应参数关键字的约束(第7-9行)。在第一个数据流分析结束时，我们确定是否有任何网络数据被写入setter(第17-21行)。如果是这样，我们使用相同的键从getter的位置初始化数据流分析，并继续收集相应参数关键字的约束(第22行)。

![](images/Pasted%20image%2020231115160531.png)

### 3.3 基于约束的模糊测试
UCRF生成结构良好且有约束的测试用例，并直接模糊路由器的后端。首先，UCRF使用前面标识的action关键字和parameter关键字来组合一个有效的格式化种子。之后，UCRF仅在约束信息引导下的有意义的测试空间中对种子进行突变，以实现有效的模糊化。最后，UCRF监视远程设备的状态，以确定在发送测试用例之后是否发生崩溃。

**种子生成**。UCRF根据后端分析的结果生成用于模糊路由器的种子。由于UCRF没有从后端二进制文件接收到的HTTP请求开始执行完整的分析，因此我们无法知道完整的HTTP请求是如何处理的。此外，不同的供应商有不同的固件定制实现。由于上述原因，UCRF首先通过观察前端发送的请求来确定在HTTP中使用哪种格式(例如，JSON和SOAP，两者都遵循KEY-VALUE模型)来传输数据。然后需要三种类型的信息来生成种子:用于请求的URL、参数关键字和用于身份验证的会话。UCRF使用action关键字作为URL来调用后端中的操作句柄。在某些情况下，路由器使用带有特定前缀的URL，而UCRF依赖于分析人员指定应该使用的URL前缀。幸运的是，我们的分析发现，小型嵌入式设备(如SOHO路由器)的url通常遵循相同的模式。分析人员可以快速地在多个URL中发现相同的模式作为URL前缀。例如，清单1中调用接口telnet的完整URL是“/goform/telnet”，其中“/goform/”是所有操作关键字的前缀。然后，UCRF为每个操作句柄使用收集到的参数关键字来生成特定于接口的种子。最后，在分析人员执行登录操作之后，UCRF自动获得访问凭证并组装结构良好且经过身份验证的种子。

**基于约束的变异器**。为了启用基于约束的模糊测试，UCRF根据参数关键字的约束确定是否改变其值。约束表示特定参数关键字的候选值范围。约束信息可用于缩小突变空间，并帮助生成有可能预测更深路径的测试用例。此外，对于类数约束和类网络约束，这意味着数据已经被清理，不需要进行额外的修改。具体来说，对于每一类约束，突变策略如下:
- 对于类strcmp数据。我们从对应于突变参数关键字的约束列表中选择一个候选值。
- 对于类似数字的数据。将收集到的约束和逆值用于组合种子。
- 对于类似网络的数据。从预定义的类网络数据中随机选择值来组装种子，例如“192.168.0.1/24”和“255.255.254.0”。
- 对于无约束的数据。使用随后描述的策略随机变异它们。

UCRF侧重于查找内存损坏和命令注入漏洞，这些漏洞可以很容易地扩展，如第6节所述。为了改变参数关键字的值，我们使用以下策略:
- 字符串长度。为了触发内存损坏漏洞，例如缓冲区溢出，我们使用一个随机字符串并修改其长度作为突变。
- 数值。我们使用随机整数作为突变。特别是，我们对特定的数字(例如，0和1)进行优先排序，以绕过可能的检查。
- 精心制作的的命令。为了触发命令注入漏洞，我们从预定义的数据库中随机选择构造良好的有效负载作为突变，这可以绕过常见的字符限制并触发基于代理的监视器。

**两阶段模糊测试**。我们观察到后端操作句柄分为两类。receiver用于从前端获取数据并对其进行处理(例如POST请求)，而returner用于响应前端请求并返回数据(例如get请求)。为了尽可能正确地测试所有操作句柄，我们在receiver之后发送一个returner并重复循环。我们使用一个简单的启发式策略来区分receiver和returner。在所标识的所有操作句柄中，使用key-value函数获取网络数据的操作句柄是receiver，而其余的操作句柄被认为是returner。我们将对固件中与web相关的文件的请求也视为returner。作为一种模糊测试方法，在无法确定HTTP请求类型的情况下，UCRF使用突变(例如，预定义的GET或POST类型)填充HTTP请求方法。

**变异器**。UCRF监视设备的状态，以检测在模糊过程中由测试用例引起的崩溃，并在监视器检测到异常状态时生成警报。我们实现了两种监测方法来监测设备的状态:(i)基于网络的监测。如果设备没有响应或响应与之前不同，则认为发生了内存崩溃。(ii)基于代理的监控，如果我们的本地代理服务器接收到测试路由器发送的特制请求，则认为发生了命令执行。当监视器发现设备在一段时间后没有响应时，UCRF将物理重启路由器，并在路由器恢复后继续模糊处理。由于UCRF直接测试物理设备，而不依赖于固件仿真，我们不能直接获得错误消息的反馈(例如，段故障)。我们使用上述两种启发式监视器来检测bug。有关故障可观测性的更多讨论，请参见第6节。

## 4.实现
UCRF的设计包括四个步骤：固件预处理、动作句柄识别、约束收集和基于约束的模糊检测。我们将UCRF实现为自动模糊测试框架。

**固件预处理**。我们从供应商的网站上下载了所有设备的固件，然后使用Binwalk(2014)解压缩固件映像。为了确定哪些二进制文件用于网络通信，即边界二进制文件，我们使用SaTc (Chen et al .， 2021)来发现边界二进制文件，作为后续分析的起点。此外，我们利用IDA Pro (IDA, 2022)来识别功能并构建控制流图(CFG)。

**操作句柄标识**。如3.1节模型2中所述，后端二进制代码中间接调用的存在会阻止正确识别某些函数。为了正确识别所有功能，我们使用内存对齐长度(4字节或8字节，取决于CPU架构长度)作为偏移量扫描整个数据段，以确定数据是否指向可执行段地址。如果是，我们将其视为一个函数，并将该函数及其后继节点添加到CFG中。最后，我们通过分析算法2中描述的数据引用来识别操作句柄，在算法2中，我们使用IDA提供的API来收集函数的数据引用信息。

**约束集合**。我们从键值函数开始数据流分析，并收集与参数关键字对应的约束。在数据流分析过程中，如果达到一个预定义的约束函数(见表1)，我们将该约束函数的名称和对应的比较条件记录为对应参数关键字的约束。基于VEX IR的数据流分析方法和键值函数识别方法是在先前工作的基础上建立的(Cheng et al .， 2021)。基于VEX中间表示，我们可以将多种体系结构的原生二进制代码转换成统一的中间表示(IR)，在此基础上实现跨体系结构的二进制分析。我们使用PyVex(2022)在Python中进行中间语言翻译。

![](images/Pasted%20image%2020231116151016.png)

**基于约束的模糊测试**。UCRF使用访问凭证对路由器的后端二进制文件(即web服务器)进行深入测试。UCRF首先使用Selenium(2022)加载一个浏览器，允许分析人员执行登录操作以获取访问凭据。同时，UCRF捕获登录请求，以确定在HTTP中使用哪种格式传输数据。目前，UCRF支持嵌入式设备中使用的常见HTTP消息格式，包括HTTP、JSON、简单对象访问协议(SOAP)和家庭网络管理协议(HNAP)，它们都遵循KEY-VALUE模型。我们使用了Boofuzz(2014)框架，并对其进行了修改，以支持种子生成、mutator和监视器。为了使突变的有效载荷能够在后端绕过简单的清理(例如，字符过滤)，我们使用预先收集的攻击有效载荷来丰富boofuzz mutator模块(Payloadsallthethings, 2018)。在模糊处理过程中，当路由器没有响应时，监控模块将对路由器进行物理重启，强制复位路由器状态。监控模块通过向智能插头发送控制命令来重新启动路由器，使其断电，然后再上电。我们使用了小米智能插头(2022)，并使用Python-miio(2022)将其暴露给Python。

## 5.评估
我们评估UCRF以回答以下研究问题:
- RQ1: UCRF能发现真实世界的漏洞吗？由UCRF生成的种子对发现漏洞有帮助吗?(5.1节)
- RQ2: UCRF在后端可以准确识别多少个操作句柄?(5.2节)
- RQ3: UCRF可以收集多少约束?不同类型的约束如何帮助发现漏洞?(5.3节)

**数据集**。为了评估UCRF，我们选择了一些来自不同厂商的热门设备进行评估，其中包括来自4家厂商的10款路由器设备(表2)，这些设备在之前的研究工作中被广泛使用(Chen et al .， 2021;Redini et al, 2020;Zhang et al .， 2019)。在实验中，我们对物理路由器进行了测试，因为UCRF不依赖固件模拟来获取运行时信息来指导模糊测试。

![](images/Pasted%20image%2020231116151756.png)

**实验设置**。我们购买了这些路由器设备(见图4)，并将它们连接到子网内。为了获得正确的会话进行模糊测试，我们手动设置了路由器的密码并指定了认证方法。最后，我们在一台运行Ubuntu 20.04的40核、256 GB内存的机器上部署了UCRF。

![](images/Pasted%20image%2020231116151814.png)

### 5.1. 漏洞识别
我们使用10台安装最新版本固件的设备对UCRF进行了评估。如表3所示，UCRF在7台设备上共发现41个0天漏洞。我们负责任地向供应商报告了这些漏洞，并得到了证实。其中，24个漏洞是缓冲区溢出漏洞，另外17个是命令注入漏洞。这些漏洞可能导致设备崩溃，从而导致DDoS攻击或远程命令执行。总体而言，这些漏洞共被分配了38个CVE ID、2个CNVD ID和1个PSV ID，分配的ID如表7所示。

为了探索基于约束的UCRF生成的种子的有效性，我们根据漏洞警报对固件进行人工逆向工程，并分析漏洞触发的条件。表3中的最后两列说明，为了触发这些漏洞，需要对一个或多个参数关键字进行并发突变。其中，当两个或多个参数关键字值在一个测试用例中发生突变时，触发了20个漏洞，并且至少有一个值基于约束信息。其余21个漏洞仅在一个值发生突变时触发，不需要约束信息。注意，UCRF可以通过限制约束域的突变空间来帮助发现漏洞，从而提高模糊化效率。

![](images/Pasted%20image%2020231116152552.png)

**比较**。SRFuzzer (Zhang et al, 2019)和ESRFuzzer (Zhang et al, 2021)是最先进的SOHO路由器模糊测试工具。SRFuzzer (Zhang et al .， 2019)通过模拟浏览器的提交行为生成测试用例，并捕获前端发送的请求作为种子。SRFuzzer重复填充网页10次，分析变量属性标签请求，包括固定字符串、数字和可变字符串。SRFuzzer将固定字符串和数字视为不变量，可用于在后端通过条件检查。然而，后端代码的严格输入检查使得模糊测试效率低下。UCRF在后端收集约束，以获得更准确的语义信息，以达到深度路径。ESRFuzzer (Zhang et al, 2021)使用D-CONF模式增强了SRFuzzer，该模式利用部分路由器提供的NVRAM配置操作，并从后端从NVRAM键值对读取数据的位置开始模糊测试。单个NVRAM键值对代表一个参数关键字及其对应的值。D-CONF模式可以帮助ESRFuzzer在忽略部分后端数据验证的前提下更深入地测试代码。

为了将我们的方法与SRFuzzer和ESRFuzzer进行比较，我们联系了作者，但未能获得他们的工具。我们从SRFuzzer和ESRFuzzer的数据集中选择了10个实验设备中的5个，在相同的固件版本上进行实验。没有选择设备进行评估，原因如下:(1)Mercury Mer450和ASUS RT-AC1200，供应商已经下架，我们无法获得。(2) Netgear Orbi和Netgear Insight，总价超过600美元，对我们来说价格比较贵。(3)对于TP-Link TL-WVR900G，设备的后端web服务器是用Lua编程的，UCRF目前只适用于内存不安全的低级编程语言(例如，C/ c++)，目的是发现内存损坏和命令注入漏洞。我们将UCRF运行了40小时，与SRFuzzer和ESRFuzzer论文中描述的时间相同。由于一些漏洞细节不是公开可用的，我们通过比较发现的漏洞的数量来说明UCRF的漏洞发现能力。