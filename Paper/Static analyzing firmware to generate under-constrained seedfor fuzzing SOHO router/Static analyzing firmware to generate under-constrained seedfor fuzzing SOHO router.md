# UCRF: Static analyzing firmware to generate under-constrained seedfor fuzzing SOHO router


![](images/Pasted%20image%2020231114110818.png)

2023 Computers & Security

## 摘要
SOHO(小型办公室和家庭办公室)路由器是物联网的关键要素，为各种智能设备提供网络服务。近年来，针对SOHO路由器网络应用程序的攻击越来越多。web服务器在直接接收和处理外部数据的过程中引入了大量的漏洞。模糊测试是发现此类漏洞最常用的技术。以前提出的方法通过分析前端以有效格式生成模糊种子。不幸的是，生成的种子受到前端代码合法性检查的过度约束，因为恶意数据可以绕过前端检查而直接发送到后端。而且，这种种子忽略了后端的语义，使得后端的检查逻辑阻碍了模糊测试的效率。

在本文中，我们提出了一种通过静态分析后端二进制文件生成高质量测试用例来模糊SOHO路由器的新方法。具体而言，我们首先获得后端所有通信接口，以避免丢失不可见的前端接口。然后，对每个接口进行数据流分析，提取所有数据字段的约束信息。最终，有效和深入的测试用例只能在基于约束信息的有意义的测试空间中生成。我们在一个名为UCRF的工具中实现了我们的方法。为了说明UCRF的有效性，我们对来自4家供应商的10个真实固件进行了评估。UCRF在我们的5个路由器上发现了比最先进的SRFuzzer更多的内存损坏和命令注入漏洞。此外，UCRF共发现41个0天后端漏洞，其中20个只有在满足提取的约束条件时才能触发。

## 1.引言
物联网(IoT)设备越来越多地应用于人们的日常生活中(Alrawi et al, 2019)。根据全球移动通信系统协会(GSMA)的报告(the Mobile Economy, 2022)，到2021年，全球物联网设备总数已达到151亿，预计到2025年将增长到233亿。SOHO (Small office and home office)路由器被广泛用于为智能家居、笔记本电脑、智能手机等各种设备提供网络服务，因此SOHO路由器的安全性至关重要。不幸的是，由于嵌入式系统资源有限，SOHO路由器中缺少常见的安全机制(Smart Yet flaws, 2020;Thompson and Zatko, 2018;Yu et al, 2022)，并且许多漏洞可以被攻击者远程利用(Cisco Small, 2022;Dir, 2022)。例如，2016年，Mirai僵尸网络入侵了数百万台物联网设备，并对互联网基础设施公司Dyn发起了分布式拒绝服务(DDoS)攻击，导致欧洲和北美的大规模互联网服务中断(Kolias等人，2017;Mirai, 2016;结束,2018;旅行路由器，2017)。

路由器易受攻击的一个重要原因是它们内部易受攻击的web服务(Cisco Small, 2022;Costin et al, 2016)。SOHO路由器提供自定义web服务器供终端用户配置。web服务器通常包含前端(HTML和JavaScript等)和后端(如web服务器和公共网关接口)。用户数据在前端输入，并通过超文本传输协议(Hypertext Transfer Protocol, HTTP)发送到后端进行进一步处理。恶意用户网络数据很容易绕过前端检测(例如，中间人攻击)，被发送到后端进行处理。最终，该漏洞被利用来泄露信息或使设备崩溃。

近年来，人们提出了许多针对SOHO路由器的漏洞发现方法，包括静态分析(Chen et al .， 2021;Cheng等，2021;2018;Redini等人，2020)和动态测试(例如，模糊测试)(Srivastava等人，2019;Wang et al .， 2013;Zhang等，2021;2019;郑等，2019a;2019 b)。静态分析具有天然的局限性，存在许多误报(Shoshitaishvili等人，2016;Vadayath et al, 2022)。为了验证漏洞警报和编写概念验证(PoC)脚本，引入了大量的手工工作。模糊测试是一种流行的漏洞发现技术。固件仿真提供固件的运行时信息，包括代码覆盖率，这些信息可用于指导模糊测试。然而，由于外设依赖性，仿真自定义固件需要大量的手工工作(Chen等人，2016;Kim et al, 2020;Zaddach et al .， 2014)。为了避免固件仿真中的问题，一些研究工作选择直接对物理路由器进行测试。然而，如果没有有效信息的指导，生成有效的测试用例并执行深入的测试是具有挑战性的，这最终会导致大量的假阴性。

现有的物理SOHO路由器模糊测试方法基于前端生成测试用例(Srivastava et al .， 2019;Zhang et al .， 2019)。例如，这些方法模拟前端的行为，并生成请求作为模糊测试的种子。但是，前端严格验证输入数据的有效性，这使得生成的种子受到过度约束。换句话说，输入数据的合法性检查只发生在前端，而不是后端。然而，后端错误地假设所有外部数据都已经过清理，而没有检查合法性。有经验的攻击者可以绕过前端检测，将恶意数据发送到后端直接利用漏洞。此外，基于前端生成的种子缺乏后端代码的语义信息。因此，很难满足网络数据处理逻辑，并在后端触发深度路径。此外，前端的爬行通信接口可能会错过不可见的接口，这些接口只出现在后端。总之，基于前端的模糊方法限制了漏洞发现的效率和范围。

我们的关键观察是，后端代码的语义可以帮助生成具有有效格式和约束信息的种子，以便在不考虑前端的情况下进行模糊测试。然而，提取后端语义信息来指导模糊测试并不是一项简单的任务。我们面临以下挑战:i)需要正确识别潜在的通信接口，这是测试用例不被丢弃的基本条件。ii)后端代码严格检查不同通信接口的数据字段组成和内容，这是影响代码测试范围的关键因素。

本文提出了一种基于路由器固件静态分析的自动、高效模糊测试框架UCRF (underconstrained router fuzzer)。UCRF根据其特征识别后端所有通信接口，包括不可见的前端接口。然后，通过对每个接口的数据流分析，提取出所有数据字段的三种约束类型。在后端代码中对特定字段中的数据验证约束，满足约束的数据字段可以通过条件检查，并触发受检查保护的更深层代码。最后，根据约束信息，UCRF将结构良好的种子集合起来，并在有意义的测试空间中进行变异，生成测试用例。

我们实现了解决方案UCRF的原型，并在4家供应商的10台流行路由器上运行。UCRF发现了41个零日漏洞，并分配了38个CVE ID, 2个CNVD ID和1个PSV ID。在我们的5个路由器上，UCRF发现的内存损坏和命令注入漏洞明显多于最先进的SRFuzzer。此外，我们评估了接口识别和约束信息。实验结果表明，UCRF识别后端通信接口的准确率为96.3%。对于约束信息，UCRF平均可以找到36.4%的参数关键字的约束(条件计算的固定值或数值范围类型)。请注意，只有在满足约束的情况下才能触发20个漏洞。

综上所述，我们在本文中做出了以下贡献:
- 我们提出了一种新的方法来生成有效的路由器模糊测试用例。我们首先通过对后端二进制文件的静态分析生成结构良好的种子，而不分析前端。进一步，提取数据字段的三种约束类型，仅在有意义的测试空间中引导种子突变，实现有效的测试空间探索。
- 我们实现了原型系统UCRF，这是一个用于SOHO路由器发现后端漏洞的自动模糊测试框架。UCRF在后端识别所有潜在的通信接口，以避免丢失不可见的前端接口，并生成特定于接口的种子。然后，UCRF利用轻量级数据流分析以低开销提取后端二进制数据字段的约束。
- 我们在4家厂商的10台SOHO路由器上对UCRF进行了评估。共发现41个0天漏洞，其中20个只有满足提取的约束条件才能触发，说明基于后端语义生成的种子对漏洞发现是有效的。

在第2节中，我们介绍了SOHO路由器的背景知识，并通过一个示例说明了当前模糊器的局限性。第3节概述了UCRF并描述了详细的设计。在第4节中，我们描述了UCRF的实现，并在第5节中使用真实设备评估了UCRF。在第6节中，我们讨论了UCRF的局限性并提出了未来的工作。在第7节中介绍了与本文相关的研究工作，最后在第8节中对本文进行了总结。

## 2. 背景与动机
### 2.1. SOHO路由器系统
SOHO路由器被广泛用于为各种设备提供网络服务。SOHO路由器通常通过web服务器为最终用户提供一个交互界面，以便正确地连接到Internet并启用网络服务。web服务器通常包含两个组件:前端和后端，它们都包含在固件中。前端是用于用户交互的网页，包括HTML、Javascript等文件。用户在前端输入的数据通过HTTP发送到后端进行处理。在后端，特定的二进制文件(例如httpd)接收和解析来自网络的用户请求，然后根据请求完成预定义的任务。我们将这种二进制称为边界二进制(Redini et al, 2020)。通过这种方式，攻击者控制的数据被引入到固件中。后端可以假定所有接收到的数据在前端验证之后都是可信的。但是，攻击者可以绕过这种验证并直接发送恶意数据以使后端崩溃。最终，外部网络数据的滥用会导致安全漏洞。

为了调用边界二进制中的特定函数进行数据处理，前端向后端发送的请求包括一个action关键字和可能的多个参数关键字。action关键字用于触发不同的句柄函数，根据action关键字在边界二进制文件中注册一系列回调函数。参数关键字是用于标识请求中的数据字段值的键。这种数据传输模式也称为KEY-VALUE模型。前端和后端使用共享关键字描述相同的数据字段(Chen et al, 2021)。边界二进制使用key-value函数(Cheng et al .， 2021)(也称为input entry (Chen et al .， 2021))获取key - value模型的结构化数据，根据给定的键获取数据。

### 2.2. 激励的例子
图1(b)显示了一个例子，这是Netgear R8500中的缓冲区溢出漏洞。为了清楚地说明这个问题，我们简化了代码，而实际情况要复杂得多。websGetVar函数用于根据key - value模型在网络数据中按键获取相应的值。在第12行中，如果网络数据中的主机名长度大于缓冲区长度，则会触发该bug。为了触发此漏洞，攻击者控制的网络数据需要满足以下几个条件:(1)在第8行和第10行，result需要等于apply而不等于cancel。(2)在第21行，号码长度的范围应小于2。

![](images/Pasted%20image%2020231115152023.png)

当前SOHO路由器模糊检测方法(Srivastava等，2019;Zhang et al .， 2019)基于前端生成测试用例很难满足上述约束。由于缺乏后端代码语义，它们很难通过随机突变绕过这些条件(Li et al, 2017;Rawat et al, 2017)。另外，前端严格检查输入数据的合法性，防止恶意数据被发送到后端。这些工具很难生成正确的值来通过前端检查，或者需要引入大量的手工工作。此外，一些数据验证只发生在前端，而不发生在后端，这意味着基于前端生成的种子可能会受到过度约束，从而限制了后端测试的范围。最后，前端的爬行动作关键词可能会错过不可见的界面，并且在后端识别相应的句柄函数仍然是一个挑战。

我们观察到后端代码的语义可以帮助生成具有有效格式和约束信息的种子，用于模糊测试。为了弥合上述差距，一方面，我们可以在后端识别所有接口及其相应的数据字段，以生成有效的格式种子。另一方面，提取特定字段的数据验证有助于生成测试用例，这些测试用例有可能探索更深的路径并缩小突变空间。例如，我们可以使用确定的动作关键字fwSchedule.cgi和相应的参数关键字来生成如图1(a)所示的测试用例。在测试用例中，结果的有效范围是cancel和apply，长度的有效范围小于2，显著提高了模糊效率。

## 3.详细设计
我们开创了UCRF，它通过静态分析固件来指导SOHO路由器模糊检测，以组装结构良好且约束不足的种子。如图2所示，UCRF由三个核心模块组成:(1)动作句柄识别，(2)约束收集，(3)基于约束的模糊测试。固件在分析之前进行预处理以获得文件系统和边界二进制文件。预处理模块是基于当前的研究工作(见第4节)实现的。

- 动作句柄标识。UCRF首先识别后端所有的通信接口，即动作句柄，并使用action关键字来触发它们，这便于在随后的分析中为每个动作句柄生成特定于接口的种子(章节3.1)。
- 约束集合。对于每个操作句柄，UCRF使用轻量级数据流分析提取所有数据字段的约束信息。我们观察到固件主要包括三种类型的数据验证约束，包括类strcmp、类number和类network(章节3.2)。
- 基于约束的模糊测试。UCRF根据识别的动作和参数关键字组装有效格式化的种子。然后，在参数关键字的约束下，对测试用例进行高效、深入的变异。同时，UCRF监控设备的运行状态以检测漏洞(第3.3节)。

![](images/Pasted%20image%2020231115155015.png)

### 3.1. 操作句柄标识
操作句柄是由后端不同操作关键字调用的一系列函数，用于处理前端发送的请求。动作句柄的标识决定了前端和后端交互之间的所有通信接口。爬取前端可以找到动作关键字(Srivastava等人，2019;Zhang et al .， 2019)。但是，如果后端操作关键字没有出现在前端，可能会错过后端一些不可见的界面。清单1显示了Tenda G1中一个不可见接口的示例。在第8行中，操作关键字telnet用于注册一个名为TendaTelnet的操作句柄，该操作句柄用于启动一个shell，该shell允许攻击者执行任意命令。然而，action关键字并没有出现在前端。此外，在前端抓取动作关键字后，在后端仍然难以识别相应的动作句柄。

我们观察到，动作句柄通常在后端注册为一系列回调函数。通过action关键字注册回调函数主要有两种方法。

- 模型1。如清单1第6行至第8行所示，后端使用统一的注册函数使用action关键字注册操作句柄。
- 模型2。如图1(b)第1 ~ 2行所示，动作关键字和动作句柄以边界二进制的形式连续存储在数据段中，通过函数调用表中的不同偏移量间接调用。

![](images/Pasted%20image%2020231115154448.png)

我们的见解是，可以通过分析后端函数指针的数据引用来识别操作句柄。对函数指针的数据引用表明间接调用了操作句柄。所有操作句柄都可以在后端识别，因为action关键字调用一个具有唯一常量字符串的操作句柄。为了进一步过滤误报，我们从多个候选列表中选择调用最多键值函数的函数表。key-value函数用于获取网络数据，如websGetVar。

算法1列出了我们方法的伪代码。我们首先识别边界二进制中的所有函数作为算法的输入。然后，我们根据每个函数指针的数据引用分别分析这两种情况(第4-6行)。对于模型1，函数指针的数据引用属于text段，即函数指针被用作函数参数。对于每个引用位置，我们首先找到它的所有调用者和调用点(第14-16行)。然后，我们发现调用地点的一个参数是否是表示action关键字的常量字符串(第17行)。最后，我们认为真实的注册函数调用频率最高，并收集与之对应的动作关键字和动作句柄(第9-10行)。对于模型2，数据引用属于data段或load段。我们在函数指针的引用地址附近搜索一个常量字符串，作为action关键字的候选对象(第24行)。这种方法可能会找到不用作通信接口的其他函数调用表。我们认为在正确的函数调用表中，有些函数会使用key-value函数来获取网络数据。我们使用它作为一个特性过滤器来获取真实的函数表，并收集action关键字和action句柄(第9-10行)。

![](images/Pasted%20image%2020231115154907.png)

### 3.2. 约束集合
如我们的动机示例(图1)所示，一些参数关键字在后端用于数据验证。只有通过检查后，执行才能触发更深层次的代码路径。我们将参数关键字需要满足的验证条件称为约束。UCRF首先识别action句柄中的所有参数关键字，然后执行数据流分析，收集参数关键字对应的约束。

**参数关键字**。参数关键字根据KEY-VALUE模型标记请求中对应的数据。之前的工作(Cheng et al .， 2021)观察到后端key-value函数被显式地用于解析结构化数据，如key-value模型。根据key-value函数的五个特征，可以将key-value函数定位在后端。当然，在键-值函数中用于获取数据的关键字是参数关键字。但在实际分析中，我们发现有些关键字是在使用前动态生成的，比如使用格式化字符串。为了找到所有参数关键字，我们使用key-value函数开始反向数据流分析，直到找到一个表示参数关键字的常量字符串。对于一些用“%d”格式化的关键字，我们保守地假设它们只对应一个参数关键字。

**约束**。约束是后端对参数关键字的条件比较判断，只有满足约束时才会激活相应的代码路径。收集参数关键字的约束有助于生成不受约束的种子，以达到更深层次的代码，并仅在有意义的测试空间中进行突变。我们总结了后端中三种主要约束类型的案例。

- Strcmp-like.用于条件比较的固定字符串，由类似strcmp的约束函数获得。
- Number-like.数字范围的条件比较，由类似number的约束函数获得。
- Network-like.确定字符串是否是由类似network的约束函数获得的合法网络地址

考虑到嵌入式系统的固件是用内存不安全的低级语言(Szekeres et al, 2013)实现的，例如C/ C++。条件比较代码大量使用C标准库提供的库函数或基于库包装器的函数。我们可以通过分析这些库函数的语义来获得约束条件。我们使用三种类型的约束函数(如表1所示)来收集parameter关键字对数据流的约束:(1)类strcmp函数;(2)类number函数;(3)类network功能。此外，如果一个参数关键字在其数据流中没有访问任何约束函数，即在分析中没有发现该参数关键字被用于条件比较，则我们认为该参数关键字是无约束的。无约束参数关键字通常用于传输终端用户自定义的配置数据，如果后端缺乏清理，可能会导致潜在的漏洞。最后，一些固件使用供应商定义的函数在语义上等同于C标准库中的函数，并且一些函数无法根据名称在剥离的二进制文件中找到。UCRF可以很容易地扩展到第6节中讨论的这样的固件。

**代码遍历**。UCRF 跟踪从key-value函数取出参数关键字的值开始的数据流，并收集约束函数的附加约束。我们分析整个动作句柄函数和它的被调用函数直到最后。我们使用了以前工作中的数据流分析方法(Cheng et al, 2021)，这是一种基于VEX IR的细粒度数据流分析方法(Nethercote and Seward, 2007)。为了实现跨进程通信，在后端使用环境变量或非易失性随机存取存储器(NVRAM)进行数据传输。唯一键用于读取和写入相同的数据。这种通信也存在于边界二进制中，并中断数据流分析(例如，参见5.1节)。我们将基于环境变量或NVRAM写入数据的函数称为setter，将读取数据的相应函数称为getter。UCRF记录用于向setter写入数据的键，并继续从用于从同一键读取数据的getter进行数据流分析，从而使数据流分析不间断地进行。

算法2演示了UCRF的代码遍历策略。首先，我们获得CFG中入度为0的所有节点作为我们分析的开始节点(第11行)。这些节点表示调用链的起点，对于开始节点，我们获得其后续节点作为调用链(第12行)。我们确定key-value函数是否位于每个调用链中。如果是，我们从key-value函数开始的地方初始化数据流分析(第16行)。否则，我们不分析这个调用链，认为这些路径与处理网络数据无关。在数据流分析期间，我们记录了访问setter时用于写入数据的参数关键字和唯一键(第3-6行)。同时，当数据流到达约束函数时，我们将该函数和相应的约束条件记录为对应参数关键字的约束(第7-9行)。在第一个数据流分析结束时，我们确定是否有任何网络数据被写入setter(第17-21行)。如果是这样，我们使用相同的键从getter的位置初始化数据流分析，并继续收集相应参数关键字的约束(第22行)。

![](images/Pasted%20image%2020231115160531.png)

### 3.3 基于约束的模糊测试
UCRF生成结构良好且有约束的测试用例，并直接模糊路由器的后端。首先，UCRF使用前面标识的action关键字和parameter关键字来组合一个有效的格式化种子。之后，UCRF仅在约束信息引导下的有意义的测试空间中对种子进行突变，以实现有效的模糊化。最后，UCRF监视远程设备的状态，以确定在发送测试用例之后是否发生崩溃。

