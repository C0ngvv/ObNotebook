# UCRF: Static analyzing firmware to generate under-constrained seedfor fuzzing SOHO router


![](images/Pasted%20image%2020231114110818.png)

2023 Computers & Security

## 摘要
SOHO(小型办公室和家庭办公室)路由器是物联网的关键要素，为各种智能设备提供网络服务。近年来，针对SOHO路由器网络应用程序的攻击越来越多。web服务器在直接接收和处理外部数据的过程中引入了大量的漏洞。模糊测试是发现此类漏洞最常用的技术。以前提出的方法通过分析前端以有效格式生成模糊种子。不幸的是，生成的种子受到前端代码合法性检查的过度约束，因为恶意数据可以绕过前端检查而直接发送到后端。而且，这种种子忽略了后端的语义，使得后端的检查逻辑阻碍了模糊测试的效率。

在本文中，我们提出了一种通过静态分析后端二进制文件生成高质量测试用例来模糊SOHO路由器的新方法。具体而言，我们首先获得后端所有通信接口，以避免丢失不可见的前端接口。然后，对每个接口进行数据流分析，提取所有数据字段的约束信息。最终，有效和深入的测试用例只能在基于约束信息的有意义的测试空间中生成。我们在一个名为UCRF的工具中实现了我们的方法。为了说明UCRF的有效性，我们对来自4家供应商的10个真实固件进行了评估。UCRF在我们的5个路由器上发现了比最先进的SRFuzzer更多的内存损坏和命令注入漏洞。此外，UCRF共发现41个0天后端漏洞，其中20个只有在满足提取的约束条件时才能触发。

## 1.引言
物联网(IoT)设备越来越多地应用于人们的日常生活中(Alrawi et al, 2019)。根据全球移动通信系统协会(GSMA)的报告(the Mobile Economy, 2022)，到2021年，全球物联网设备总数已达到151亿，预计到2025年将增长到233亿。SOHO (Small office and home office)路由器被广泛用于为智能家居、笔记本电脑、智能手机等各种设备提供网络服务，因此SOHO路由器的安全性至关重要。不幸的是，由于嵌入式系统资源有限，SOHO路由器中缺少常见的安全机制(Smart Yet flaws, 2020;Thompson and Zatko, 2018;Yu et al, 2022)，并且许多漏洞可以被攻击者远程利用(Cisco Small, 2022;Dir, 2022)。例如，2016年，Mirai僵尸网络入侵了数百万台物联网设备，并对互联网基础设施公司Dyn发起了分布式拒绝服务(DDoS)攻击，导致欧洲和北美的大规模互联网服务中断(Kolias等人，2017;Mirai, 2016;结束,2018;旅行路由器，2017)。

路由器易受攻击的一个重要原因是它们内部易受攻击的web服务(Cisco Small, 2022;Costin et al, 2016)。SOHO路由器提供自定义web服务器供终端用户配置。web服务器通常包含前端(HTML和JavaScript等)和后端(如web服务器和公共网关接口)。用户数据在前端输入，并通过超文本传输协议(Hypertext Transfer Protocol, HTTP)发送到后端进行进一步处理。恶意用户网络数据很容易绕过前端检测(例如，中间人攻击)，被发送到后端进行处理。最终，该漏洞被利用来泄露信息或使设备崩溃。

近年来，人们提出了许多针对SOHO路由器的漏洞发现方法，包括静态分析(Chen et al .， 2021;Cheng等，2021;2018;Redini等人，2020)和动态测试(例如，模糊测试)(Srivastava等人，2019;Wang et al .， 2013;Zhang等，2021;2019;郑等，2019a;2019 b)。静态分析具有天然的局限性，存在许多误报(Shoshitaishvili等人，2016;Vadayath et al, 2022)。为了验证漏洞警报和编写概念验证(PoC)脚本，引入了大量的手工工作。模糊测试是一种流行的漏洞发现技术。固件仿真提供固件的运行时信息，包括代码覆盖率，这些信息可用于指导模糊测试。然而，由于外设依赖性，仿真自定义固件需要大量的手工工作(Chen等人，2016;Kim et al, 2020;Zaddach et al .， 2014)。为了避免固件仿真中的问题，一些研究工作选择直接对物理路由器进行测试。然而，如果没有有效信息的指导，生成有效的测试用例并执行深入的测试是具有挑战性的，这最终会导致大量的假阴性。

现有的物理SOHO路由器模糊测试方法基于前端生成测试用例(Srivastava et al .， 2019;Zhang et al .， 2019)。例如，这些方法模拟前端的行为，并生成请求作为模糊测试的种子。但是，前端严格验证输入数据的有效性，这使得生成的种子受到过度约束。换句话说，输入数据的合法性检查只发生在前端，而不是后端。然而，后端错误地假设所有外部数据都已经过清理，而没有检查合法性。有经验的攻击者可以绕过前端检测，将恶意数据发送到后端直接利用漏洞。此外，基于前端生成的种子缺乏后端代码的语义信息。因此，很难满足网络数据处理逻辑，并在后端触发深度路径。此外，前端的爬行通信接口可能会错过不可见的接口，这些接口只出现在后端。总之，基于前端的模糊方法限制了漏洞发现的效率和范围。

我们的关键观察是，后端代码的语义可以帮助生成具有有效格式和约束信息的种子，以便在不考虑前端的情况下进行模糊测试。然而，提取后端语义信息来指导模糊测试并不是一项简单的任务。我们面临以下挑战:i)需要正确识别潜在的通信接口，这是测试用例不被丢弃的基本条件。ii)后端代码严格检查不同通信接口的数据字段组成和内容，这是影响代码测试范围的关键因素。

本文提出了一种基于路由器固件静态分析的自动、高效模糊测试框架UCRF (underconstrained router fuzzer)。UCRF根据其特征识别后端所有通信接口，包括不可见的前端接口。然后，通过对每个接口的数据流分析，提取出所有数据字段的三种约束类型。在后端代码中对特定字段中的数据验证约束，满足约束的数据字段可以通过条件检查，并触发受检查保护的更深层代码。最后，根据约束信息，UCRF将结构良好的种子集合起来，并在有意义的测试空间中进行变异，生成测试用例。

我们实现了解决方案UCRF的原型，并在4家供应商的10台流行路由器上运行。UCRF发现了41个零日漏洞，并分配了38个CVE ID, 2个CNVD ID和1个PSV ID。在我们的5个路由器上，UCRF发现的内存损坏和命令注入漏洞明显多于最先进的SRFuzzer。此外，我们评估了接口识别和约束信息。实验结果表明，UCRF识别后端通信接口的准确率为96.3%。对于约束信息，UCRF平均可以找到36.4%的参数关键字的约束(条件计算的固定值或数值范围类型)。请注意，只有在满足约束的情况下才能触发20个漏洞。

综上所述，我们在本文中做出了以下贡献:
- 我们提出了一种新的方法来生成有效的路由器模糊测试用例。我们首先通过对后端二进制文件的静态分析生成结构良好的种子，而不分析前端。进一步，提取数据字段的三种约束类型，仅在有意义的测试空间中引导种子突变，实现有效的测试空间探索。
- 我们实现了原型系统UCRF，这是一个用于SOHO路由器发现后端漏洞的自动模糊测试框架。UCRF在后端识别所有潜在的通信接口，以避免丢失不可见的前端接口，并生成特定于接口的种子。然后，UCRF利用轻量级数据流分析以低开销提取后端二进制数据字段的约束。
- 我们在4家厂商的10台SOHO路由器上对UCRF进行了评估。共发现41个0天漏洞，其中20个只有满足提取的约束条件才能触发，说明基于后端语义生成的种子对漏洞发现是有效的。

在第2节中，我们介绍了SOHO路由器的背景知识，并通过一个示例说明了当前模糊器的局限性。第3节概述了UCRF并描述了详细的设计。在第4节中，我们描述了UCRF的实现，并在第5节中使用真实设备评估了UCRF。在第6节中，我们讨论了UCRF的局限性并提出了未来的工作。在第7节中介绍了与本文相关的研究工作，最后在第8节中对本文进行了总结。

## 2. 背景与动机
### 2.1. SOHO路由器系统
SOHO路由器被广泛用于为各种设备提供网络服务。SOHO路由器通常通过web服务器为最终用户提供一个交互界面，以便正确地连接到Internet并启用网络服务。web服务器通常包含两个组件:前端和后端，它们都包含在固件中。前端是用于用户交互的网页，包括HTML、Javascript等文件。用户在前端输入的数据通过HTTP发送到后端进行处理。在后端，特定的二进制文件(例如httpd)接收和解析来自网络的用户请求，然后根据请求完成预定义的任务。我们将这种二进制称为边界二进制(Redini et al, 2020)。通过这种方式，攻击者控制的数据被引入到固件中。后端可以假定所有接收到的数据在前端验证之后都是可信的。但是，攻击者可以绕过这种验证并直接发送恶意数据以使后端崩溃。最终，外部网络数据的滥用会导致安全漏洞。

为了调用边界二进制中的特定函数进行数据处理，前端向后端发送的请求包括一个action关键字和可能的多个参数关键字。action关键字用于触发不同的句柄函数，根据action关键字在边界二进制文件中注册一系列回调函数。参数关键字是用于标识请求中的数据字段值的键。这种数据传输模式也称为KEY-VALUE模型。前端和后端使用共享关键字描述相同的数据字段(Chen et al, 2021)。边界二进制使用key-value函数(Cheng et al .， 2021)(也称为input entry (Chen et al .， 2021))获取key - value模型的结构化数据，根据给定的键获取数据。

### 2.2. 激励的例子
图1(b)显示了一个例子，这是Netgear R8500中的缓冲区溢出漏洞。为了清楚地说明这个问题，我们简化了代码，而实际情况要复杂得多。websGetVar函数用于根据key - value模型在网络数据中按键获取相应的值。在第12行中，如果网络数据中的主机名长度大于缓冲区长度，则会触发该bug。为了触发此漏洞，攻击者控制的网络数据需要满足以下几个条件:(1)在第8行和第10行，result需要等于apply而不等于cancel。(2)在第21行，号码长度的范围应小于2。

![](images/Pasted%20image%2020231115152023.png)

当前SOHO路由器模糊检测方法(Srivastava等，2019;Zhang et al .， 2019)基于前端生成测试用例很难满足上述约束。由于缺乏后端代码语义，它们很难通过随机突变绕过这些条件(Li et al, 2017;Rawat et al, 2017)。另外，前端严格检查输入数据的合法性，防止恶意数据被发送到后端。这些工具很难生成正确的值来通过前端检查，或者需要引入大量的手工工作。此外，一些数据验证只发生在前端，而不发生在后端，这意味着基于前端生成的种子可能会受到过度约束，从而限制了后端测试的范围。最后，前端的爬行动作关键词可能会错过不可见的界面，并且在后端识别相应的句柄函数仍然是一个挑战。

我们观察到后端代码的语义可以帮助生成具有有效格式和约束信息的种子，用于模糊测试。为了弥合上述差距，一方面，我们可以在后端识别所有接口及其相应的数据字段，以生成有效的格式种子。另一方面，提取特定字段的数据验证有助于生成测试用例，这些测试用例有可能探索更深的路径并缩小突变空间。例如，我们可以使用确定的动作关键字fwSchedule.cgi和相应的参数关键字来生成如图1(a)所示的测试用例。在测试用例中，结果的有效范围是cancel和apply，长度的有效范围小于2，显著提高了模糊效率。

## 3.详细设计
我们开创了UCRF，它通过静态分析固件来指导SOHO路由器模糊检测，以组装结构良好且约束不足的种子。如图2所示，UCRF由三个核心模块组成:(1)动作句柄识别，(2)约束收集，(3)基于约束的模糊测试。固件在分析之前进行预处理以获得文件系统和边界二进制文件。预处理模块是基于当前的研究工作(见第4节)实现的。

- 动作句柄标识。UCRF首先识别后端所有的通信接口，即动作句柄，并使用action关键字来触发它们，这便于在随后的分析中为每个动作句柄生成特定于接口的种子(章节3.1)。
- 约束集合。对于每个操作句柄，UCRF使用轻量级数据流分析提取所有数据字段的约束信息。我们观察到固件主要包括三种类型的数据验证约束，包括类strcmp、类number和类network(章节3.2)。
- 基于约束的模糊测试。UCRF根据识别的动作和参数关键字组装有效格式化的种子。然后，在参数关键字的约束下，对测试用例进行高效、深入的变异。同时，UCRF监控设备的运行状态以检测漏洞(第3.3节)。

![](images/Pasted%20image%2020231115155015.png)

### 3.1. 操作句柄标识
操作句柄是由后端不同操作关键字调用的一系列函数，用于处理前端发送的请求。动作句柄的标识决定了前端和后端交互之间的所有通信接口。爬取前端可以找到动作关键字(Srivastava等人，2019;Zhang et al .， 2019)。但是，如果后端操作关键字没有出现在前端，可能会错过后端一些不可见的界面。清单1显示了Tenda G1中一个不可见接口的示例。在第8行中，操作关键字telnet用于注册一个名为TendaTelnet的操作句柄，该操作句柄用于启动一个shell，该shell允许攻击者执行任意命令。然而，action关键字并没有出现在前端。此外，在前端抓取动作关键字后，在后端仍然难以识别相应的动作句柄。

我们观察到，动作句柄通常在后端注册为一系列回调函数。通过action关键字注册回调函数主要有两种方法。

- 模型1。如清单1第6行至第8行所示，后端使用统一的注册函数使用action关键字注册操作句柄。
- 模型2。如图1(b)第1 ~ 2行所示，动作关键字和动作句柄以边界二进制的形式连续存储在数据段中，通过函数调用表中的不同偏移量间接调用。

![](images/Pasted%20image%2020231115154448.png)

我们的见解是，可以通过分析后端函数指针的数据引用来识别操作句柄。对函数指针的数据引用表明间接调用了操作句柄。所有操作句柄都可以在后端识别，因为action关键字调用一个具有唯一常量字符串的操作句柄。为了进一步过滤误报，我们从多个候选列表中选择调用最多键值函数的函数表。key-value函数用于获取网络数据，如websGetVar。

算法1列出了我们方法的伪代码。我们首先识别边界二进制中的所有函数作为算法的输入。然后，我们根据每个函数指针的数据引用分别分析这两种情况(第4-6行)。对于模型1，函数指针的数据引用属于text段，即函数指针被用作函数参数。对于每个引用位置，我们首先找到它的所有调用者和调用点(第14-16行)。然后，我们发现调用地点的一个参数是否是表示action关键字的常量字符串(第17行)。最后，我们认为真实的注册函数调用频率最高，并收集与之对应的动作关键字和动作句柄(第9-10行)。对于模型2，数据引用属于data段或load段。我们在函数指针的引用地址附近搜索一个常量字符串，作为action关键字的候选对象(第24行)。这种方法可能会找到不用作通信接口的其他函数调用表。我们认为在正确的函数调用表中，有些函数会使用key-value函数来获取网络数据。我们使用它作为一个特性过滤器来获取真实的函数表，并收集action关键字和action句柄(第9-10行)。

![](images/Pasted%20image%2020231115154907.png)

### 3.2. 约束集合
如我们的动机示例(图1)所示，一些参数关键字在后端用于数据验证。只有通过检查后，执行才能触发更深层次的代码路径。我们将参数关键字需要满足的验证条件称为约束。UCRF首先识别action句柄中的所有参数关键字，然后执行数据流分析，收集参数关键字对应的约束。

**参数关键字**。参数关键字根据KEY-VALUE模型标记请求中对应的数据。之前的工作(Cheng et al .， 2021)观察到后端key-value函数被显式地用于解析结构化数据，如key-value模型。根据key-value函数的五个特征，可以将key-value函数定位在后端。当然，在键-值函数中用于获取数据的关键字是参数关键字。但在实际分析中，我们发现有些关键字是在使用前动态生成的，比如使用格式化字符串。为了找到所有参数关键字，我们使用key-value函数开始反向数据流分析，直到找到一个表示参数关键字的常量字符串。对于一些用“%d”格式化的关键字，我们保守地假设它们只对应一个参数关键字。

**约束**。约束是后端对参数关键字的条件比较判断，只有满足约束时才会激活相应的代码路径。收集参数关键字的约束有助于生成不受约束的种子，以达到更深层次的代码，并仅在有意义的测试空间中进行突变。我们总结了后端中三种主要约束类型的案例。

- Strcmp-like.用于条件比较的固定字符串，由类似strcmp的约束函数获得。
- Number-like.数字范围的条件比较，由类似number的约束函数获得。
- Network-like.确定字符串是否是由类似network的约束函数获得的合法网络地址

考虑到嵌入式系统的固件是用内存不安全的低级语言(Szekeres et al, 2013)实现的，例如C/C++。条件比较代码大量使用C标准库提供的库函数或基于库包装器的函数。我们可以通过分析这些库函数的语义来获得约束条件。我们使用三种类型的约束函数(如表1所示)来收集parameter关键字对数据流的约束:(1)类strcmp函数;(2)类number函数;(3)类network功能。此外，如果一个参数关键字在其数据流中没有访问任何约束函数，即在分析中没有发现该参数关键字被用于条件比较，则我们认为该参数关键字是无约束的。无约束参数关键字通常用于传输终端用户自定义的配置数据，如果后端缺乏清理，可能会导致潜在的漏洞。最后，一些固件使用供应商定义的函数在语义上等同于C标准库中的函数，并且一些函数无法根据名称在剥离的二进制文件中找到。UCRF可以很容易地扩展到第6节中讨论的这样的固件。

**代码遍历**。UCRF 跟踪从key-value函数取出参数关键字的值开始的数据流，并收集约束函数的附加约束。我们分析整个动作句柄函数和它的被调用函数直到最后。我们使用了以前工作中的数据流分析方法(Cheng et al, 2021)，这是一种基于VEX IR的细粒度数据流分析方法(Nethercote and Seward, 2007)。为了实现跨进程通信，在后端使用环境变量或非易失性随机存取存储器(NVRAM)进行数据传输。唯一键用于读取和写入相同的数据。这种通信也存在于边界二进制中，并中断数据流分析(例如，参见5.1节)。我们将基于环境变量或NVRAM写入数据的函数称为setter，将读取数据的相应函数称为getter。UCRF记录用于向setter写入数据的键，并继续从用于从同一键读取数据的getter进行数据流分析，从而使数据流分析不间断地进行。

算法2演示了UCRF的代码遍历策略。首先，我们获得CFG中入度为0的所有节点作为我们分析的开始节点(第11行)。这些节点表示调用链的起点，对于开始节点，我们获得其后续节点作为调用链(第12行)。我们确定key-value函数是否位于每个调用链中。如果是，我们从key-value函数开始的地方初始化数据流分析(第16行)。否则，我们不分析这个调用链，认为这些路径与处理网络数据无关。在数据流分析期间，我们记录了访问setter时用于写入数据的参数关键字和唯一键(第3-6行)。同时，当数据流到达约束函数时，我们将该函数和相应的约束条件记录为对应参数关键字的约束(第7-9行)。在第一个数据流分析结束时，我们确定是否有任何网络数据被写入setter(第17-21行)。如果是这样，我们使用相同的键从getter的位置初始化数据流分析，并继续收集相应参数关键字的约束(第22行)。

![](images/Pasted%20image%2020231115160531.png)

### 3.3 基于约束的模糊测试
UCRF生成结构良好且有约束的测试用例，并直接模糊路由器的后端。首先，UCRF使用前面标识的action关键字和parameter关键字来组合一个有效的格式化种子。之后，UCRF仅在约束信息引导下的有意义的测试空间中对种子进行突变，以实现有效的模糊化。最后，UCRF监视远程设备的状态，以确定在发送测试用例之后是否发生崩溃。

**种子生成**。UCRF根据后端分析的结果生成用于模糊路由器的种子。由于UCRF没有从后端二进制文件接收到的HTTP请求开始执行完整的分析，因此我们无法知道完整的HTTP请求是如何处理的。此外，不同的供应商有不同的固件定制实现。由于上述原因，UCRF首先通过观察前端发送的请求来确定在HTTP中使用哪种格式(例如，JSON和SOAP，两者都遵循KEY-VALUE模型)来传输数据。然后需要三种类型的信息来生成种子:用于请求的URL、参数关键字和用于身份验证的会话。UCRF使用action关键字作为URL来调用后端中的操作句柄。在某些情况下，路由器使用带有特定前缀的URL，而UCRF依赖于分析人员指定应该使用的URL前缀。幸运的是，我们的分析发现，小型嵌入式设备(如SOHO路由器)的url通常遵循相同的模式。分析人员可以快速地在多个URL中发现相同的模式作为URL前缀。例如，清单1中调用接口telnet的完整URL是“/goform/telnet”，其中“/goform/”是所有操作关键字的前缀。然后，UCRF为每个操作句柄使用收集到的参数关键字来生成特定于接口的种子。最后，在分析人员执行登录操作之后，UCRF自动获得访问凭证并组装结构良好且经过身份验证的种子。

**基于约束的变异器**。为了启用基于约束的模糊测试，UCRF根据参数关键字的约束确定是否改变其值。约束表示特定参数关键字的候选值范围。约束信息可用于缩小突变空间，并帮助生成有可能预测更深路径的测试用例。此外，对于类数约束和类网络约束，这意味着数据已经被清理，不需要进行额外的修改。具体来说，对于每一类约束，突变策略如下:
- 对于类strcmp数据。我们从对应于突变参数关键字的约束列表中选择一个候选值。
- 对于类似数字的数据。将收集到的约束和逆值用于组合种子。
- 对于类似网络的数据。从预定义的类网络数据中随机选择值来组装种子，例如“192.168.0.1/24”和“255.255.254.0”。
- 对于无约束的数据。使用随后描述的策略随机变异它们。

UCRF侧重于查找内存损坏和命令注入漏洞，这些漏洞可以很容易地扩展，如第6节所述。为了改变参数关键字的值，我们使用以下策略:
- 字符串长度。为了触发内存损坏漏洞，例如缓冲区溢出，我们使用一个随机字符串并修改其长度作为突变。
- 数值。我们使用随机整数作为突变。特别是，我们对特定的数字(例如，0和1)进行优先排序，以绕过可能的检查。
- 精心制作的的命令。为了触发命令注入漏洞，我们从预定义的数据库中随机选择构造良好的有效负载作为突变，这可以绕过常见的字符限制并触发基于代理的监视器。

**两阶段模糊测试**。我们观察到后端操作句柄分为两类。receiver用于从前端获取数据并对其进行处理(例如POST请求)，而returner用于响应前端请求并返回数据(例如get请求)。为了尽可能正确地测试所有操作句柄，我们在receiver之后发送一个returner并重复循环。我们使用一个简单的启发式策略来区分receiver和returner。在所标识的所有操作句柄中，使用key-value函数获取网络数据的操作句柄是receiver，而其余的操作句柄被认为是returner。我们将对固件中与web相关的文件的请求也视为returner。作为一种模糊测试方法，在无法确定HTTP请求类型的情况下，UCRF使用突变(例如，预定义的GET或POST类型)填充HTTP请求方法。

**变异器**。UCRF监视设备的状态，以检测在模糊过程中由测试用例引起的崩溃，并在监视器检测到异常状态时生成警报。我们实现了两种监测方法来监测设备的状态:(i)基于网络的监测。如果设备没有响应或响应与之前不同，则认为发生了内存崩溃。(ii)基于代理的监控，如果我们的本地代理服务器接收到测试路由器发送的特制请求，则认为发生了命令执行。当监视器发现设备在一段时间后没有响应时，UCRF将物理重启路由器，并在路由器恢复后继续模糊处理。由于UCRF直接测试物理设备，而不依赖于固件仿真，我们不能直接获得错误消息的反馈(例如，段故障)。我们使用上述两种启发式监视器来检测bug。有关故障可观测性的更多讨论，请参见第6节。

## 4.实现
UCRF的设计包括四个步骤：固件预处理、动作句柄识别、约束收集和基于约束的模糊检测。我们将UCRF实现为自动模糊测试框架。

**固件预处理**。我们从供应商的网站上下载了所有设备的固件，然后使用Binwalk(2014)解压缩固件映像。为了确定哪些二进制文件用于网络通信，即边界二进制文件，我们使用SaTc (Chen et al .， 2021)来发现边界二进制文件，作为后续分析的起点。此外，我们利用IDA Pro (IDA, 2022)来识别功能并构建控制流图(CFG)。

**操作句柄标识**。如3.1节模型2中所述，后端二进制代码中间接调用的存在会阻止正确识别某些函数。为了正确识别所有功能，我们使用内存对齐长度(4字节或8字节，取决于CPU架构长度)作为偏移量扫描整个数据段，以确定数据是否指向可执行段地址。如果是，我们将其视为一个函数，并将该函数及其后继节点添加到CFG中。最后，我们通过分析算法2中描述的数据引用来识别操作句柄，在算法2中，我们使用IDA提供的API来收集函数的数据引用信息。

**约束集合**。我们从键值函数开始数据流分析，并收集与参数关键字对应的约束。在数据流分析过程中，如果达到一个预定义的约束函数(见表1)，我们将该约束函数的名称和对应的比较条件记录为对应参数关键字的约束。基于VEX IR的数据流分析方法和键值函数识别方法是在先前工作的基础上建立的(Cheng et al .， 2021)。基于VEX中间表示，我们可以将多种体系结构的原生二进制代码转换成统一的中间表示(IR)，在此基础上实现跨体系结构的二进制分析。我们使用PyVex(2022)在Python中进行中间语言翻译。

![](images/Pasted%20image%2020231116151016.png)

**基于约束的模糊测试**。UCRF使用访问凭证对路由器的后端二进制文件(即web服务器)进行深入测试。UCRF首先使用Selenium(2022)加载一个浏览器，允许分析人员执行登录操作以获取访问凭据。同时，UCRF捕获登录请求，以确定在HTTP中使用哪种格式传输数据。目前，UCRF支持嵌入式设备中使用的常见HTTP消息格式，包括HTTP、JSON、简单对象访问协议(SOAP)和家庭网络管理协议(HNAP)，它们都遵循KEY-VALUE模型。我们使用了Boofuzz(2014)框架，并对其进行了修改，以支持种子生成、mutator和监视器。为了使突变的有效载荷能够在后端绕过简单的清理(例如，字符过滤)，我们使用预先收集的攻击有效载荷来丰富boofuzz mutator模块(Payloadsallthethings, 2018)。在模糊处理过程中，当路由器没有响应时，监控模块将对路由器进行物理重启，强制复位路由器状态。监控模块通过向智能插头发送控制命令来重新启动路由器，使其断电，然后再上电。我们使用了小米智能插头(2022)，并使用Python-miio(2022)将其暴露给Python。

## 5.评估
我们评估UCRF以回答以下研究问题:
- RQ1: UCRF能发现真实世界的漏洞吗？由UCRF生成的种子对发现漏洞有帮助吗?(5.1节)
- RQ2: UCRF在后端可以准确识别多少个操作句柄?(5.2节)
- RQ3: UCRF可以收集多少约束?不同类型的约束如何帮助发现漏洞?(5.3节)

**数据集**。为了评估UCRF，我们选择了一些来自不同厂商的热门设备进行评估，其中包括来自4家厂商的10款路由器设备(表2)，这些设备在之前的研究工作中被广泛使用(Chen et al .， 2021;Redini et al, 2020;Zhang et al .， 2019)。在实验中，我们对物理路由器进行了测试，因为UCRF不依赖固件模拟来获取运行时信息来指导模糊测试。

![](images/Pasted%20image%2020231116151756.png)

**实验设置**。我们购买了这些路由器设备(见图4)，并将它们连接到子网内。为了获得正确的会话进行模糊测试，我们手动设置了路由器的密码并指定了认证方法。最后，我们在一台运行Ubuntu 20.04的40核、256 GB内存的机器上部署了UCRF。

![](images/Pasted%20image%2020231116151814.png)

### 5.1. 漏洞识别
我们使用10台安装最新版本固件的设备对UCRF进行了评估。如表3所示，UCRF在7台设备上共发现41个0天漏洞。我们负责任地向供应商报告了这些漏洞，并得到了证实。其中，24个漏洞是缓冲区溢出漏洞，另外17个是命令注入漏洞。这些漏洞可能导致设备崩溃，从而导致DDoS攻击或远程命令执行。总体而言，这些漏洞共被分配了38个CVE ID、2个CNVD ID和1个PSV ID，分配的ID如表7所示。

为了探索基于约束的UCRF生成的种子的有效性，我们根据漏洞警报对固件进行人工逆向工程，并分析漏洞触发的条件。表3中的最后两列说明，为了触发这些漏洞，需要对一个或多个参数关键字进行并发突变。其中，当两个或多个参数关键字值在一个测试用例中发生突变时，触发了20个漏洞，并且至少有一个值基于约束信息。其余21个漏洞仅在一个值发生突变时触发，不需要约束信息。注意，UCRF可以通过限制约束域的突变空间来帮助发现漏洞，从而提高模糊化效率。

![](images/Pasted%20image%2020231116152552.png)

**比较**。SRFuzzer (Zhang et al, 2019)和ESRFuzzer (Zhang et al, 2021)是最先进的SOHO路由器模糊测试工具。SRFuzzer (Zhang et al .， 2019)通过模拟浏览器的提交行为生成测试用例，并捕获前端发送的请求作为种子。SRFuzzer重复填充网页10次，分析变量属性标签请求，包括固定字符串、数字和可变字符串。SRFuzzer将固定字符串和数字视为不变量，可用于在后端通过条件检查。然而，后端代码的严格输入检查使得模糊测试效率低下。UCRF在后端收集约束，以获得更准确的语义信息，以达到深度路径。ESRFuzzer (Zhang et al, 2021)使用D-CONF模式增强了SRFuzzer，该模式利用部分路由器提供的NVRAM配置操作，并从后端从NVRAM键值对读取数据的位置开始模糊测试。单个NVRAM键值对代表一个参数关键字及其对应的值。D-CONF模式可以帮助ESRFuzzer在忽略部分后端数据验证的前提下更深入地测试代码。

为了将我们的方法与SRFuzzer和ESRFuzzer进行比较，我们联系了作者，但未能获得他们的工具。我们从SRFuzzer和ESRFuzzer的数据集中选择了10个实验设备中的5个，在相同的固件版本上进行实验。没有选择设备进行评估，原因如下:(1)Mercury Mer450和ASUS RT-AC1200，供应商已经下架，我们无法获得。(2) Netgear Orbi和Netgear Insight，总价超过600美元，对我们来说价格比较贵。(3)对于TP-Link TL-WVR900G，设备的后端web服务器是用Lua编程的，UCRF目前只适用于内存不安全的低级编程语言(例如，C/ c++)，目的是发现内存损坏和命令注入漏洞。我们将UCRF运行了40小时，与SRFuzzer和ESRFuzzer论文中描述的时间相同。由于一些漏洞细节不是公开可用的，我们通过比较发现的漏洞的数量来说明UCRF的漏洞发现能力。

如表4所示，UCRF共发现了109个漏洞，SRFuzzer发现了58个漏洞，ESRFuzzer发现了72个漏洞。其中，与SRFuzzer和ESRFuzzer相比，UCRF在大多数设备上发现的漏洞更多，除了R7800, UCRF在R7800上发现的命令执行漏洞较少。我们进一步的研究表明，这可能是由于设备的内部保护机制导致UCRF没有检测到漏洞，我们在第6节中讨论了这种情况。我们向供应商报告了这些漏洞;幸运的是，它们中的大多数已经在较新的固件版本中修复了。其中，在R8500和G3中发现的漏洞可以在最新固件版本中进行验证，并被厂商确认为零日漏洞。一共分配了12个CVE ID、2个CNVD ID和1个PSV ID。SRFuzzer和ESRFuzzer支持多种类型的漏洞发现，包括跨站脚本(XSS)和信息泄露。目前，UCRF被设计用来发现内存不安全的后端漏洞，包括内存损坏和命令注入漏洞，并且可以像第6节中讨论的那样进行扩展。

![](images/Pasted%20image%2020231116160203.png)

UCRF通过了解后端代码的语义发现了更多的漏洞。相比之下，SRFuzzer和ESRFuzzer对后端代码的语义不敏感，允许模糊测试保持在较浅的级别。ESRFuzzer的D-CONF模式允许对代码深处的多个参数关键字进行独立模糊测试，但忽略先前路径上的潜在数据验证可能导致误报。此外，在漏洞复制过程中，我们发现由于前端交互逻辑复杂，基于前端生成有效请求需要大量的手工工作，并且前端对数据进行严格的检查。而UCRF基于后端信息生成种子，可以避免分析复杂的前端。

**案例研究：CVE-2022-29765**。清单2显示了UCRF在Tenda G3中发现的0天漏洞CVE-2022-29765，为了更清晰，我们对其进行了简化。首先，UCRF通过action句柄识别找到动作关键字setQos和相应的句柄函数formQOSSet，并进行后续针对接口的分析(第1行)。在函数formQOSSet中，我们可以通过键值函数websGetVar找到三个参数关键字，包括qospicy、qosDefaultRuleEn和qosConnecttedNum(第4-6行)。UCRF利用这些动作和参数关键字构建结构良好的种子，并通过进一步分析生成高效、深入的测试用例。此外，UCRF通过从参数关键字的位置初始化数据流分析来收集特定于字段的约束。例如，我们可以确定qosppolicy属于具有有效候选者“user”、“auto”和“disable”的类正则约束(第15-21行)。最后，当qosPolicy等于“user”并且qosDefaultRuleEn等于“true”时，可以通过改变不受约束的变量connectLimit来触发第37行的堆栈溢出漏洞。此外，UCRF的代码遍历算法可以恢复基于环境变量或NVRAM读写的数据流分析。例如，通过“bandwidth.dft”写入第10行中的环境变量。在第28行读到。UCRF可以收集到参数关键字qosDefaultRuleEn对应的约束为类数字且等于1。此外，UCRF的轻量级数据流分析可以快速分析深度调用链，而不会产生路径爆炸。

![](images/Pasted%20image%2020231116160610.png)

### 5.2 操作句柄标识
由于没有oracle可以突出显示后端所有的通信接口，我们尽最大努力手动反向工程固件，以验证后端操作句柄的结果。我们考虑了每个设备的操作句柄的特征，并尝试构建请求来触发它们，作为识别所有操作句柄的一种方式。我们也承认，我们的分析不能排除假阴性，因为分析真实世界的固件是困难的。

表5显示UCRF可以在所有设备中找到90%以上的操作句柄。对于六个设备，UCRF可以发现所有操作句柄。我们在R8500中发现了两个函数调用表，UCRF正确地识别了用于注册操作句柄的函数调用表。对于A720R和X5000R，这些函数调用表中只有一个存在并且被UCRF正确识别。对于设备R7800和WNDR4500，边界二进制中有10多个不同的函数调用表。我们尽了最大努力确定了其中两个用于注册操作句柄的函数表。对于使用模型2注册动作句柄的其余5个设备(参见3.1节)，其中边界二进制中存在多个类似的注册函数。UCRF可以精确地识别用于注册操作句柄的唯一函数。在AC9和AX3的情况下，UCRF识别了由相同注册函数注册的函数作为操作句柄，但生成了误报。我们对固件进行了反向工程，发现误报来自遗留代码。厂商保留了函数项，但删除了相应的函数代码，导致无法触发操作句柄。处理步骤nAct列显示了UCRF找到的不可见的前端操作句柄。在分析之后，它们中的大多数都是遗留接口，也就是说，开发人员只从前端删除了它们，而没有从后端删除。其中，我们发现了一些可能导致漏洞的接口，我们将具体的分析留给了以后的工作。最后，在实际分析过程中，我们发现，由于供应商对固件的自定义实现，为8个设备构建正确的URL(用†表示)依赖于分析师在action关键字之前指定特定的前缀，例如“/goform/”。幸运的是，每个设备中的url只包含一个特殊的前缀，分析人员可以在不超过3分钟的时间内根据多个url的相同模式识别出该前缀并通知UCRF。

![](images/Pasted%20image%2020231116161208.png)

以前的工作SaTC (Chen et al, 2021)可以根据来自前端的信息识别后端操作句柄。SaTC观察到，如果在前端文件(JavaScript/HTML等)中识别的关键字和函数指针作为参数传递给函数，则关键字用作操作关键字，函数指针是操作句柄。由于前端的异构性，如多厂商代码风格和JavaScript代码的动态特性，在前端识别动作关键字的方法可能会产生误报结果。同时，由于没有调用注册函数，SaTC无法识别Model 2。我们将SaTC的结果显示在表5中，UCRF的动作柄识别方法比SaTC更准确，而且不需要花费过多的时间。

### 5.3 约束
**约束集合**。为了通过UCRF的静态分析来评估后端约束的集合，我们在10个固件上运行UCRF。如表6所示，平均有36.41%的参数关键字可以找到相关约束条件，说明我们的观察结果得到了证明。这些约束可以帮助种子缩小突变空间，并达到受检查保护的更深层次的代码。具体来说，UCRF为TOTOLINK A720R找到了71.53%的约束参数关键字。我们手动检查固件并确定约束是有效的，后端广泛使用函数atoi将网络数据转换为数字。对于Netgear R7800, UCRF只发现了18.13%的约束参数关键字。我们的手工分析显示约束不存在于边界二进制，但在其他边缘二进制。我们将在第6节讨论UCRF的不完善之处。固件分析的平均时间为54.92 s，表明UCRF的静态分析是轻量级的和实用的。

![](images/Pasted%20image%2020231116161648.png)

UCRF为每个接口生成特定的种子，不同动作句柄中的同名参数关键字可能具有不同的角色和约束。重复数据删除后的约束如表8所示。对于具有相同名称的参数关键字，将合并约束。结果与未合并的结果相似。

![](images/Pasted%20image%2020231116161706.png)

**约束有效性**。为了验证不同约束类型的UCRF对漏洞发现的有用性，我们使用单个约束类型来评估UCRF在40小时内发现的崩溃数量。我们使用以下模糊测试方案作为基准。
- UCRF.启用所有三种约束类型
- UCRF-str. 只使用类strcmp约束
- UCRF-num. 只使用类似number的约束
- UCRF-net. 只使用类似network的约束
- boofuzz. 我们使用正确的action关键字和parameter关键字配置Boofuzz(2014)。值得注意的是，UCRF是基于boofuzz实现的，通过正确的配置，我们可以在不使用约束信息的情况下将boofuzz视为UCRF。

我们对五个设备进行了实验，这些设备之前发现了更多漏洞，使结果更直接。此外，我们跳过了在检测到崩溃后当前正在发生突变的参数关键字的后续突变。我们手动记录了触发崩溃的poc，并执行了反向工程分析，以确保我们获得了唯一崩溃的数量。

图3显示了触发崩溃的五种模糊方案的效率。UCRF优于其他四种模式，正如我们前面提到的，为了访问更深层次的路径，后端中的三种约束类型一起起作用。在其他四种策略中，UCRF-str在有限的时间内发现了最多的漏洞。考虑到固件的逆向工程分析，我们认为这是因为类似约束的约束经常用于早期的条件比较。UCRF-num使用的类数字约束可以帮助绕过对数字类的条件检查。但是，类字符串数据的突变空间要比类数字数据大得多。UCRF-num很难生成符合条件的字符串类约束，使测试停留在一个肤浅的层次上。对于UCRF-net，效率类似于boofuzz，因为这样的约束通常位于深度路径中，如果没有条件比较的信息，很难到达。此外，仅使用单一约束信息的三种方案的效率与提取的约束数量成正比(见表6)，这表明约束信息有助于缩小突变空间。

![](images/Pasted%20image%2020231116162042.png)

## 6. 讨论
**范围限制**。UCRF旨在有效地测试SOHO路由器中的脆弱web服务器。从技术上讲，UCRF可以针对任何具有客户机-服务器模式的嵌入式设备的web服务器工作。我们计划扩展UCRF以支持其他嵌入式设备，如摄像头、可编程逻辑控制器(PLC)等。我们对来自4家厂商的10台路由器进行了评估，证明了UCRF的可扩展性。目前，UCRF仅侧重于分析基于linux的固件，依赖符号表进行约束收集。虽然大多数路由器固件符合上述标准，但UCRF无法用于某些blob或剥离固件。可以使用函数语义分析(Redini et al, 2020)或二元相似度匹配(Yu et al, 2020)来发现约束函数，将UCRF与这些方法集成是一种可行的解决方案。

由于不同的供应商有不同的自定义固件实现，我们保留在其他设备上使用不同数据处理模型的可能性。出于同样的原因，在某些情况下，与实际使用的URL相比，我们从后端收集的操作关键字缺少特定的前缀(例如，“/goform/”)。分析人员可以根据多个URL的相同模式快速确定UCRF中应该使用的URL前缀。虽然可以通过分析前端直接获得完整的URL，但由于前端代码风格的多样性，这种方法可能会引入误报(例如，SaTC Chen等人，2021，我们已在表5中显示)。或者，需要引入手工工作来处理复杂的前端交互逻辑(例如，SRFuzzer Zhang等人，2019)。此外，在某些设备的请求中可能会对参数进行编码(例如MD5或base64)，此时需要分析人员对请求进行分析并确定编码类型，然后在突变模块的末尾指定对突变值进行哪种编码方式。

**约束的粒度**。UCRF执行轻量级数据流分析来收集约束，而不是符号执行(例如，angr Shoshitaishvili等人，2016)。因为在我们的实际分析中，对于使用KEY-VALUE模型传输的数据，后端执行一个或多个键的粗粒度比较(例如，使用strcmp进行字符比较)，而不是字节粒度的精确验证。这允许我们忽略复杂的和动态的约束，比如内存和函数引用的比较。我们的实验表明，UCRF可以有效地收集许多参数关键字的约束(参见5.3节)。另一方面，符号执行在遇到深度调用栈时面临路径爆炸问题。相比之下，数据流分析使我们能够遍历更深的路径并收集尽可能多的约束。

**漏洞类型**。UCRF目前的目标是发现两种类型的后端漏洞，内存损坏和命令注入，因为收集的约束对于发现这两种典型的污染式漏洞类型是有效的。SRFuzzer (Zhang et al .， 2019)先前的工作还支持发现跨站点脚本(XSS)和信息泄露漏洞。为了检测XSS，我们可以修改UCRF的mutator模块来发现此类漏洞，我们的基于代理的监视器可以支持检测此类漏洞。对于信息泄露的检测，通常需要手动验证来确定漏洞的发生，我们将在未来通过对返回消息的进一步分析来支持此类漏洞。UCRF发现了一些不可见的前端接口，其中一些可能是脆弱的，我们将具体的分析留给以后的工作。KARONTE (Redini et al, 2020)观察到，多二进制交互可能导致漏洞，其中一些数据流通过边界二进制转发给其他二进制进行处理。UCRF可以通过直接模糊边界二进制来发现此类漏洞，但目前，我们没有考虑其他二进制中的数据流约束，并将其留给未来的工作。

**故障可观测性**。UCRF通过观察网络行为来确定内存崩溃漏洞的发生。然而，正如Muench等人(2018)所讨论的那样，并非所有错误都可以在嵌入式设备上观察到。由于缺乏桌面系统中常见的保护机制(智能但有缺陷，2020;Thompson and Zatko, 2018;Yu et al, 2022)，当应用程序崩溃时，嵌入式设备不能提供错误消息(例如，段故障)和反馈。在基础分析中，我们发现web服务器的错误处理代码或嵌入式设备的自我保护机制(例如看门狗)通常通过重新启动应用程序或操作系统来消除异常，从而使我们有机会通过观察网络行为来确定崩溃的发生。本文根据UCRF检测到的崩溃进行逆向工程，证明了UCRF不存在假阳性。然而，在某些情况下，仅通过观察网络行为可能会出现假阴性。例如，SRFuzzer通过物理设备的检测检测到8个命令执行漏洞，ESRFuzzer在D-CONF模式下通过相同的机制发现了3个，而UCRF通过观察网络行为只发现了2个。使用QEMU (Bellard, 2005)来模拟异构固件并捕获异常，或者使用物理设备的仪器(Zhang等人，2019)，都是检测静默内存损坏的可能方法。我们计划在未来使用这些方法来增强UCRF。

## 7. 相关工作
**模糊嵌入式系统**。模糊测试是一种流行的漏洞发现技术。之前的一些研究工作集中在反馈驱动的模糊方法上(American Fuzzy Lop, 2014;Lee et al, 2021;Li et al .， 2017;Rawat et al, 2017;Stephens et al .， 2016;Wang et al .， 2017)获取运行时信息(如代码覆盖率)来指导种子生成，并赋予可以触发更深路径的种子更高的权重。没有仿真支持的嵌入式设备无法本地执行固件。FIRMADYNE (Chen et al .， 2016)和FirmAE (Kim et al .， 2020)旨在提高模拟成功率并进行大规模动态分析。Zheng等人(2019b)和FirmFuzz (Srivastava等人，2019)集成了一个基于固件仿真的漏洞发现模糊框架。为了提高固件仿真的吞吐量，Firm-AFL (Zheng et al .， 2019a)提出了增强过程仿真，方法是在用户模式仿真器中运行固件程序，并在程序运行时将系统调用重定向到系统模式仿真器，以满足特殊的硬件依赖。EQUAFL (Zheng et al .， 2022)使用增强的用户模式仿真来执行固件程序，从而避免了系统模式仿真的巨大开销。为了在用户模式仿真中成功执行程序，EQUAFL首先使用全系统仿真运行程序以收集有效信息，然后迁移所需的环境以进行用户模式仿真。μAFL (Li et al, 2022)利用嵌入式设备上的调试接口从设备收集运行时信息，实现基于代码覆盖率的反馈驱动模糊测试。固件仿真通常可以为模糊器提供有关程序的运行时信息，在此基础上可以采用基于反馈的高级模糊测试方法。然而，这些方法大多使用随机字符串或HTTP消息作为输入，没有考虑嵌入式设备中网络通信的特点。

为了避免固件仿真中的问题，一些研究针对物理设备进行测试。SRFuzzer (Zhang et al .， 2019)是用于模糊SOHO路由器的最先进工具，它模拟浏览器的提交行为，并捕获发送到后端的请求作为种子。SRFuzzer分析请求以找到不变量，包括固定字符串和数字，用于通过后端条件检查。然而，后端代码的严格输入检查使得模糊测试效率低下。请注意，UCRF从后端收集所有潜在约束的列表，而不仅仅是不变量，并且UCRF基于后端生成种子，以避免来自前端生成的种子的过度约束。ESRFuzzer (Zhang et al, 2021)通过DCONF模式对SRFuzzer进行扩展，该模式使用部分路由器提供的NVRAM配置操作(例如，“备份和恢复配置”功能)，并使用与NVRAM相关的键值对测试后端。在D-CONF模式下，ESRFuzzer可以通过改变值来直接模糊单个键值对。D-CONF模式可以帮助ESRFuzzer在忽略部分后端数据验证的前提下更深入地测试代码。然而，并不是所有的键值对都与NVRAM操作相关，忽略与NVRAM无关的键值对会阻碍后端漏洞的发现。SRFuzzer和ESRFuzzer实现了一个基于信号的监视器，当有权限在真实设备内部署监视器时，通过常见信号(例如SIGSEGV和SIGABRT)获得更准确的进程内信息，从而捕获静默内存崩溃。RPFuzzer (Wang et al .， 2013)的目标是模糊路由器协议，如SNMP。Snipuzz (Feng et al, 2021)使用基于消息片段的突变策略对物联网设备进行测试，根据响应推断用于突变的消息片段，从而缩小探测信息的搜索空间。IoTInfer (Shu and Yan, 2022)利用基于FSM(有限状态机)推理的启发式方法来指导物联网网络协议(包括蓝牙和Telnet协议)的黑盒模糊测试。IoTFuzzer (Chen等人，2018)和DIANE (Redini等人，2021)利用物联网设备的配套应用程序生成结构良好的测试用例。然而，这样的测试用例忽略了后端潜在的约束。此外，UCRF在后端收集约束信息，以帮助测试用例到达更深的路径。

**二进制静态分析**。二进制静态分析技术是发现嵌入式系统漏洞的另一种方法(Davidson et al .， 2013;Redini et al, 2017;Shoshitaishvili et al, 2015)。Cheng等(2021)提出了一种在SOHO路由器固件中自动推断污染源的方法，该方法总结了KEYVALUE模型中用于解析结构化数据的函数的特点，并使用数据流分析来识别污染源等功能。UCRF在此基础上进一步进行数据流分析，收集网络数据处理中的约束条件，用于指导模糊测试。SaTC (Chen et al .， 2021)观察到变量名在前端文件和后端函数之间通常是共享的，使用在前端找到的关键字可以在后端定位动作句柄和输入条目。但是，不准确的前端关键字可能导致操作句柄标识的误报和误报。KARONTE (Redini et al, 2020)观察到多二进制交互中的数据流可能导致漏洞，首先构建二进制依赖图，并使用符号执行进行污染传播来发现漏洞。DTaint (Cheng等人，2018)是第一个检测固件二进制文件中污染式漏洞的工作，它通过生成上下文敏感和过程间数据流来检测漏洞。UCRF可以对嵌入式设备中的web服务器相关漏洞进行验证，我们相信UCRF可以作为静态分析工具的补充。

## 8. 结论
在本文中，我们提出了针对SOHO路由器模糊测试的UCRF，它通过对后端二进制文件的静态分析生成高质量的测试用例，而不需要固件仿真。为了生成结构良好的种子，UCRF识别后端所有的通信接口，以避免丢失不可见的前端接口。然后，UCRF利用静态数据流分析来提取每个动作句柄的约束信息，仅在基于约束信息的有意义的测试空间中生成高效、深入的测试用例。我们实现了UCRF的原型系统，并在4家知名厂商的10台真实路由器上进行了评估，共分配了38个CVE ID、2个CNVD ID和1个PSV ID。
