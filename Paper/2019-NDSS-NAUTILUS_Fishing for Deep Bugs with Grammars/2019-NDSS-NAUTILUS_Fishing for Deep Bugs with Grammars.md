---
title: 2019-NDSS-NAUTILUS_Fishing for Deep Bugs with Grammars
date: 2024/01/09
categories:
  - 论文
tags:
  - 论文翻译
---
# 2019-NDSS-NAUTILUS_Fishing for Deep Bugs with Grammars
## 摘要
模糊测试是一种众所周知的有效识别程序bug的方法。不幸的是，当需要高度结构化输入(如解释器)的程序被模糊化时，许多模糊化方法很难通过语法检查:解释器通常分多个阶段处理输入，首先检查语法正确性，然后检查语义正确性。只有当两个检查都通过时，解释后的代码才会被执行。这可以防止模糊器执行“更深层次”的代码——因此可能更有趣。通常，导致在目标程序中执行不同功能的两个有效输入需要太多的突变，简单的基于突变的模糊器无法发现:进行像位翻转这样的小更改通常只会导致在解析引擎中执行错误路径。所谓的语法模糊器能够通过使用ContextFree Grammars来通过语法检查。反馈可以显著提高模糊引擎的效率，并且通常用于不使用语法的最先进的突变模糊器。然而，当前的语法模糊器没有利用代码覆盖率，也就是说，它们不知道是否有任何输入触发了新的功能。

在本文中，我们提出了NAUTILUS，这是一种通过结合使用语法和使用代码覆盖反馈来有效模糊需要高度结构化输入的程序的方法。这允许我们重新组合感兴趣的输入的各个方面，并增加任何生成的输入在语法和语义上正确的可能性。我们实现了一个概念验证模糊器，并在多个目标上进行了测试，包括ChakraCore (Microsoft Edge的JavaScript引擎)、PHP、mruby和Lua。NAUTILUS在所有目标中发现了多个漏洞:mruby中有7个，PHP中有3个，ChakraCore中有2个，Lua中有1个。报告这些漏洞将获得2600美元的奖励，并分配6个cve。我们的实验表明，在测量代码覆盖率时，结合上下文无关的语法和反馈驱动的模糊测试明显优于AFL等最先进的方法，其数量级和语法模糊测试的性能都超过了两倍以上。

## 1.引言
软件控制着现代生活越来越多的方面。因此，软件测试的重要性也在以类似的速度增长。人工编写的测试(例如，单元测试)是软件开发生命周期的重要组成部分;然而，由于各种原因，许多软件项目没有或只有有限的测试套件。即使对于具有全面测试套件的项目，测试也通常围绕预期的输入来测试代码的预期功能。然而，意外输入是用于利用应用程序预期功能的主要攻击向量之一，而自动化软件测试擅长于发现具有意外特征的输入，这些特征可以被利用来触发漏洞。

自动测试程序的一种流行方法是模糊测试，即通过生成输入并将其提供给程序来自动测试程序，同时监视崩溃和其他意外情况。近年来，开发了许多不同的模糊器，涵盖了各种方法和目标。通用fuzzers[18]通常依赖于低级的二进制转换来生成新的输入，因此，它们很难处理只接受高度结构化文件的程序，例如脚本语言的解释器。二进制转换生成的输入很难通过最初的词法和语法分析[36]，并到达在这些检查之后执行的代码，即深度代码。

这个问题的一个直观的解决方案是使用(与上下文无关的)语法来生成语法正确的输入。以前的作品[5]、[17]、[36]、[47]使用了这种方法，但它们没有利用插桩反馈，这使得模糊器能够区分到达代码库新部分的输入和没有到达新代码的输入。

利用反馈可以极大地提高通用模糊器的性能。最流行的面向反馈的fuzzers之一是AFL[19]，它被用于识别数百个应用程序和工具中的错误。使用代码覆盖率反馈，AFL能够智能地结合有趣的输入来探索更深入的代码，如果没有反馈，这将花费不合理的时间。相反，AFL在处理结构复杂的文件格式时遇到困难，因为它针对二进制格式进行了优化，并且不支持语法。注意，可以为AFL提供一个字符串列表，它将尝试使用该列表来生成输入。但是，此列表不支持任何类型的类语法语义。

大多数覆盖率驱动的模糊测试，包括AFL，都需要一个输入语料库，作为开始模糊测试过程的基础。高质量的语料库对模糊器的性能和有效性至关重要:语料库使用的任何代码路径都不必由模糊器发现，并且可以从一开始就与其他输入组合在一起。获得如此高质量的语料库并非易事:如果目标应用程序所接受的语言被广泛使用，一种方法是从Web[49]或公共代码库中抓取公开可用的示例。然而，这些示例很可能偏向于语法中非常常用的部分，这些部分使用了目标应用程序中经过良好测试的部分。当然，安全研究人员通常希望测试很少使用或最近引入的功能，这些功能更有可能导致目标应用程序中的错误。获取语料库来测试这些特性显然更加困难，而手工编写示例的成本也非常高。

**目标和贡献**。在本文中，我们提出了一种模糊测试方法的设计和实现，该方法结合了基于描述的输入生成和基于反馈的模糊测试，以发现应用程序语义深处的错误，即在词法和语法检查之后发生的错误。这个概念的原型实现称为NAUTILUS，它不需要语料库，只需要应用程序的源代码和为其生成输入的语法。人们可以使用公开可用的语法开始对NAUTILUS进行模糊测试[6]。然后，模糊测试过程可以通过删除语法中无趣的部分并添加有关语言的额外信息来进行微调，例如，通过合并从语言文档中获取的函数名和参数类型，这很容易实现自动化。此外，NAUTILUS允许用户使用额外的脚本扩展语法。这些脚本允许NAUTILUS生成任何可确定的输入语言，以进一步提高其生成语义正确输入的能力。

然而，NAUTILUS不只是产生有趣的初始输入。模糊过程本身也通过对输入执行高级语义转换来利用语法，例如，将程序中的一个表达式交换为另一个表达式。通过将这些突变与覆盖反馈相结合，NAUTILUS可以创建一个语义上有趣且多样化的输入语料库，并以一种极大地增加发现语法和语义上有效的新输入的可能性的方式重新组合它们。正如我们在第六节中所评估的那样，这两个优点使NAUTILUS比最先进的模糊器具有显著的优势。此外，NAUTILUS能够在其测试的所有目标中发现新漏洞:mruby1中有7个，PHP中有3个，Lua中有1个，ChakraCore中有2个。

综上所述，我们在本文中的贡献是:

- 我们介绍并评估了NAUTILUS，这是第一个将基于语法的输入生成与反馈定向模糊相结合的模糊器。NAUTILUS显著提高了对需要高度结构化输入的目标进行模糊测试的效率和有效性，而不需要任何语料库。为了增强表达能力，NAUTILUS支持图灵完备脚本作为输入语言描述语法的扩展。这可以用于为复杂的、非上下文无关的输入语言创建描述。
- 我们描述和评估了几种基于语法的突变、最小化和生成技术。通过结合覆盖反馈和基于语法的拼接，NAUTILUS能够生成语法和语义正确的程序，优于传统的纯分代模糊器，后者花费大量时间生成和测试语义无效的输入。
- 我们在多个广泛使用的软件项目中发现并报告了几个安全漏洞，而在我们的评估中没有其他fuzzer发现这些漏洞。

为了促进对这一主题的研究，我们在https://github.com/RUB-SysSec/nautilus上发布了我们的fuzzer。

## 2.背景
### B.上下文无关语法
应用程序通常需要高度结构化的输入，这是传统的基于突变的模糊器无法轻易提供的。上下文无关语法（CFG）非常适合指定高度结构化的输入语言。这里我们给出了cfg的一个简短定义，并介绍了如何使用它们来描述输入语言。直观地说，CFG是一组生成规则，其形式为“某些变量X(非终结符号)可以被下面的字符串(终结符号)和变量数组所替换”。另外，一个特殊的start non-terminal指定从哪里开始应用这些规则。CFG描述的输入语言是所有字符串的集合，这些字符串可以通过应用任意数量的规则派生，直到不再出现非终结符。

更正式地说，CFG被定义为一个元组:G = (N;T;R;S):

![](2019-NDSS-NAUTILUS_Fishing%20for%20Deep%20Bugs%20with%20Grammars/image-20240109203643100.png)

由于每条规则的左侧恰好包含一个非终结符，因此可能的派生只依赖于一个非终结符而不依赖上下文，因此这些语法被称为上下文无关。

要派生字符串，必须对起始符号s应用匹配的生成规则，即左手边各有一个非终结符的生成规则。只要该规则的右手边包含一个非终结符，就执行另一个派生步骤。对于每一步，一个非终结符被匹配该非终结符的规则的右侧所替换。

示例II.1显示了给定语法G1的可能的输入生成。
![](2019-NDSS-NAUTILUS_Fishing%20for%20Deep%20Bugs%20with%20Grammars/image-20240109203740612.png)

![](2019-NDSS-NAUTILUS_Fishing%20for%20Deep%20Bugs%20with%20Grammars/image-20240109203751411.png)
![](2019-NDSS-NAUTILUS_Fishing%20for%20Deep%20Bugs%20with%20Grammars/image-20240109203928024.png)

CFG生成的每个字符串都可以用它的派生树表示。一个CFG G的导数树t是这样一棵树，它的顶点要么用非终结标记，要么用终结标记。t的根被标记为起始符号，所有的终端顶点被标记为来自G[52]的终端。NAUTILUS主要操作这些派生树，而不是我们称之为未解析字符串的树的字符串表示。派生树是NAUTILUS对其应用结构突变的输入的内部表示。然而，由于许多公共语言结构不是与上下文无关的(例如，校验和，或者生成适当的XML，因为开始和结束标记需要包含相同的标识符)，我们通过允许使用额外的脚本来转换输入来扩展cfg。

由于生产规则集必须包含所有(相关的)非终端和终端，因此在下面我们仅通过其生产规则和开始符号来定义cfg。为了区分非终结符和终结符，我们对非终结符使用大写名称。

## 3.挑战
设计一个模糊器需要彻底的考虑，以最大限度地减少用户的努力，最大限度地提高模糊器的有效性。特别是，我们确定了四个值得期待的关键方面:

C1:生成语法和语义有效的输入。生成的输入需要通过目标应用程序的语法和语义检查，才能进入下一阶段的计算。语法和语义有效输入的子集通常比所有可能输入的集合要小得多[49]。因此，对于fuzzers来说，通常很难“深入”并发现由输入验证保护的应用程序逻辑中的错误。此外，在许多情况下，输入语言不能通过更简单的形式化(如CFGs)来建模。

C2:独立于语料库。当前的模糊器通常需要输入的初始语料库，即一组种子文件。即使使用知名软件(通常有语料库)，获取针对应用程序中新的和模糊部分的语料库也是困难的。为内部或未发布的软件获取语料库就更难了。因此，不需要使用(适当的)语料库来模糊应用程序。然而，许多软件项目都有一个允许输入(或语法)的规范，可以用来代替。此外，试图将种子语料库与输入规范相结合的技术通常需要限制其输入语言以启用解析，因此，在使用输入规范时降低了种子语料库的有用性。

C3:目标功能的高覆盖率。在目标应用程序中实现高覆盖率是找到更多错误的理想选择。这主要涉及两个方面:(1)传递输入处理，(2)转向分析，探索新的路径。

C4:性能好。快速测试周期意味着每个模糊测试窗口有大量的测试输入，这是提高模糊测试器有效性的关键方面之一。为了保证高的执行速度，输入需要小，生成方法需要快。

我们在设计NAUTILUS时考虑到了这些挑战:仅语法的输入派生处理C1和C2，而我们使用反馈驱动的输入生成来解决C3，并控制输入派生长度以及最小化感兴趣的输入来处理C4。在下一节中，我们将解释这些高级概念的设计。

## 4.NAUTILUS的设计
该方法的高级概述如图1所示。

![](2019-NDSS-NAUTILUS_Fishing%20for%20Deep%20Bugs%20with%20Grammars/image-20240109204257913.png)

使用NAUTILUS所需的第一步是使用我们的工具1编译目标应用程序的源代码，以便在运行时提供覆盖率信息的反馈。然后，启动fuzzer进程本身，解析用户提供的语法2，然后从头生成少量(1000)随机初始输入3，并将它们传递给调度器。然后，NAUTILUS通过执行插桩的二进制文件4来测试新生成的输入是否触发任何新的覆盖。如果是，NAUTILUS使用语法将其最小化，并将其添加到队列中。根据是否还可以探索新的路径，调度程序将触发现有输入6的突变或派生新输入7。对于队列中的输入，将应用基于语法的更改。突变方法包括一些技术，比如用新生成的子树替换子树，或者将发现目标应用程序不同有趣特征的子树组合在一起。突变后，输入被添加到队列8中，并在随后的分析运行中使用。这种架构允许我们结合语法模糊测试和反馈模糊测试的优势，将现有的有趣输入重新组合为语义上更有趣的输入。在下面，我们更详细地解释了产生过程、最小化过程和突变过程。





## 参考链接

