# Efficient Greybox Fuzzing of Applications in Linux-Based IoT Devices via Enhanced User-Mode Emulation

![](images/Pasted%20image%2020230321210045.png)

## 摘要
灰盒模糊已经成为最有效的漏洞发现技术之一。然而，灰盒模糊技术不能直接应用于物联网设备中的应用。主要原因是执行这些应用程序高度依赖于特定的系统环境和硬件。为了在基于linux的IoT设备中执行应用程序，大多数现有的fuzzing技术都使用了全系统仿真，以最大限度地提高兼容性。但是，与用户模式仿真相比，全系统仿真的开销很大。因此，以前的一些工作，如FirmAFL，提出将全系统仿真和用户模式仿真结合起来，以加快模糊过程。尽管尝试将应用程序转换为用户模式模拟，但没有现有技术支持在用户模式模拟中完全执行这些应用程序。

为了解决这个问题，我们提出EQUAFL，它可以自动设置执行环境，在用户模式模拟下执行嵌入式应用程序。EQUAFL首先在全系统模拟下执行应用程序，并观察在用户模式模拟期间程序可能卡住甚至崩溃的关键点。使用观察到的信息，EQUAFL可以迁移用户模式仿真所需的环境。然后，EQUAFL使用增强的用户模式仿真来重放网络的系统调用和资源管理行为，以满足嵌入式应用程序在执行期间的需求。

我们在来自不同系列物联网设备的70个网络应用上评估EQUAFL。结果表明，EQUAFL的性能优于最先进的模糊效率(平均比AFL-QEMU快26倍，比FirmAFL快14倍)。我们还从测试的固件映像中发现了10个漏洞，包括6个cve。

关键词：灰盒模糊测试，基于linux的物联网设备，增强的用户模式仿真

## 1.引言
随着物联网(IoT)的快速发展，数十亿物联网设备连接到互联网。与传统IT厂商相比，物联网设备厂商更注重系统功能，而不是系统安全性。因此，物联网系统中运行的应用程序存在各种未知的漏洞，为攻击者提供了大量的攻击面。例如，2016年底，Mirai病毒被开发出来，利用基于linux的物联网设备的漏洞，对美国东海岸发起了大规模DDoS攻击。这一事件对网络空间安全产生了重大影响。总之，安全研究人员需要尽快找到基于linux的物联网设备内部的漏洞，特别是那些作为物联网设备和互联网之间的大门的应用程序。

灰盒模糊是一种实用的测试技术，用于发现软件中的漏洞。灰盒模糊的基本思想是使用轻量级的程序插桩来收集被测程序(PUT)的执行反馈，例如代码覆盖率，以指导整个测试过程。尽管灰盒模糊对运行在桌面环境中的常规程序表现出了良好的性能，但它不能直接应用于运行在嵌入式设备中的应用程序。这主要是因为缺乏执行应用程序的系统和硬件支持。为了解决这个问题，现有的greybox fuzzing技术使用仿真技术来执行嵌入式应用程序[34,51]。

现有的仿真技术(如QEMU)既支持用户模式仿真，也支持全系统仿真。与全系统仿真相比，用户模式仿真以兼容性为代价享受了更小的执行开销，因为无法模拟系统调用和执行上下文。因此，现有的大多数灰盒模糊技术使用全系统仿真来执行嵌入式应用程序。然而，由于模拟整个系统的沉重开销，这种方法存在效率问题。为了提高仿真效率，Firm-AFL提出了一种在用户模式仿真和全系统仿真之间进行智能切换的技术。Firm-AFL的机制是，它允许应用程序在用户模式下运行，只要它没有执行系统调用，当应用程序遇到系统调用时，Firm-AFL将切换到全系统模拟以获取系统调用结果。与全系统仿真相比，Firm-AFL提高了执行速度，但当PUT涉及大量系统调用时，这种改进就可以忽略不计了。因此，现在的挑战是，我们能否在用户模式模拟下完全执行嵌入式应用程序，而不牺牲太多兼容性?

为了解决基于linux的物联网设备中模糊化应用的挑战，我们提出了EQUAFL，这是一个通过增强的用户模式仿真增强的灰盒模糊化框架，它具有高效率和高兼容性。增强型用户模式仿真的基本机制是自动设置执行环境，以便PUT的系统调用可以直接传递给主机。这样，PUT可以完全在用户模式模拟中执行，避免了系统调用模拟所引起的开销。为了自动地为PUT设置执行环境，EQUAFL使用了观察回放策略。首先，EQUAFL使用全系统仿真执行PUT，并观察系统的关键行为，如设置启动变量、生成配置文件、网络操作等。然后，EQUAFL将重放观察到的系统行为，以建立PUT的执行环境。不同的系统行为需要不同的观察和回放方法，其中最复杂的两种行为是动态配置文件生成和网络交互。前者在观察时需要进程感知，在重播时需要文件系统同步。后者需要状态感知的观察和重放。

我们在基于linux的物联网设备中的70个实际应用程序上评估了EQUAFL的兼容性和效率。结果表明，EQUAFL在执行速度方面优于AFL-QEMU(平均快26倍)和Firm-AFL(平均快14倍)。在实验中，EQUAFL在18个嵌入式设备中发现了10个以前未知的漏洞(包括6个cve)，证明了它在现实世界漏洞发现中的有用性。

**贡献**。综上所述，我们作出以下贡献:

- 我们提出了一种新的EQUAFL技术，它可以在用户模式下自动设置执行环境来完全模拟嵌入式程序。增强的EQUAFL用户模式仿真可以保证高兼容性和高效率。
- 我们基于AFL和QEMU实现了EQUAFL作为覆盖引导的灰盒模糊框架。
- 我们在来自主要嵌入式设备供应商的不同产品系列的70个真实网络应用上广泛评估了EQUAFL。结果表明EQUAFL具有较高的相容性和效率。此外，我们还发现了10个0日漏洞，其中包括6个带有EQUAFL的cve
- 我们在https://github.com/zyw-200/EQUAFL上发布了EQUAFL的源代码，以促进未来的研究。

## 2.背景
### 2.1 基于仿真的Fuzzing

## 3.概述
本系统的目标是在物联网设备中实现基于linux的网络应用程序的高效灰盒模糊。正如在2.1中所讨论的，目前的模糊工作存在性能或兼容性问题。用户模式仿真的AFL一方面保证了较高的模糊速度，但兼容性较差。另一方面，具有全系统仿真的AFL能够成功地模拟更多的目标应用程序，但效率较低。为此，我们建议以一种创新的方式将全系统仿真和用户模式仿真结合起来，开发一个满足两个要求的fuzzer:
- 高兼容性:应用程序的行为应该与全系统模拟相同。
- 效率高:模糊的速度要尽可能快

我们提出的模糊器称为EQUAFL，它是一个基于afl的框架，通过增强型QEMU用户模式仿真。图1显示了EQUAFL的工作流程，包括两个主要步骤:观察和回放。在观察阶段，EQUAFL通过全系统仿真来执行PUT，并观察系统的关键行为。根据图2.1中讨论的故障原因，系统的关键行为包括启动变量的设置、文件生成、NVRAM相关操作、网络交互、进程资源限制等。在这些行为中，最复杂的两个行为是动态配置文件生成和网络交互。因此，我们建议通过进程感知来观察动态配置文件生成和NVRAM配置(4.2和4.3)。同时，我们提出用状态感知来观察网络行为(4.4)。此外，我们使用几个启发式来观察其他信息，如启动变量和进程资源限制(4.1和4.5)。在重播阶段，EQUAFL通过在主机上部署系统资源(如动态配置文件)或在用户模式模拟期间执行系统调用执行的拦截来执行重播。在观察和重放仿真系统中的关键行为之后，PUT可以在增强的用户模式仿真中完全执行，从而避免了将系统调用执行委托给全系统仿真所引起的开销。最后，通过调整PUT生命周期管理和fuzzing的入口点，我们将增强的用户模式仿真与AFL fuzzer集成在一起，以便EQUAFL可以模糊从网络接收输入的物联网应用程序。

![](images/Pasted%20image%2020230321212334.png)

## 4.方法
### 4.1 启动变量处理
启动变量指的是模拟系统中PUT启动时使用的参数和环境变量。如果没有正确的启动变量，PUT可能会提前终止，因此在用户模式模拟中执行PUT时，我们需要确定启动变量。这里我们将PUT表示为𝑝∗，将其程序名称、参数和环境变量表示为𝑝∗𝑛𝑎𝑚𝑒、𝑝∗𝑣𝑎𝑟𝑠和𝑝∗𝑒𝑛𝑣𝑠。通常，这些变量以不同的方式存储在嵌入式固件中，包括写入配置文件，硬编码为二进制可执行文件，甚至由父进程传递。因此，很难通过静态方法实际提取这些参数。相反，我们建议通过对Linux内核进行静态模式分析和在全系统仿真期间进行运行时分析来获得𝑝∗𝑣𝑎𝑟𝑠和𝑝∗𝑒𝑛𝑣𝑠的具体值。

**观察**。基于Linux内核在启动新程序时调用execve系统调用的事实，我们在全系统模拟期间通过检测内核函数do_execve来转储新启动程序的𝑝𝑛𝑎𝑚𝑒、𝑝𝑣𝑎𝑟𝑠和𝑝𝑒𝑛𝑣𝑠。由于do_execve是Linux内核的一个通用体系结构部分，因此可以安全地假设大多数基于Linux的固件不会修改该代码。因此，通过分析Linux内核的源代码，我们总结了一个二进制模式，该模式可用于在模拟固件时定位用于转储这些启动变量的确切组装指令。具体地说，我们发现了三个函数调用指令(一个调用copy_strings_kernel，另两个调用copy_strings)，它们包含可用于计算𝑝𝑛𝑎𝑚𝑒、𝑝𝑣𝑎𝑟𝑠和𝑝𝑒𝑛𝑣𝑠地址的寄存器。然后，我们从这些指令中找到一个最近的后续基本块，在那里QEMU可以进行操作。最后，我们在系统模拟期间将值转储到该基本块。具体来说，我们选择的基本块正是函数search_binary_handler的入口点。

**重放**。经过观察，我们得到了一个集合(𝑝𝑛𝑎𝑚𝑒，𝑝𝑣𝑎𝑟𝑠和𝑝𝑒𝑛𝑣𝑠)，可以用来表示固件仿真过程中不同的进程。然后我们认识𝑝𝑣𝑎𝑟𝑠和𝑝𝑒𝑛𝑣𝑠作为目标𝑝∗𝑣𝑎𝑟𝑠和𝑝∗𝑒𝑛𝑣𝑠,哪里𝑝𝑛𝑎𝑚𝑒等于𝑝∗𝑛𝑎𝑚𝑒。在模糊化过程中，我们利用用户模式模拟，用𝑝* 𝑣𝑎𝑟𝑠和𝑝* 𝑒𝑛𝑣𝑠执行𝑝*。最终，PUT可以在用户模式模拟中运行到深度状态以进行进一步测试。

### 4.2 文件系统状态同步
在全系统模拟中，许多固件映像挂载临时文件系统，并在初始化阶段不断更改文件系统状态。在主机上，如果不初始化固件，就不能更新文件系统状态。结果，由于主机的文件系统状态不正确，PUT将在用户模式模拟中执行到意想不到的状态。例如，固件在初始化阶段[5]动态生成配置文件等文件。在固件的原始文件系统中找不到这些文件。因此，PUT可以在不访问主机上的特定配置文件的情况下执行到错误状态

为此，我们利用观察-重放策略来同步客户机和主机之间的文件系统状态。具体来说，我们尝试观察客户计算机中与文件相关的系统调用执行情况。对于每个观察到的与文件相关的系统调用执行，我们在主机上重新执行它。我们不断重复这样的观察-重放操作，直到检测到PUT已经开始运行。在此之前，PUT执行的文件系统状态已经完全设置好。不幸的是，在主机上执行重播操作时，与文件相关的系统调用的一些参数是未知的。例如，如图2的右手所示，当我们重新执行写入系统调用时，我们不能直接指定𝑓𝑑* ℎ𝑜𝑠𝑡的值。为了解决这个问题，我们提出了一种进程感知的观察方法来构建客户机和主机之间的文件映射。

**准确的进程识别**。为了实现进程感知的观察，我们首先建议识别客户机中当前正在执行的进程。进程识别的工作流程包括进程收集和进程推断两个步骤。在进程收集步骤中，我们不断更新固件仿真过程中所有运行进程的信息。具体来说，由于fork和execve系统调用都参与创建新进程，因此我们在这两个系统调用执行的末尾收集新生成进程的信息。在插装点，我们遍历task_struct数据结构(Linux内核中的进程描述符)，并找到新生成的表示新进程的数据结构。对于每个进程，我们从task_struct中获取信息，包括页全局目录(PGD)的起始地址、进程标识符(PID)和父进程的PID (PPID)。最后生成包含所有运行进程信息的集合𝐶𝑜𝑙𝑙𝑒𝑐𝑡𝑖𝑜𝑛，如式1所示。在进程推断步骤中，我们通过监视特定的寄存器或内存区域来获取当前正在执行的进程𝑝的PGD值。例如，对于ARM架构，我们通过访问指定的系统控制协处理器寄存器（CP15）来获得𝑝的PGD值。在得到PGD值后，我们进一步搜索𝐶𝑜𝑙𝑙𝑒𝑐𝑡𝑖𝑜𝑛，找到PGD值相等的匹配项。我们获得𝑝的PID和PPID，它们将用于客户计算机和主机计算机之间的文件系统状态同步。

![](images/Pasted%20image%2020230328110001.png)


## 4.3 NVRAM配置
我们利用观察-重放策略在主机上生成运行时NVRAM配置。

**观察**。在最先进的全系统仿真技术(例如，FIRMADYNE[5])中，分配常规文件来存储NVRAM配置的数据。因此，通过将相关api重定向到这些常规文件中的数据访问来实现NVRAM访问的模拟。由于我们已经在主机上实现了文件系统状态同步，因此存储NVRAM配置数据的文件也会在主机上生成。

**重播**。在用户模式模拟中，我们通过将PUT的NVRAM访问重定向到主机上的NVRAM配置文件来执行重播。具体来说，我们利用LD_PRELOAD技术来执行带有定制库的PUT，该库覆盖了所有与NVRAM相关的api，包括set、get、commit和clear NVRAM操作。

## 4.4 网络行为
与其他系统行为不同，网络行为会受到网络与外界互动的影响。例如，由于用户向PUT发送请求的场合不同，与网络相关的系统调用序列在不同的运行中会有很大差异。为了模拟网络行为，我们首先从大量观察到的与网络相关的系统调用序列中学习网络状态机。然后，我们基于状态机模拟PUT的网络行为。

状态感知的观察。首先，我们在全系统仿真期间自动收集PUT的与网络相关的系统调用序列。由于Linux系统中的应用程序不仅使用socket进行网络通信，而且还使用socket进行进程间通信，因此我们通过监控socket系统调用的𝑡𝑦𝑝𝑒参数来识别与网络相关的socket。如果𝑡𝑦𝑝𝑒与AF_INET6或AF_INET相同，我们将生成的套接字标识为与网络相关的描述符𝑓𝑑𝑛𝑒𝑡。稍后，在𝑓𝑑𝑛𝑒𝑡上执行的系统调用被标识为与网络相关的系统调用。在收集网络相关的系统调用序列后，我们执行如图3所示的状态机来指导网络行为的仿真。具体来说，Linux内核发出一系列与网络相关的公共系统调用来支持网络通信。大多数与网络相关的系统调用，包括bind、listen、accept、read/recv/recvfrom，都是按照一定的顺序执行的。否则，与网络相关的应用程序将无法正确实现网络通信。

此外，我们的网络应用程序经常使用I/O多路复用操作来监视网络套接字是否准备好了读或写。有代表性的系统调用包括轮询、选择。与典型的套接字操作不同，它们不被认为是实现网络通信所必需的。从我们的观察中，我们发现I/O多路复用的使用在不同的应用中呈现出多种形式。幸运的是，网络状态转换过程也可以如图3所示进行建模:(1)当应用程序第一次在𝑓𝑑𝑛𝑒𝑡上执行Poll时，𝑓𝑑𝑛𝑒𝑡已经准备好连接，并且在𝑓𝑑𝑛𝑒𝑡上设置就绪状态。在此之后，接受新的网络描述符𝑓𝑑'𝑛𝑒𝑡。(2)当应用程序在𝑓𝑑'𝑛𝑒𝑡上执行Poll时，就绪状态设置在𝑓𝑑'𝑛𝑒𝑡上。在此之后，𝑓𝑑'𝑛𝑒𝑡正在等待数据。(3)当应用程序第三次执行Poll时，𝑓𝑑'𝑛𝑒𝑡已经接收到数据，在大多数情况下，当前的fuzzing迭代可以终止，然后进入下一轮fuzzing。

重播。在重播阶段，我们遵循图3中的状态机来模拟与网络相关的系统调用。具体来说，我们在与网络相关的系统调用开始时进行检测，然后在它成功执行后提供预期的结果。我们还通过填充相应的内存维护了网络资源sock_addr等数据结构，这确保了依赖这些网络相关资源的后续执行能够正确执行。


### 4.5 进程资源限制



## 5.实现
### 5.1 模拟
**观察**。最初，EQUAFL通过使用FIRMADYNE(用于基于linux的嵌入式固件[5]的自动化和可扩展的全系统仿真平台)执行全系统仿真PUT。在全系统仿真期间，EQUAFL在系统调用执行结束时通过检测QEMU的全系统模式来进行观察。具体来说，当固件执行到系统调用时。QEMU将处理系统调用的特定异常或中断。EQUAFL将其作为系统调用执行的起点，并记录当前执行上下文。稍后，固件将执行到内核空间，在每个基本块的末尾使用EQUAFL插桩来检测固件执行是否返回到用户空间。当固件执行到用户空间并且执行上下文等于之前的记录时，EQUAFL将其视为系统执行的结束。最后，我们可以在全系统模拟中收集每个系统调用执行的参数和返回值。

**重播**。EQUAFL从两个方面进行回放。对于启动变量、文件系统状态同步、NVRAM配置，EQUAFL通过直接在主机上部署相关资源来实现重播机制，PUT可以在基于模糊的用户模式仿真中使用这些资源。针对网络行为、进程资源限制等问题，EQUAFL利用QEMU的用户模式实现了重放策略。在释放发射变量阶段，我们利用IDA Pro[21]找到释放发射变量的准确位置。此外，在文件系统状态同步阶段，我们首先利用Binwalk实用程序[25]来解包固件并获得原始文件系统。在文件系统状态同步后，我们利用chroot将提取的固件文件系统的顶部目录指定为根目录，以便用户模式模拟中的PUT能够正确地访问具有绝对路径的文件。

## 5.2 模糊测试
此外，通过修改以下策略，我们将增强的用户模式仿真与AFL集成在一起。

**PUT生命周期管理**。一般来说，AFL使用PUT的主要功能作为模糊入口点。它在入口点分叉一个子进程，并在派生进程中执行模糊处理。当PUT执行到结束时，AFL退出生成的流程并循环回到入口点，进行下一个模糊迭代。在我们的系统中，我们进一步缩短了模糊循环的生命周期以提高效率。具体来说，我们指定接收网络输入的系统调用作为入口点。同时，当检测到PUT执行轮询或选择已为新的网络请求做好准备的系统调用时，我们退出当前的模糊迭代，如图3所示。

**模糊的入口点**。通常，AFL将测试输入作为文件提供给PUT。与AFL不同，EQUAFL将输入馈送到存储网络输入的内存缓冲区。具体来说，我们通过检测接收网络输入(如read、recv和recvfrom)的系统调用来实现输入馈送。在输入模糊化输入后，我们还将模糊化输入的长度分配给返回值。


## 9.结论
针对linux嵌入式固件中的网络应用，我们提出了一种高效的模糊分析框架EQUAFL。该框架允许通过增强的用户模式仿真来模糊物联网应用程序，从而避免了QEMU全系统仿真的成本。我们在标准基准测试和来自三大嵌入式设备供应商(包括D-Link、TRENDnet和NETGEAR)的70个实际应用程序上评估EQUAFL。结果表明，EQUAFL在模糊兼容性方面优于AFL，在模糊效率方面优于AFL- full和Firm-AFL。EQUAFL已经在这些固件镜像中发现了10个漏洞，其中包括6个cve。未来，我们将尝试支持更多定制化的硬件外设，进一步提高EQUAFL的兼容性。

