# Firmadyne论文
## 论文基本信息

论文题目：Towards Automated Dynamic Analysis for Linux-based Embedded Firmware

作者：

## 论文主要内容

### 研究问题

嵌入式设备由固件控制来执行生活中不可或缺的功能，而这些设备的安全性无法得到保障。评估设备固件安全首先应该准确识别出漏洞，但市场上的嵌入式设备种类各种各样，影响了该领域现有方法的适用性。

### 作者目标，已实现什么，还有哪些局限

**目标：**准确识别嵌入式固件漏洞

嵌入式固件通用动态分析平台

实现：

1.确定了COTS固件动态分析固有的一些挑战及解决方法

2.提出firmadyne，一个针对网络设备上的基于linux的固件的自动化动态分析系统

3.对firmadyne进行评估，测试42个供应商的23035个固件映像

**局限：**模拟成功率低

### 研究方法/技术



方法/技术创新点，关键要素



哪些内容有用



## 写作积累

### 常见术语

embedded devices

## Introduction

越来越多嵌入式设备连接到互联网上，它们之间有一些共同的技术特征。而很多设备是由固件控制的，但这些固件很少更新来解决与设备相关的安全漏洞。这些设备常位于网络上的重要位置，这使得安全问题进一步恶化。并且大多数供应商没有采取措施来提高他们设备的安全性，使得家庭和小型企业网络都容易受到已知和未知威胁的攻击。

为提高设备安全状况，作者认为应该解决**准确识别嵌入式固件漏洞**的问题。

以往固件安全研究根据分析方法分类：

1.Zaddach等将固件执行部分转移到硬件层面来执行动态分析

优点：准确

缺点：大规模分析会遇到障碍

a.需要提供被测设备的物理硬件，财力负担

b.设备调试端口识别与连接使该方法可伸缩性受到限制，特别是对于不支持硬件调试的设备

2.Costin等使用静态分析技术对嵌入式设备固件解包并识别潜在的漏洞代码和二进制文件。

优点：可伸缩性强

缺点：存在静态分析经典权衡问题

a.要么分析非常一般，产生大量假阳性；要么分析太具体，导致很多假阴性

b.静态分析技术常针对特定问题域，但商用网络设备常包含各种不同的程序和脚本，有时甚至对语言运行库进行定制修改。

为克服这些缺点，作者采用**基于软件的全系统仿真来实现对商业嵌入式固件的大规模自动化动态分析**。

- 由于不依赖硬件执行，它使用额外的计算资源拓展
- 透明提供动态分析功能，因而不用考虑开发的编程语言
- 继承其他动态分析技术的精确度，若发现漏洞则可以提供成功利用的可操作结果
- 解决了嵌入式设备特有的一些挑战，如各种硬件特定外设、NVRAM持久配置存储、动态生成的配置文件

作者实现了Frimadyne来演示提出的自动化动态分析方法。

- 爬虫自动下载固件镜像和元数据，反馈给动态分析系统
- 自动解包，识别内核并提取文件系统
- 通过预编译的Linux内核来支持基于Linux的固件
- 使用Qemu全系统模拟器，使用提取的文件系统来引导仪器化内核

为正确配置仿真环境来实现网络接口交互，系统最初在一个隔离的网络环境中模拟客户机，监视所有的网络交互来推断正确的配置。收集到这些信息后，Firmadyne使用推断的网络配置重新配置仿真环境，使固件客户机可以与主机进行网络通信。

作者发现了14个先前未知漏洞，并能手工编写POC。从42个供应商收集到23035个固件镜像，在成功提取出来的9486个固件镜像中识别出69个漏洞固件镜像，涵盖至少12种不同的产品。因Firmadyne模拟和测试固件镜像的过程是自动的，所有可以直接从Metasploit框架中集成现有漏洞的一个子集。

基于这些结果，作者发现最多的漏洞利用影响多达5个不同的供应商的固件，最有效的漏洞利用影响数据集中所有网络推断固件镜像的10%。这些攻击也影响源代码不公开的程序中，这说明代码共享和共同的上游制造商非常普遍。

总结，这项工作的主要贡献：

- 提出Firmadyne，实现了一种自动化和可扩展的动态分析技术，专门设计用于准确识别基于linux的嵌入式固件中的漏洞
- 解决了嵌入式系统的典型挑战，如硬件外设、NVRAM、动态生成文件的创建
- 收集了42个供应商的23035个固件镜像，使用成功提取9486个固件镜像及14个先前未知和60个已知漏洞利用来评估Firmadyne
- 将系统开源

## Overview

这部分介绍Firmadyne各个组件的设计及设计动机。

### 组件

#### 固件爬取

该组件从供应商网站下载固件镜像，目前支持42家设备供应商。作者为每个网站手动编写解析模板，这可以区分固件镜像和其他二进制文件，并得到固件镜像的元数据，如构建日期、发布版本和SNMP协议的MIB文件链接等信息，这些元数据对自动化分析和开发很有帮助。对于难于自动抓取的动态网站，换为抓取供应商FTP站点，但这种方法没有元数据。

#### 提取固件文件系统

使用一个基于binwalk API定制的提取工具来提取固件镜像中的内核（可选）和根文件系统

#### 初步模拟

首先识别固件镜像硬件架构，如MIPS Little-Endian

然后使用预构建的Linux内核进行与目标镜像体系结构、字节顺序、字宽相匹配的Qemu系统仿真，目前支持的架构组合：ARM小端、MIPS小端、MIPS大端。

再执行一个初始模拟来推断系统和网络配置，通过拦截对文件系统、网络和其他相关内核子系统的系统调用来实现的。

#### 动态分析

基于前面推断的信息重新配置环境，然后进行动态分析。Firmadyne设计为易于扩展，为便于检查，每项分析结果都被汇总在一个数据库中。

测试

为说明这种通用性，作者开发了三个漏洞检测通道，能够帮助找到漏洞并通过监测仪器化内核事件来识别给定利用释放成功。这些通道帮助我们检测出14个先前未知漏洞，并基于我们编写的POC自动证实影响69个固件镜像。作者通过从Metasploit框架等无缝集成60个已知漏洞来进一步展示firmadybe的灵活性。这两种漏洞类型总共影响887个数据集中的固件镜像。

### 动机

针对嵌入式系统固件的动态分析解决了抽象层次的各种设计点。这里将讨论此类分析的潜在优势、挑战、缺点，并讨论为什么基于全系统仿真的动态分析是解决这一挑战的最有前途的方法。

#### 应用程序级

静态提取特定应用程序数据并用本地一个支持的应用执行它。如将嵌入式系统的web的页面放到常规的web服务器来运行，但这种方法有很多缺点，伸缩性不强：

- 很多网页依赖于服务器端脚本语言非标准扩展
- 一些固件镜像将HTML内容嵌入自定义web服务器二进制文件中，而非存放在文件系统中

对应用程序的数据分析方法只能检测应用程序特定数据中的漏洞，而不能检测原始应用程序和其他系统组件中的漏洞。

#### 进程级

在原始文件系统上下文中模拟单个进程的行为。如可以通过qemu用户模式执行应用程序，通过chroot将其限制在原始文件系统中。

这种方法只是部分解决上面的问题，但对于特定硬件外设（如NVRAM）仍不可用，当程序试图通过/dev/nvram访问NVRAM外设时，程序会错误的终止。

执行环境中微小的差异可能会对程序行为产生重大影响。如多个固件镜像使用的alphafs web服务在访问NVRAM前会验证硬件相关产品和供应商ID，如果这些值不在对应的物理内存地址中，那么程序就会错误终止。为此，web程序会使用mmap()系统调用通过/dev/mem访问内存，检查特定偏移位置处的所支持的EEPROM芯片的Product ID和VendorID。

在用户模式下模拟这些行为是复杂的，首先模拟器需要跟踪映射到内存上文件句柄和系统调用来确定程序行为，其次模拟器需要识别各种内存地址的含义并替换为适合的值。

此外，由于主存储设备上写周期有限，许多固件映像挂载一个临时内存支持文件系统at boot for volatile data.这个文件被动态地挂载和生成，因此/dev和/etc可能是连接到临时文件系统子目录的符号链接，在静态检测时看起来是断开的。如D-Link DIR-865L 无线路由器使用一个startup脚本来填充包括lighttpd在内的应用配置，然后这个配置文件通过-c命令参数传递给web服务二进制程序。因此，即使原始文件系统存在，对lighttpd二进制程序简单的动态模拟也会失败。

这些环境的差异可能会对漏洞的存在有巨大影响。例如很多信息泄露漏洞可以通过适当的控制策略被简单的修复，同样web服务器目录遍历攻击的影响很大程度上受系统配置的影响。

尽管这个方法比前一种更准确，但它显然因为模拟保真度低而有很多缺点。没有精确的运行时系统环境知识，主机的环境可能通过改变程序执行而无意中影响单个进程的动态分析。

#### 系统级

系统级的模拟方法能够克服上面的挑战。通过对它们的功能进行模拟，预期的硬件外围设备接口将存在。系统环境的精确模拟使得动态生成的数据可以像在真实设备上以同样的方式被创建。所有被系统启动的进程都可以被分析，包括各种守护进程。

因此作者在设计的过程中明确选择系统模拟作为firmadyne的基础。通过利用内核提供的内置硬件抽象，作者将现有内核替换为专门为仿真环境设计和[仪表化]的经过修改的内核。然后结合自定义的用户空间NVRAM实现，在qemu全系统模拟器引导提取的文件系统和预先构建的内核。

对于数据集中超过96.6%的基于linux的固件镜像初始模拟来说这个方法是成功的。这可能是因为Linux系统用户空间和内核接口的稳定和一致性，除了被特定于供应商的内核模块引入的自定义IOCTL。事实上，Linux内核开发者将恢复打破用户空间应用程序向后兼容性的内核改变。

但这不适用于内核模块，当前实现的缺点是缺少位于文件系统上的树外内核模块的仿真支持，因此内核版本的不同可能会导致系统不稳定。然而我们的数据显示这样的支持是没有必要的，因为在所有数据集固件镜像中超过99%的树外内核模块对我们的系统没有用。一个主要的原因是新的内核提供了以前作为树外扩展开发的功能的树内等价物。特别的，58.8%的树外内核模块被用来实现在旧的内核中不存在的各种网络协议和过滤机制，12.7%提供特定硬件外设的支持。例如较老的2.7系列主线内核缺少netfilter连接跟踪和对于各种特定应用协议的NAT支持，而这些在2.6.20左右的内核版本中变得可用。相比之下，最近被确认的包含一个远程利用的缓冲区溢出漏洞的第三方NetUSB内核模块只占数据库中所有内核模块的不到0.2%。

## Concept

本节介绍动态分析框架背后的概念。

### 体系结构

系统具有一个固件存储服务器用于存储每个固件映像对应的二进制文件和一个数据库用来跟踪与每个固件映像相关的信息，包括提取状态，体系结构、品牌，以及给定图像中的每个文件。

一组虚拟的工作节点被用来从每个固件镜像中提取根文件系统和内核（可选）。通过这个过程，数据库被更新为当前的实验进程。如果提取成功，固件库将缓存归档的文件系统。接下来，这些工作节点进入学习阶段，固件镜像被指定一个默认配置，并记录网络交互过程，这可以使我们的系统去推断正确的仿真网络环境。最后，工作节点进入分析阶段，使用推断的网络环境模拟固件镜像，并开始执行单独的分析。

### 获取

为了收集具有代表性的固件镜像数据集，作者开发了一个自定义网络爬虫，为42个预选供应商的支持页面编写解析器，这使我们能区分固件更新和不需要的二进制文件，比如驱动、配置程序和其他二进制文件，并且由于对目标网站有了更好的语义理解，可以恢复关于固件镜像重要的元数据，如供应商、产品名称、发行日期、版本号、更新日志等。

在适用情况下，还补充了目标供应商FTP镜像网站的固件镜像，尽管这种固件源的元数据不那么丰富，但它提供了不会被所有终端用户直接访问的额外的二进制文件，包括发行版本有限的beta版本和测试二进制文件。

少数品牌的固件镜像很难自动化获取或供应商不提供直接的固件下载方式，这时就采用手工方式收集。

### 提取

作者使用binwalk的API开发了一个自定义提取工具，来从固件镜像中提取恢复根文件系统和内核（可选），并将它们规范的压缩为tar档案存储在固件库中。

### 模拟

提取出根文件系统后，系统采取一些列分析步骤来推断固件所期望的系统配置。

首先，检测位于根文件系统下的二进制程序ELF头来识别目标架构和端序。对每个镜像使用对应架构的qemu全系统模拟仿真，使用匹配的内核引导文件系统，目前我们有预编译内核满足的ARM小端、MIPS小端、MIPS大端架构，这些架构占据数据集的90.8%。

接下来，进行初始模拟，系统以一种特殊的学习模式执行，修改过的内核会记录所有与网络子系统进行的系统交互，包括网络接口IP地址的分配。

最终，收集完这些信息后，firmadyne进入真实的模拟阶段，配置匹配的网络环境来实现与模拟固件的通信。为确认成功进行了网络配置，firmadyne启动模拟固件镜像并执行一些列的网络连接检查。

### 自动分析

在动态分析框架中实现了三个基本的自动化分析通道来演示系统的有效性，这使得我们检测到影响69个固件的14个之前未知漏洞，和影响887个固件映像的74个漏洞。

## 实现

这部分介绍每个组件背后的实现。

### 获取

自定义网络爬虫使用Scrapy框架开发，为42个供应商编写了单独的爬行器。为了提高代表性，数据集包含了从消费者到专业网络设备的产品供应商，如IP摄像头、路由器、接入点、NAS、智能电视、有线调制解调器、卫星调制解调器以及第三方或开源的固件。我们使用XPath选择器为每个供应商支持页面编写独立解析器，来枚举和展开输入网页的特定元素。此外，我们也尝试爬取每个供应商多个不同的地理位置支持网站，包括美国（英语）、中国（中文）、俄罗斯（俄语）、欧洲（英语）、德国（德语）和南非（英语）。

一些供应商，如D-Link和ZyXEL在他们的网站上使用了大量的动态生成内容，这种情况下是通过他们的FTP镜像网站来爬取的。只有看起来相关的FTP文件才会被下载，通常限制文件拓展名为：img, chk, bin, stk, zip, tar, sys, rar, pkg和rmt。一些其他供应商，如思科，他们的网站难于自动爬取或者限制大多数固件下载，通过手工爬取。

支持的元数据字段从供应商网站自动收集，包括产品名、供应商名称、版本、构建、日期、更新日志、SNMP MIB文件、源代码URL和固件镜像URL，这使我们可以区别出共享相同固件镜像的多个产品，因为我们删除重复下载的固件镜像二进制文件。然而，不是所有供应商都有这样的信息，这时就通过FTP或手工爬取。

### 提取

通过手工实验，我们发现在binwalk中内置的递归提取机制不能满足我们的要求。当尝试去从一个ELF可执行文件或一个文件系统中每个文件递归提取压缩数据时，这种提取很容易发生路径爆炸，并且不能保证会终止，特别是当假阳性签名匹配存在的情况下。

我们使用binwalk API开发了一个自定义目标驱动的提取工具，在实现提取目标，即从固件镜像内获取到根文件系统和内核时，程序终止，以此来减少磁盘空间和运行时。

另外，我们实现了一组早期检测非固件文件的启发式方法，减少计算资源的浪费。这包括任何结构化类型二进制文件输入文件黑名单，包括Windows PE32可执行文件、Linux ELF可执行文件、Macintosh的通用二进制文件及字节码和可重定位对象。其他被排除的常见格式包括PDF文件和Microsoft Office文档，不然它们会显示为需要递归提取的压缩档案。

黑名单验证后，提取过程使用一组按照置信度顺序进行优先级排序的签名，这些签名可以分为以下几类：存档格式、固件头、内核魔字或版本字符串、类UNIX根文件系统及最后的压缩数据。若匹配到存档格式或压缩数据，就会递归进行提取。通过检查来自文件系统层级标准下的至少四个标准根目录是否存在来验证类UNIX根文件系统是否提取成功。

通过优先考虑高可信度的签名匹配（如固件头）而非通用签名匹配（如gzip压缩数据）减少了假阳性签名匹配的影响。比如上游binwalk在固件内核镜像中的压缩数据并启用了递归提取，那它将浪费资源来尝试提取该数据。

对提取过程做的另一个改进是使用第三方jefferson和sasquatch提取工具来提取JFFS2和SquashFS文件系统。相对来说，他们更难提取。这是因为文件系统开发人员提供的用户空间提取工具jffsdump和unsquashfs经常对这种类型的真实文件系统提取失败。

一方面，这是因为这些用户模式提取工具很少更新，在文件系统支持方面落后于内核文件系统代码。更重要的，很多设备制造商已经修改了现有的压缩算法，甚至为这些文件系统实现了新的压缩算法，使它们的变体与其他实现不兼容。

为了解决这个问题，其他的固件提取工具如bat和firmware-mod-kit依赖于一组从各种路由器GPL源代码发布中收集来的启发式和预编译的unsquashfs二进制文件。然而这种方法是不完整和无效的，因为这些提取工具的维护者需要手工编译新的二进制文件并实现适合的启发式。

相反，我们利用专门编写的工具从用户空间提取这些修改过的文件系统内容。sasquatch由binwalk的作者开发，设计用于支持尽可能多的修改过的SquashFS实现，通过适应压缩算法的改变，及识别SquashFS文件系统的结构而不是特定的签名字符串。

在这个过程中，我们发现了binwalk和jefferson的很多bug并做了改进，这些改进被提交给各自的上游项目中。我们提交的大部分补丁已经合并到正式官方版本中，还有一些仍然在等待维护者的审查。

尽管这些改进提高了我们的成功率，但并不是所有的固件镜像都可以通过我们当前的实现提取出来。例如，一些供应商仅仅发布它们产品的部分固件镜像，防止我们重建根文件系统。另一些供应商发布代带有多个嵌入的或部分的文件系统的固件镜像，这使我们需要额外的逻辑来重新组装部分文件系统或挂载在另一个文件系统之上的文件系统。此外，其他的供应商发布加密的固件镜像、在二进制更新程序内的固件镜像、非基于Linux的固件镜像、含有不能识别的文件系统的基于Linux的固件镜像，这些我们都不支持，这些镜像被归类为未知。

### 模拟

#### NVRAM

粗略的检查，至少52.6%的提取出来的固件镜像（9486中的4992个）使用名为libnvram.so共享库访问硬件NVRAM来保存特定设备配置参数。对于路由器和其他网络设备，这包括显示在基于web的配置界面上的设置，比如无线网络设置、网络适配器MAC地址和web界面的访问凭据。

因为这个外围设备通常被抽象为一个键值存储，我们开发了一个自定义用户空间库来拦截对NVRAM相关的调用，比如const char* nvram_get(const char* key)和int nvram_set(const char* key,char \*val)，这两个函数分别用于从NVRAM获取和设置参数。通过修改内核传递给init二进制文件的系统环境，来借助LD_PRELOAD包含我们的自定义库，因为所有用户空间进程都是init的子进程，所以它们都继承相同的环境。我们把一个文件系统上的临时挂载点当作键值存储的根，这允许我们重新实现用户空间的这个接口而不需要模拟特定硬件外设。

在测试过程中，我们遇到的一个常见挑战是我们固件镜像的数据集是由不同的C工具链编译的，其中一些我们没有访问权限。这个多样性对我们的共享库来说是有问题的，因为所有动态加载的ELF二进制文件必须指定它们被编译时动态加载库的路径，以及动态加载依赖的文件名，这些文件名在不同系统上是不同的。

起初，我们试图通过静态编译我们的NVRAM实现来解决这个问题，然而我们很快发现这些C运行时库不仅使用了内置C特性(如线程本地存储)的不兼容实现，而且它们也没有构建为位置无关代码来支持静态编译。结果我们既不能针对一个单一的C运行时库静态构建我们的NVRAM库，也不能针对每个固件镜像动态构建我们的共享库。

幸运的是，Linux系统的ELF动态加载器支持懒链接，这允许外部函数符号延迟到使用的时候才被解析。通常，编译器通过在PLT表内放置存根代码来实现，当给定的导入函数第一次被调用的时候，PLT初始化GOT项。

由于ELF加载器在解析时使用全局符号来查找作用域，因此我们能够使用- nostdlib编译器标志编译我们的NVRAM库，从而将外部符号的解析延迟到调用进程已经加载了系统C运行时库之后。实际上，这允许我们的共享库以静态二进制文件的形式出现，同时动态地利用调用进程提供的函数，包括标准C运行时库。

另一个挑战是，没有一组系统特定的默认值，我们的NVRAM实现是无效的。这些值通常在工厂就被嵌入在硬件NVRAM外设中，系统硬件的依赖性将阻碍我们执行大规模分析的目标。简单的返回NULL或空字符串也是不够的，因为这可能最终造成系统在启动时崩溃或进入一个错误状态，如用空指针调用itoa()和strcpy()函数，或者向程序调用插入错误的参数如ifconfig。起初，我们尝试硬编码一组默认的NVRAM值到我们的库中，但我们很快发现这是无法实现的，因为一个一般的固件镜像在启动的时候可能引用数百个NVRAM值。

在手动检查模拟失败的镜像后，我们意识到大多数镜像将一组默认的NVRAM值嵌入到一些常见位置，如名为/etc/nvram.default, /etc/nvram.conf, /var/etc/nvram.default的文本文件中。另一些则在内置库如libnvram.so或libshared.so库，导出了一个类型为char *[]发符号router_defaults或Nvrams。我们不能使用libdl.so（通常不是由调用文件加载）或将它们作为常规引用（外部数据符号解析不是懒加载），但我们可以通过将它们声明为弱引用并检查它们是否初始化来访问这些符号。

不幸的是我们的NVRAM模拟实现并不是对所有的固件镜像都有用，这可能有很多原因。例如镜像调用我们没有模拟的NVRAM相关函数，在传递参数、返回值、调用者/被调用者内存分配方面程序期望的语义与我们模拟的不同，镜像实现NVRAM为一个在MTD分区上的自定义数据结构，我们目前无法初始化为一个有效状态。我们认为在NVRAM模拟上的失败可能是后面模拟效果下降的一个重要原因。作为一个难以忽视的事实，提高来自像Shibby的Tomato这样的固件镜像，模拟成功率或修复网络配置检测是一个手动的过程。它需要手动分析检测系统日志来对故障进行识别和分类，然后做出改变以支持这些镜像。通常，这时一个循环的过程，因为可能有很多原因导致模拟失败。

#### 内核

我们不使用提取的内核，而实使用自己定制的ARM和MIPS架构内核，这两种架构加起来占数据集的90.8%。

在内核编译过程中，我们在自定义Linux内核模块中实现分析，该模块用于帮助调试和模拟原始系统环境。通过使用内核动态探测(kprobes)框架挂钩20个系统调用，我们能够拦截改变执行环境的调用。包括分配MAC地址、创建网桥、重新启动系统和执行程序等操作，所有这些操作都被我们的框架监视，以此来正确配置模拟的网络环境。该功能还可以用于提供漏洞的自动确认，特别是结合不应该出现在系统调用中预定义的有毒值(例如，0xDEADBEEF, 0x41414141)。

一些固件期望在引导的时候某些文件系统就被挂载，如/dev或/proc，我们使用rdinit内核参数来允许一个自定义脚本，使这些文件系统在init执行前就初始化这些文件系统。另外，我们在启动的时候加载nandsim内核模块，用于模拟通过/dev/mtdX访问的内存技术设备(MTD)分区，这些分区经常用在在这些嵌入式设备上。

另外，由于我们模拟的NVRAM是不稳定的，我们禁止客户机重启系统并通过重启init进程来模拟这个行为。这个内核模块还通过返回带有通用存根的成功，模拟特定于供应商或特定于设备的接口，如自定义设备节点、procfs条目或非标准IOCTL。

对于MIPS架构，为大端和小端系统建立了独立的内核，都针对MIPS Malta开发平台，因为此平台得到QEMU和Linux内核的良好支持。事实上，这个平台甚至支持64位代码，虽然我们暂时不支持它因为它只占数据集的不到0.6%。这个内核当前版本为2.6.32.68，是一个长期支持的版本，并且包括对完全kprobes支持的提交。

对于ARM架构，只支持小端系统，因为大端系统只占数据集的不到1.1%，并且不被主线QEMU所支持。我们针对ARM Versatile Express开发平台，它使用一个模拟的Cortex-A9(ARMv7-A)处理器。该平台提供了比标准的ARM Versatile Platform Baseboard开发板更好的硬件兼容性，后者使用模拟的ARM926 (ARMv5)处理器，不支持在一些固件映像中发现的较新的ARM指令。但是，由于QEMU中缺少模拟的PCI总线，这个平台最多只支持一个模拟以太网设备。未来，我们计划切换到ARM Virtual Machine平台，此平台通过VirtIO支持多个虚拟设备，但这需要把内核从3.10.92升级到4.1.12，这是一个更新的长期支持版本，完全支持ARM上的VirtIO功能。

如上所述，添加新硬件体系结构(如x86)的支持不是一个自动化的过程，特别是在QEMU选择一个支持的硬件平台是棘手的，因为通常需要附加多个虚拟网络接口来支持VirtIO或模拟的PCI总线。同时，QEMU中所选的硬件平台必须由所选的Linux内核版本支持，该版本需要足够最新能够支持kprobes和VirtIO。为内核开发兼容的配置也很棘手，因为我们需要启用现有固件所依赖的所有特性。此外，我们需要基于所选的内核版本重新修改自定义内核模块实现，这可能需要手动兼容性修复以考虑内部内核API的更改。

#### 系统配置

由于我们主要对实现网络功能的固件感兴趣，例如路由器、网络附加存储或监视设备，因此我们需要对模拟硬件进行特定于设备的更改。理想情况下，所有网络设备都可以通过DHCP协议自动配置自身。不幸的是，某些网络设备，特别是路由器和一些托管交换机，被设计为向其他设备提供DHCP服务。此外，这些设备往往有不同数量的网络接口，例如，典型的家用路由器至少有四个以太网接口，而IP摄像机上只有一个。

我们的系统最初以60s的学习阶段执行每个仿真固件，在这个阶段，使用QEMU内置的套接字网络后端，模拟器使用对应模拟目标平台(MIPS Malta或ARM Virtual Express)的默认硬件外设来配置，以及最多四个模拟的网络适配器。在此期间，将收集有关预期网络配置的信息，特别是，我们跟踪分配给网络接口的IP地址，以及用于聚合多个网络接口的IEEE 802.1网桥是否存在。此外，我们使用IEEE 802.1Q VLANS检查以太网帧的标记和分离，一些路由器使用该VLANS将无线客户网络与物理网络隔离。

然后将该信息反馈到我们的仿真框架中，为该系统生成更精确的QEMU配置。我们在主机上实例化一个tap设备与固件里LAN接口对应的一个模拟网络接口（如eth0）相关联。对于使用VLANs的固件，我们为tap接口分配了一个对应的VLAN ID来与实现与模拟网络设备的通信。接下来为tap接口分配IP地址，此IP地址与固件模拟接口的IP在同一子网。最后，通过发送ICMP请求和Nmap工具进行端口扫描来检查网络连通性。

#### QEMU

除了NVRAM，我们预计嵌入式系统会依赖于其他硬件特定的外设，如看门狗定时器或额外的闪存存储设备。不幸的是，一些设备制造商没有遵循良好的软件工程实践，直接在用户空间中实现这些功能，而不是在内核空间中使用设备驱动程序。

结果，我们不能简单地抽象出这些设备，并在自定义内核模块中清晰地模拟这种行为。例如，前面提到的alphafs web服务器将一部分物理内存从/dev/mem设备节点直接映射到它自己的地址空间。它期望闪存芯片的配置信息映射到0x1e000000，用VendorID和ProductID标识参数与软件支持的芯片匹配，若不匹配就会终止。

为了在FIRMADYNE中支持138个受影响的固件映像，我们在QEMU的源代码中为仿真平台flash设备适当修改了16个字节，以返回一个已知的良好值。

### 动态分析

当前，在我们的系统内我们已经实现了三个基本的自动化动态分析通道，每一个都注册为系统中的回调，使得固件镜像进入网络推断状态时，依次触发注册的回调。这帮助我们检测14个先前未知的漏洞，这些漏洞影响了69个固件镜像，和74个已知的影响887固件镜像的漏洞。

#### 可访问网页

为了帮助检测各种信息泄露、缓冲区溢出和命令注入漏洞，我们编写了一个简单的分析来从固件映像的LAN接口中寻找公开可访问的网页。一个定制编写的Python测试工具遍历固件映像中每个可能是web服务的文件（如位于/www/下），若验证它们不是一个静态资源（如.png, .css, .js），就尝试直接通过web界面访问它。

若HTTP**响应状态非2xx就直接忽略**，因为这些通常是无法访问的网页(403/404)、需要身份验证的网页(401)或是由于套接字超时或不完全读取引起的无效响应。包含重定向的成功响应被标记为低置信度结果，因为我们通过实验确定了大量重定向被用于实现软身份验证页面。

可能作为一种更友好的身份验证机制，这些身份验证页面检查客户端请求是否使用客户端cookie或服务器IP地址日志进行身份验证，而不是使用HTTP协议里的Basic或Digest身份验证机制j（返回401）。因此，这些网页被标记为较低的置信度，而所有其他网页都被标记为正常置信度。这些结果在我们的固件数据集中进行聚合，以确定哪些url最容易访问，然后按受欢迎程度的顺序进行优先级进一步分析。

#### SNMP信息

出于对数据集中SNMP实现的流行度和安全度的兴趣，我们使用我们的框架编写了一个基本的分析，从公共和私有社区使用snmpwalk工具转储所有未认证的SNMP信息。使用爬虫收集的MIB文件，手动解释一个子集的结果来检查是否存在敏感信息。记录相应的对象标识符(OID)，并根据查询OID时是否返回信息为每个对象编写一个简单的概念证明。

#### 漏洞

使用60个已知漏洞(大部分来自Metasploit框架)，我们首先检查数据集中所有固件镜像有没有已知安全漏洞，每个漏洞利用顺次执行，如果适用的话携带远程shell载荷，然后检查相应的攻击日志是否成功。这为我们的数据集中的漏洞数量提供了一个下限，因为即使存在漏洞，利用也可能失败。测试的漏洞是根据已知存在于嵌入式设备上的应用程序和守护进程的相关性手动选择的，并且包含了各种利用类别，如缓冲区溢出、命令注入、信息泄露和拒绝服务。

对于我们发现的新漏洞，我们手动开发了概念证明利用，这利用了我们预定义的有毒参数，如0xDEADBEEF。然后，我们为每个攻击指定一个验证条件，这通常是在我们的仪器化内核日志中存在有毒参数，其他的可能是segmentation
fault at 0x41414141或网页中的WPS PIN。

### 额外功能

我们还开发了很多额外的功能来协助开发和调试我们的仿真框架和利用。这包括代码执行的动态追踪，这可以导入到现有的逆向工程工具中，例如IDA Pro。我们自定义内核被修改为禁用context_switch()函数的内联，这使模拟器可以跟踪给定用户空间进程的执行。此外，在启动时，我们还在设备节点/dev/ttyS1上启动一个特殊的控制台应用程序，该应用程序由QEMU转发到主机系统上的一个临时套接字。这为我们提供了一种在运行时修改模拟固件映像的方便机制，特别是在没有默认控制台启动的情况下。

## 评估

这一节，我们评估了firmadyne的实现。首先，我们检查了输入数据集的组成，分析在模拟管道每个阶段它对模拟保真度的影响。其次，我们展示如何利用我们的系统在收集的固件样本中识别出14个先前未知的漏洞，利用我们针对每个漏洞开发的概念验证漏洞，我们使用我们的系统来评估它们的流行程度和对数据集的影响。最后，我们通过补充60个已知的攻击(大部分来自Metasploit框架)来演示我们系统的分析灵活性，并评估这些已知的攻击对我们数据集的流行程度和影响。

重要的是要注意，跨产品线和设备供应商的固件映像分布是不一致的，这可能会影响对结果的解释。特别是，尽管我们试图抓取关于每个固件映像的型号和版本号的元数据，但这些信息并不总是可用的，也不是以可以轻松建立时间顺序的格式显示的。例如，供应商可能会重新发布具有不同硬件的给定产品，或者在每个地区发布具有不同硬件或固件的产品，阻碍了具有完全相同模型的两个固件映像之间进行直接比较。结果，很难识别哪些固件映像已弃用，以及哪些固件映像是当前版本。

此外，很难在固件映像和产品之间建立映射，因为不存在直接的一对一对应关系。例如，一些供应商(如Mikrotik)为每个硬件体系结构分发单一固件映像，而其他供应商(如OpenWRT)为每个硬件芯片组分发单一固件映像。同样，一些供应商(如QNAP和Synology)开发的主固件映像仅对每个产品在硬件支持和产品字符串方面进行轻微定制，而其他供应商(如OpenWRT)则使用各种封装格式分发相同固件映像的不同二进制版本。这引出了一个我们没有解决的问题：给定两个不同的固件二进制，它们在功能上可能有多相同。尽管如此，在可能的情况下，我们试图提供受影响产品数量的下限。

### 统计

#### 架构

对于所有具有提取根文件系统的固件映像，我们能够通过检查系统上busybox二进制文件的格式头来识别相应固件映像的体系结构，如果找不到busybox，也可以选择/sbin/中的二进制文件。

我们的固件映像的大多数是32位MIPS(包括大端和小端)，大约占79.4%。下一个最流行的体系结构类型是32位小端ARM，约占8.9%。这两个体系结构加在一起构成了所有固件映像的90.8%，其余的构成了这个分布的尾巴，这意味除非有特别的理由，否则没有必要进行额外的工作来支持剩余的架。

#### 操作系统

通过结合我们对Linux和VxWorks内核的根文件系统提取和签名匹配的统计数据，我们发现在我们的固件镜像中占比最大的是基于UNIX的，占48%。如果一个固件映像的文件系统被确定为基于unix的，但是在内核提取过程中遇到了故障，那么该映像将被标记为类unix的。导致这种情况的潜在原因包括路径探索约束、不支持的压缩算法，甚至是固件映像中缺少内核。只有3.5%的固件映像被识别为VxWorks，这表明实现对这些设备的支持是低优先级的。

前面提过，未知的固件镜像可能是固件提取失败的重要原因。这包括看似基于linux的固件映像，但我们无法重新组装整个文件系统，只能提取部分类unix文件系统，或者提取一个未达到我们认为是类unix的阈值的文件系统。其中一些已知使用ZynOS，ZynOS由ZyXEL通信公司开发的专有实时操作系统，它使用ThreadX内核和未知的文件系统类型，而我们缺乏内核版本签名和文件系统提取实用程序。

其他未知的固件镜像是不使用明显的内核或文件系统的整体镜像。因此，如果没有硬件文档，模拟这些固件映像将非常困难，因为特定于芯片组的代码可能分布在整个二进制文件中。u-blox使用这种类型的固件映像，它也包含在我们的数据集中。

#### 内核模块

在我们提取的所有固件映像中，我们基于文件名对树外内核模块执行了一个基本的分类。这些数字表明，58.8%的这些模块实现了各种网络相关的功能，如包过滤(iptables, xtables, netfilter, ebtables)，协议实现(pptp, ppp, adsl)和接口支持(mii, tun, tap)。第二大子集(12.7%)用于提供对各种外设的支持，包括无线适配器(wl、ath9k、sierra)、平台芯片组(ar7240、ar7100、bcm963xx)和各种其他设备(acos_nat、pl2303)。其余的许多内核模块似乎都是被编译为可加载模块的树内内核模块，包括通用USB接口实现(ehci、uhci、xhci)、文件系统(fat、fuse、ext3)、加密函数(sha512、crypto)和各种其他杂项内核例例(ts_fsm、sch_hfsc)。这些内核模块中只有不到0.2%被识别为KCodes NetUSB内核模块，这是一个专有的IP内核上的USB模块，已知它包含一个可远程利用的缓冲区溢出漏洞。

#### 网络服务

为了评估数据集固件中监听网络服务的流行程度，我们使用nmap网络扫描工具检查响应ICMP echo requests的1971个镜像。我们基于来自nmap-services文件的所有已知服务来扫描所有TCP端口，以及1-1024的连续端口（这时nmap的默认扫描行为）。结果显示，在1971个网络可达的网络设备中，47.3%支持基于web的配置界面(HTTP或HTTPS)。其中，只有9.5%的设备支持HTTPS作为配置接口，是支持HTTP设备的19.8%。

37.4%的设备支持通过Telnet或SSH协议进行远程shell访问。然而，SSH不在前十个结果之列，事实上，它以2.2%的占比排在第13位，是支持Telnet的设备的1.9%，这比支持HTTPS的设备在支持HTTP的设备中所占的比例还要少。

根据DNS服务的存在情况，这些固件映像中应该至少有27.2%是路由器，它们通常充当本地DNS代理。另外16.4%的设备默认启用了UPnP，允许LAN设备从wan接口自动配置端口转发。

已知2602端口被RIP协议使用，该协议通常在企业级路由器上启用，用于自动网络路由。

根据各种客户支持论坛，端口3333和5555已知在某些Netgear设备上是开放的，不过我们还没有检查我们的Netgear固件映像来确定对应的服务。端口49152是各种应用程序通过UPnP转发的动态端口地址范围中的第一个端口，尽管我们的网络配置中没有任何UPnP客户端，也不确定默认转发状态。

#### 模拟进展

在我们识别体系结构的8,617个提取固件映像中，我们的系统最初成功地模拟了96.6%(8,591)。而失败镜像可以归因于许多原因，包括在标准位置(/bin/init、/etc/init或/sbin/init)中缺乏初始化二进制文件，或无法引导的文件系统。例如，某些包含Ralink芯片组的映像将其init二进制文件命名为ralink_init，我们当前不支持这种。同样，在前面关于失败原因的讨论也会影响初始模拟的成功率，由于我们只从包含多个文件系统的固件映像中提取第一个类unix文件系统，因此很可能只提取了文件系统的一部分，从而导致引导失败。将这些系统重新组装到单个文件系统中并不简单，因为每个文件系统都可能安装在另一个文件系统的任意位置上。

在8,591个进入“学习”阶段的固件映像中，只有32.3%(2,797)成功推断出了网络配置。我们认为，这种减少是由于在试图推断网络配置时引导过程出现了失败。正如我们之前所讨论的，NVRAM仿真问题是导致这些故障的重要原因。例如，如果我们的NVRAM实现不能覆盖内置实现，如果我们的实现加载了不足的默认NVRAM值，或者如果内置NVRAM实现期望与NVRAM相关函数有不同的语义，那么一些路由器可能不会正确初始化。这些在引导过程中表现为各种崩溃或挂起，特别是当内存或字符串操作函数(memcpy()， strcpy()等)被我们的NVRAM实现为不存在的键而返回的NULL值调用时。此外，也有可能一些映像不使用NVRAM硬件外设，而是直接将配置值写入MTD分区，这种情况我们可能无法成功模拟。

网络故障的其他潜在原因包括网络设备不同的命名约定。例如，使用Atheros或Ralink芯片组的设备可能希望平台网络设备的命名分别类似于ath0或ra0，而不是通常的eth0。同样，其他设备可能期望出现无线网络接口(如wlan0)，否则就会失败。此外，由于我们的ARM小端仿真平台目前只支持一个仿真以太网设备，这可能会阻止一些固件映像正确配置网络。

在2797个能推测网络配置的镜像中，只有70.8%(1971)个可以使用ping访问，这可能是由仿真客户机上防火墙过滤ICMP回响请求造成的，从而导致假阴性，或者其他各种网络配置问题。例如，我们的系统可能错误地将QEMU中的主机TAP接口分配给了仿真设备的WAN接口而不是LAN接口，或者识别了WAN接口的默认IP地址而不是LAN接口。类似地，固件可能会在启动后更改模拟网络设备的MAC地址，导致ARP缓存项失效，使机器看起来不可访问。

令人惊讶的是，我们的结果显示45%(1971个固件映像中的887个)的网络可达固件映像容易受到至少一种攻击。我们将后面结果部分进一步讨论这个问题，并根据利用情况进行分类。

### 结果

我们对所有成功利用的漏洞进行了细分，范围在# 0 - # 100的漏洞利用来自Metasploit框架，而大多数大于等于#200的漏洞都是之前未知的漏洞，我们为此开发了POC。这不包括#202，它是一个已知的漏洞，但不是来自Metasploit框架。出于负责任的公开政策，这些以前未知的漏洞都已报告给了各自的供应商。我们将在下面更详细地讨论几个特定的漏洞，作为案例研究。

根据单个固件漏洞利用成功的数量，我们对固件镜像做了划分发现，少数这些固件映像容易受到两种以上的攻击，最不安全的映像会受到五种攻击。有趣的是，所有40个易受两种以上攻击的固件映像都是D-Link和Netgear制造的路由器和接入点。然而，这些数据可能被我们的利用和固件映像的不均匀的分布所扭曲。这个结果最初似乎呈指数衰减，只有不到一半(39.8%)易受0次攻击的固件映像易受一次攻击的攻击，但漏洞分布存在长尾效应，只有4.5%(126)的固件映像受一次以上攻击的影响。

#### 命令注入

(#200, #201, #204 – #206, #208)

在分析我们的自动可访问网页分析的汇总结果时，我们发现了6个以前未发布的命令注入漏洞，影响了Netgear制造的24个无线路由器和接入点的固件映像。所有6个漏洞都位于提供调试功能的PHP服务器端脚本中，但似乎意外地被包含在生产固件版本中。具体地说，其中五个用于更改系统参数，如WLAN适配器的MAC地址和固件映像的区域(例如，World Wide [WW]、United States [US]或Japan [JP])。剩下的一块用于将生产数据，如MAC地址、序列号或硬件版本写入闪存。我们对PHP源代码的手动分析显示，所有这些漏洞都是通过\$\_REQUEST超全局的直接命令注入漏洞，以及exec()函数的不安全使用。在发现这些潜在的漏洞后，我们利用FIRMADYNE在整个数据集中自动验证它们的可利用性。

#### 缓冲区溢出

(#203)

使用我们的自动可访问网页分析的结果，另一个我们手动发现的新漏洞是某些D-Link路由器固件映像中的缓冲区溢出漏洞。为了实现用户身份验证，web服务器将客户端cookie dlink_uid设置为与每个经过身份验证的用户相关联的唯一值。这个认证功能实际上是在web服务器中硬编码的，而不是在网页的服务器端脚本语言中验证这个cookie的值，它使用标准库函数strstr()、strlen()和memcpy()来复制cookie的值。因此，我们能够将这个cookie的值设置为一个过长的值，导致web服务器在0x41414141处崩溃，这是我们监视的另一个有毒参数。

#### 信息泄露

 (#207, #209 – #214)

通过自动网页分析，我们还在数据集中发现了7个新的信息泄露漏洞，这些漏洞影响了D-Link和Netgear生产的各种路由器的51个固件映像。其中之一(#207)是在一个未受保护的网页中，该网页为路由器提供诊断信息，包括所有本地广播无线网络的WPS PIN和口令。

其余6个漏洞(#209 - #214)位于两个制造商的SNMP守护进程中。这一功能是默认启用的，可能是因为这些路由器针对的是小型企业而不是家庭用户。要解释从SNMP查询获得的结果，需要访问一个描述每个单独对象(OID)字段语义的管理信息库(MIB)文件。正如在前面所讨论的，我们的爬虫在收集的元数据中记录到MIB文件的链接，使我们能对获得的结果进行手动验证。

我们的自动攻击验证显示，这些固件映像会响应公共和私有社区的未经身份验证的SNMP v2c查询，并返回OID的值，其中包含设备上所有用户的基于web的访问凭据，以及所有本地广播无线网络的无线凭据。

#### Sercomm配置转储

(#47)

该漏洞被报告为CVE-2014-06595，来自Metasploit框架，攻击scfgmgr服务的无文档和设计不良的特性，从NVRAM远程转储系统配置变量并获取shell。该漏洞的公开文档表明，截至2015-01-28，该漏洞已知会影响思科、Linksys、Netgear和各种小型供应商生产的网络设备的固件。我们的自动化分析证实了这一点，该分析也证实了On Networks和TRENDnet制造的设备中存在这个漏洞。更准确地说，我们的结果表明，这个单一漏洞影响了我们数据集中所有网络可达固件映像的14.3%。这是因为Sercomm 公司很可能是这些设备的原始设备制造商(OEM)，然后这些设备被不同的供应商重新命名和转售。

#### MiniUPnP拒绝服务

该漏洞报告为CVE2013-0229，利用MiniUPnP(一个开源UPnP守护进程实现)中的简单服务发现协议(SSDP)的解析缺陷，触发对该服务的拒绝服务攻击。

根据我们的结果，我们的数据集中所有网络可访问的固件映像中有8.5%容易受到这种攻击，这一问题在2009-10-30 MiniUPnP 1.4发布时得到了解决。受影响的供应商包括华为、Netgear和Shibby的Tomato，这是一个社区为各种无线路由器开发的第三方固件。Rapid7 (Metasploit框架的开发者和该漏洞的最初报告者)发布的统计数据表明，截至2013-0129,332个产品使用MiniUPnP 1.0，超过69%的MiniUPnP指纹对应1.0或更老版本。这些结果再次强调了由于共享软件组件(不管是开源的还是私有的)而导致的跨供应商漏洞的普遍存在。

#### OpenSSL ChangeCipherSpec

该漏洞被报告为CVE-2014-0224，并利用了0.9.8za、1.0.0m和1.0.1h之前的所有OpenSSL版本中SSL/TLS握手过程的错误状态机实现。利用此漏洞，攻击者可以降低客户端和服务器之间的密码规范，从而潜在地允许中间人(MITM)攻击。我们的结果显示，8.5%的网络可达固件映像容易受到这种攻击，这是所有接受HTTPS连接固件映像的89.9%。该漏洞还影响了我们数据集中8.4%的产品，是所有漏洞中影响最多的。受影响的供应商包括D-Link、Netgear和TRENDnet。

### 讨论和局限性

虽然FIRMADYNE在我们的实验中表现得很好，但当然还有改进的空间。正如前面所讨论的，额外的手工工作可以提高系统，例如，修复提取失败，增加对附加硬件架构的支持，或纠正模拟失败来。这些更改需要分析人员根据根本原因手动对故障进行分类，并执行增加兼容性所必需的更改。实现一个新的分析过程也需要人工操作，我们可能会从中获得很大的好处，因为每个新实现的分析都可以在数据集中所有受支持的固件映像上自动执行。

此外，我们的结果可能很难评估，因为缺乏一种机制来量化独特产品(而不是独特固件映像)现实世界的影响。同样，我们的结果也会受到数据集的供应商组成和网络可达固件映像的差异所导致的倾斜的影响。

FIRMADYNE的其他限制包括使用定制的预构建内核，这些内核目前不从文件系统加载树外内核模块。因此，我们的系统不能用于确认内核或由供应商在固件映像中提供的内核模块中的漏洞。例如，由于这个限制，我们无法评估数据集中KCodes NetUSB内核模块缓冲区溢出的流行程度。

同样，我们不确定哪个网口被用作上行(或wan)端口，以及哪个网口被用作下行(或LAN)端口。这使我们无法确定检测到的漏洞是通过Internet利用的，还是仅通过本地连接的客户机利用的。

然而，远程攻击者可以使用许多技术通过web浏览器从wan接口转移到LAN接口，包括跨站请求伪造(CSRF)，跨站脚本(XSS)，甚至DNS重绑定攻击。此外，随着IPv6部署的增加，本地机器现在被分配到可全球路由的IP地址。这潜在地允许攻击者访问消费设备的LAN接口，即使路由器仍然可以充当防火墙。越来越多的无线路由器和接入点现在也支持网络隔离或客户端隔离功能，这些功能可以在各种无线或物理接口之间隔离流量。然而，网关路由器中这些漏洞的存在显然损害了这种保护。

## 相关工作

随着嵌入式设备的日益普及，一些相关的工作使用各种分析技术对固件图像进行了大规模的分析。例如，Heffner执行了大规模的嵌入式固件映像提取，以收集超过2000个硬编码SSL私钥的数据库。同样，Rapid7对硬编码的SSH私钥使用了类似的分析，尽管规模较小。

使用静态分析，Costin等人最近分析了一个大约32000个固件图像的数据集。他们总共发现了38个以前未知的漏洞，包括硬编码后门、嵌入式私钥对和XSS漏洞，所有这些漏洞都是“不执行复杂的静态分析”就获得的。

另一种大规模测量嵌入式设备安全性的有效技术是网络扫描，它避免了对固件映像的直接分析。通过使用Nmap等工具，Cui和Stolfo识别了大约54万个具有默认访问凭证的公开可访问嵌入式设备。在一个为期4个月的纵向研究过程中，他们发现只有不到3%的访问凭证被更改，这表明用户缺乏意识。同样，使用ZMap网络扫描器，Heninger等人明嵌入式设备也可能遭受熵问题。他们的结果表明，2.45%的TLS证书可能由于RSA密钥生成错误而容易受到暴力攻击，1.03%的DSA私钥由于非平凡公因式可分解。

此外，之前的工作还发现了影响各种嵌入式设备的特定漏洞。Cui等人使用HP LaserJet打印机作为案例研究，演示了远程固件更新功能可以被攻击者利用来插入恶意软件。Weinmann表明，部署的蜂窝基带实现存在可远程利用的内存损坏漏洞，可用于在基带处理器上执行任意代码。类似地，Bonkoski等人表明，服务器主板上的远程管理功能充满了安全漏洞，允许远程攻击者控制系统。最后，Maskiewicz等人和Nohl等人表明，恶意功能可以插入到USB外设的固件中，允许攻击者控制主机系统并窃取数据。

为了防御这种攻击载体，开发了几种不同的技术来发现嵌入式设备中的漏洞。例如，Davidson等人使用KLEE符号执行引擎开发了一个符号执行程序，用于检测嵌入式设备中的漏洞。他们的工作发现了包含99个8位嵌入式微控制器MSP430家族的开源固件程序库中的21个内存安全漏洞。在较低的级别上，Li等人将QEMU模拟器移植到BIOS中，以建模硬件外设，以便在开发过程中验证嵌入式SoC。

最近，Zaddach等人还开发了一个框架，通过从模拟器内部转发I/O访问执行实际硬件来执行嵌入式固件的动态分析。然而，这种方法在分析成本和时间方面无法扩展，这就是我们设计FIRMADYNE以自动方式执行健壮的硬件模拟和漏洞验证的原因。

## 总结和未来工作

通过开发我们的自动化动态分析框架FIRMADYNE，我们希望降低在嵌入式系统中发现新漏洞的门槛。与此同时，FIRMADYNE实现了一种自动化方法，以评估在大量嵌入式设备固件映像中新发现的安全漏洞的流行程度。考虑到这些设备的薄弱安全态势，我们相信安全研究人员、爱好者和其他相关方对这些设备的更多关注可以激励设备制造商更快地解决其产品中的安全问题。这对原始设备制造商来说尤其如此，他们要为现有部署设备中的很大一部分漏洞负责。

我们数据集中的第二大嵌入式固件类别(仅次于Linux)来自各种专有的实时操作系统(RTOS)，如VxWorks。这为未来的工作提供了一个潜在的途径，特别是考虑到已经发布的漏洞会影响这些平台。特别是，我们对使用仿真平台上现有的实时Linux开发框架(如Xenomai)为这些应用程序开发一个兼容性层很感兴趣。

由于通用开源软件许可的条款，许多基于linux的嵌入式固件都有相当数量的源代码发行版。由于我们的数据集包含到每个固件映像的适用源代码的链接，这可以提供一种实现有效静态分析的机制，与我们执行动态分析的现有框架相结合。

最后，可以利用统计分析技术改进框架的固件提取组件。出现模糊或加密的固件映像可以通过单独的提取路径进行处理。例如，众所周知，Buffalo LinkStation设备的固件是加密的，但密码和解密实用程序是公开的。这同样适用于为QNAP设备分发的各种固件。

## 疑问

instrumented kernels 是什么？

NVRAM

out-of-tree kernel modules 

内核动态探测(kprobes)框架

## 当前固件模拟失败的原因

网络、系统环境配置

硬件外设，如NVRAM

内存上特定值
