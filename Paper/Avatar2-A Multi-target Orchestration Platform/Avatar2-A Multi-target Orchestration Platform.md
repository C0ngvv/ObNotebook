---
title: "论文：Avatar2: A Multi-target Orchestration Platform"
date: 2023/9/18
categories:
  - 论文
tags:
  - 论文翻译
---
# Avatar2: A Multi-target Orchestration Platform
发表于：Workshop on NDSS Binary Analysis Research (BAR) 2018

一个框架用于将不同的二进制分析框架整合在一起协调工作，方便复现其他工作，基于Python

## 摘要
动态二进制分析技术在研究软件系统的安全性和检测各种设备和应用程序中的漏洞方面发挥着核心作用。在过去的十年中，各种不同的技术已经发布，通常伴随着原型工具的发布来证明它们的有效性。不幸的是，大多数这些技术的实现都与它们的动态分析框架紧密耦合在一起，并且不容易集成到其他框架中。这些框架的设计目的不是向其他组件公开其内部状态或结果。这使得分析人员无法将不同的工具组合在一起，利用它们的优势来解决需要结合复杂技术的复杂问题。碎片化和隔离是两个重要的问题，它们经常导致重复的工作，或者对同一个问题产生多个等效的解决方案——每个解决方案都基于不同的编程语言、抽象模型或执行环境。

在本文中，我们介绍了avatar2，这是一个动态多目标编排框架，旨在实现不同动态二进制分析框架、调试器、模拟器和实际物理设备之间的互操作性。Avatar2允许分析人员在复杂的拓扑结构中组织不同的工具，然后将二进制代码的执行从一个系统“移动”到另一个系统。该框架支持设备/应用程序内部状态的自动传输，以及可配置的输入/输出转发和对物理外设或模拟目标的内存访问。

为了演示avatar2的使用和多功能性，在本文中，我们提出了三个非常不同的用例，其中我们复制了NDSS 2017上展示的PLC rootkit，我们测试了结合Angr和GDB的Firefox，我们使用PANDA和OpenOCD记录了嵌入式设备固件的执行情况。所有工具和三个用例都将作为开源发布，以帮助其他研究人员复制我们的实验，并使用avatar2执行他们自己的分析任务。

## 1.引言
我们的社会越来越依赖于计算系统，从低端嵌入式设备到大型基于云的系统。这些系统用于非常多样化的领域，从复杂的工业环境到较小的消费设备。然而，在所有计算系统中经常发现的大量软件漏洞使这种依赖性成为一个重大问题。因此，在这些系统上运行的软件需要仔细测试和验证，这通常不仅由制造商自己完成，而且由第三方公司和安全研究人员完成。虽然从源代码分析程序是一项重要的工作，但在软件作者和第三方中，仅二进制分析非常流行。第三方参与这项活动的动机是多种多样的，从签约执行额外黑盒测试的顾问，到作为bug赏金计划一部分搜索安全漏洞的个人，或者只是对减少流行软件产品中的bug数量感兴趣的研究人员。

当源代码可供分析人员使用或软件作为开放源代码可用时，纯二进制测试也是一种非常流行的选择。之所以会出现这种情况，是因为仅通过源代码检查无法发现一些细微的错误，而且二进制分析允许独立于用于开发系统的源代码语言测试软件。此外，不依赖于源代码意味着分析不依赖于编译器是正确的，也就是说，“你模糊测试的就是你发布的”。

因此，在过去的十年中，使用纯二进制方法的测试和分析软件变得越来越流行，并且已经发表了各种不同的二进制分析技术[23]。通常情况下，这些技术是在独立的工具中实现的，以证明它们的有效性。有些工具是简单的原型，而其他工具是更成熟的解决方案，这些解决方案多年来已经获得了显著的普及。现有的工具可能依赖于直接在目标分析主机或模拟器中执行的测试，甚至在专用的特定执行引擎中(例如，用于符号执行)。

>[23] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino, A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel et al., “Sok:(state of) the art of war: Offensive techniques in binary analysis,” in IEEE Symposium on Security and Privacy. IEEE, 2016.

不幸的是，大多数这些技术的实现都与它们的动态分析框架紧密耦合在一起，并且不容易集成到其他框架中。通常，他们甚至重新实现其他工具的二进制分析技术部分，以受益于这些技术，因为每个框架的目标都是获得尽可能最好的分析。不幸的是，到目前为止，在不同框架之间更好的交互方面投入的努力很少，不仅在重用分析结果方面，而且在向外部组件共享内部分析状态方面。这使得分析人员无法将不同的工具组合在一起，利用它们的优势来解决需要结合复杂技术的复杂问题。碎片化和隔离是两个重要的问题，它们经常导致重复的工作，或者对同一个问题产生多个等效的解决方案——每个解决方案都基于不同的编程语言、抽象模型或执行环境。

在本文中，我们介绍了avatar2，这是一个我们开发的框架，用于促进多个二进制分析工具(如调试器、符号执行引擎和模拟器)之间的互操作性。我们的解决方案背后的基本原则是让分析人员选择多个执行环境，这些环境稍后用于在相同的执行状态下执行任务。实际上，我们将在本文中展示，在各种场景中，不仅将特定的分析保留在一个工具中是有益的，而且将其状态用作其他分析环境中的基本块。Avatar2是Avatar[29]的后继者，Avatar是一个最初设计用于执行嵌入式设备分析的系统，我们完全重新设计并扩展了它，以允许任意组件的轻松编排，这些组件可以组合起来执行复杂的二进制分析任务。

我们相信avatar2是为这种多目标编排提供通用框架的第一次尝试。特别地，本文在二进制分析领域做出了以下贡献:

- 我们展示了分析环境之间的状态转发不仅对嵌入式设备分析有用，而且是一种更通用的技术，允许在多个环境之间进行编排。
- 我们提出了avatar2，一个完全重新设计的系统，用于编排多个测试环境之间的执行。
- 我们展示了avatar2脚本如何帮助快速复制以前的研究，同时提高使用avatar2进行的研究的可重复性。
- 我们用三个非常不同的用例来演示avatar2的使用和多功能性，在这些用例中，我们复制了以前的固件研究，我们记录和回放了嵌入式设备的执行，我们分析了一个大型桌面应用程序。
- 我们强调跨多个工具协调执行的好处:GDB, OpenOCD, QEMU, anger和PANDA。
- 我们将所有工具和三个用例作为开源发布，以帮助其他研究人员复制我们的实验，并使用avatar2执行他们自己的分析任务。

本文的其余部分结构如下。首先，在第二节中，我们提供了程序分析的一般背景，并对avatar2的前身avatar[29]进行了总结。之后，我们介绍了avatar2框架(第三节)，然后通过三个案例研究(第四节)展示了它的有用性，突出了框架的有趣方面。然后我们讨论结果(第V节)，比较avatar2与相关工作(第VI节)，并以结束语结束论文。

## 2.背景
在描述avatar2框架之前，我们提供一些关于动态二进制分析主题的背景信息，以强调对多目标编排的需求。之后，我们简要讨论了avatar的前身——《avatar2的灵感来源——avatar的原始框架。虽然原始工具的目的仅仅是通过将S2E[5]连接到物理设备来实现嵌入式设备的动态二进制分析，但它引入了许多重要的概念，用于构建适合协调多个动态二进制分析工具的编排框架。

> [5] V. Chipounov, V. Kuznetsov, and G. Candea, “S2e: A platform for invivo multi-path analysis of software systems,” in 16th Intl. Conference on Architectural Support for Programming Languages and Operating Systems. ACM, 2011.

### A.动态二进制分析
程序分析通常分为静态分析和动态分析。静态分析仅仅通过检查代码来解释程序，而动态分析依赖于程序的实际执行。因此，静态分析可以通过分析程序的所有可能的执行路径来提供可靠的结果。

然而，使用静态分析时，程序的整个运行时状态是不可用的(例如，堆结构，一些指针或线程)，并且通常需要近似来确定其他不可确定的问题，这可能导致大量误报。动态分析通过分析程序在给定输入上执行时的实际行为来避免这些问题(以只能观察一小部分程序状态和代码为代价)。

动态分析的一个常见应用是安全性测试和评估，其目的是发现影响被分析程序安全性的错误。这些错误的常见示例包括身份验证绕过、内存损坏或内存泄露，这些都可能对潜在的攻击者有利。在这种情况下，仅基于机器码的二进制程序分析尤其重要，原因有二。首先，二进制代码是程序最精确的表示，因为它是直接在处理器上执行的代码。第二，尽管存在一个稳步增长的开放源码运动，但大量的程序只以二进制形式分发。这尤其适用于用内存不安全语言(如C和c++)编写的程序，由于它们的广泛部署，它们是攻击者的绝佳目标。

近年来，动态二进制分析的技术水平有了很大的提高，开发并提供了各种工具来辅助安全性测试。经典的方法要求在执行程序之前对被检查的二进制文件进行插装(动态或静态)。Valgrind[18]和AddressSanitizer[22]是遵循这种方法的流行工具示例。

动态分析的另一个相关用途是与符号执行引擎相结合，作为一种提供具体输入的方式来驱动符号探索(在传统上称为concolic执行)，或者作为一种由符号探索和约束求解驱动的沿着多条路径执行程序的方式。这种混合动力引擎的发展在过去十年中经历了复兴，分析师必须在几个框架之间做出选择，如angr [24]， BAP [2]， Manticore [27]， Miasm [10]， BINSEC/SE[8]或Triton[21]。

虽然每个解决方案都有自己的优点和缺点，但它们都有一个共同的属性:每个分析任务都绑定到自己的专用工具。这是由于多种原因造成的，包括不兼容的设计选择(例如使用特定于某个工具的中间表示或以自定义格式抽象表示程序状态)，或者开发人员经常将工具实现为独立的系统，这些系统的实现是为了灵活使用，但很难与其他解决方案集成。除了导致重复工作之外，由于不同的工具经常彼此独立地实现相同的动态二进制分析技术，这阻碍了二进制分析的全部潜力的释放。

### B.Aavatar 1
Avatar[29]是一个用于嵌入式设备的动态二进制分析框架。本质上，它允许在S2E(一个基于QEMU的符号执行引擎)内部对固件进行部分仿真。为了实现这个目标，不能模拟的I/O请求被转发到实际的嵌入式设备，或者通过专用的调试端口，或者通过使用手动注入设备的调试存根。

虽然Avatar只专注于允许S2E在嵌入式设备上工作，但它引入了以下概念，这些概念对于设计更通用的二进制动态分析编排框架起着重要作用:

- 目标编排。Avatar引入了编排的概念，不仅仅是作为一种控制其两个目标(S2E和物理系统)的方法，而且还作为基于分析师指定的特定事件自动将执行从一个工具转移到另一个工具的方法。
- 执行和内存分离。在传统的分析方法中，软件的执行和它的内存空间是紧密联系在一起的，而Avatar将它们解耦了。这允许框架使用所谓的远程内存，在其中一个目标上执行，而内存读写被转发到另一个目标。这允许Avatar实现部分仿真，而主固件在仿真器中执行，而对内存映射外设的访问被转发到实际设备。
- 状态转移和同步。除了编排执行之外，Avatar还提供了选择性地将状态从一个目标转移到另一个目标的可能性，其中状态由内存内容和CPU寄存器的组合定义。这允许Avatar在被分析的物理设备上执行初始化功能，然后将状态转移到S2E执行符号执行。

## 3.AVATAR2框架
正如第II-A节所讨论的，动态二进制分析可以从现有工具的互连中大大受益。在本节中，我们将介绍avatar2，这是我们开发的框架，通过连接调试器、模拟器和其他动态二进制分析框架来实现灵活的动态二进制分析。

### A.总体概述和术语
组合和连接各种不同的工具需要仔细规划设计，以应对工具多样性带来的固有挑战。例如，这些工具通常同时使用异步和同步通信。

在抽象层次上，avatar2由四个不同的元素组成，如图1所示。avatar2的核心、目标和协议是python库(可在https://github.com/avatartwo/ avatar2上以开源形式获得)，而端点是由avatar2控制和连接的第三方软件(如其他分析框架、模拟器或与物理设备通信的解决方案)。

![](Avatar2-A%20Multi-target%20Orchestration%20Platform/Pasted%20image%2020230808093200.png)

avatar2核心有三个目的:i)作为使用框架的分析人员的主要接口，ii)执行实际的编排和控制所有底层元素，以及iii)在与各自的端点通信时捕获、调度和响应由各种协议生成的事件。

目标扮演抽象每个端点的角色，并为avatar2核心提供高级接口。然而，这些python抽象并不直接与它们相关的端点通信。实际上，由于实际的通信通常需要类似的模式，否则将在多个目标中复制，因此它由特定协议对象层进行中介。这种体系结构使得在对新目标进行原型设计时可以很容易地重用各个协议。例如，各种调试器和模拟器的情况就是这样，尽管它们通常配备有自己的通信接口，但通常还包含一个gdbserver，它可以通过gdb的远程串行协议进行控制。

协议本身根据其目的进行划分。在大多数情况下，目标至少需要一个内存协议、一个执行协议和一个寄存器协议。这些协议分别负责分派内存读写、控制目标的执行和访问其CPU寄存器。此外，avatar2还提供了定义其他协议的可能性，例如专门用于监视端点状态的监视协议，或者可以为从一个端点到另一个端点的内存访问提供自定义高带宽通道的专用远程内存协议。

最后，端点可以是任何值得为分析编排的东西，avatar2的初始实现支持五种不同的选项，我们将在第III-C节中详细介绍这些选项。

不同组件的严格分离和抽象允许灵活配置各种不同的目标。因此，与第一版Avatar相比，框架的范围远远超出了动态分析嵌入式设备固件的初始目标。这是由于avatar2中范式的巨大转变:avatar2的核心目标是在经常用于动态二进制分析的任意数量的不同工具之间实现通用互操作性，而不是用特定的目标编排特定的工具。

### B.幕后故事
至此，我们介绍了框架的总体设计。现在我们重点介绍并详细讨论avatar2提供的五个特定特性。这些特性旨在提供额外的灵活性，以应对不同的动态二进制分析工具。

1)架构独立性:随着软件的互联性的出现，不仅在商用计算机上，而且在嵌入式系统上，对程序分析系统感兴趣的架构和指令集的多样性比以往任何时候都要广泛。直观地说，由于几个动态二进制分析框架已经支持多种体系结构，因此编排框架也应该能够处理这些问题。Avatar2通过以模块化的方式对体系结构进行灵活的描述来处理这个问题，并提供了为特定目标提供注释的额外可能性(即，在体系结构中定义的由目标获取和使用的特殊变量)。虽然当前的实现附带了针对x86、x86 64和ARM的描述，但模块化方法允许轻松扩展框架以支持其他架构，甚至是特定工具使用的中间表示。

2)内部内存表示:Avatar2设计用于连接各种目标，这些目标内部很少使用相同的内存表示。然而，要跨不同的框架和平台同步分析，需要一个一致的程序内存视图。因此，avatar2为分析人员提供接口，用于定义和更新内存布局，然后将其推送到目标。例如，与其他工具不同，avatar2不以页面粒度表示内存。这是因为它的目标是能够处理嵌入式设备，这些设备通常由内存映射外设和CPU寄存器组成，这些外设只使用公共页面的一小部分。相反，avatar2通过组合任意和非统一大小的内存范围来工作。

3)传统Python支持:avatar2核心的初始原型是用Python 3.x编写的。虽然我们相信未来迁移到Python 3是不可避免的，但几个流行的动态分析框架，如angr、manticore和triton，要么完全基于Python 2.7，要么只导出绑定到Python 2.7。因此，我们决定使用Python 3，但仍然保留传统的Python支持，以实现与上述工具的完美和高性能集成。

4)外设建模:嵌入式设备通常由定制的外设组成，这些外设没有在其他端点内实现，或者更糟的是，它们根本不能在其他端点中等价地表示。和第一个Avatar一样，avatar2可以通过内存转发来解决这个问题。然而，由于内存转发可能很快成为性能瓶颈，avatar2通过添加简单外设模型的原型，提供了另一种解决此问题的方法。分析人员可以很容易地用python开发这些模型，并且本质上是在指定偏移量处响应内存读写的简单对象。为了方便这些建模机制，avatar2提供了通用串行端口接口(USART)的实现，该接口可以对意法半导体(STMicroelectronics)基于ARM的特定微控制器中的接口进行建模。因此，该模型通过tcp连接而不是物理外设来接收和传输输入和输出。

5)插件系统:Avatar2的核心设计简约且易于维护，而更复杂的逻辑则由特定的目标和协议提供。然而，大多数动态分析程序所需的各种任务是重复的，因此，如果分析人员需要在每个实验中重新执行它们，则效率将非常低。因此，为了为这些重复性任务提供一个通用的代码库并自动执行它们，avatar2采用了一个丰富的事件驱动插件系统。在插件中，分析过程中处理的各种事件可以通过自定义回调挂钩，或者可以向avatar2核心添加全新的功能。已经存在的插件的例子是汇编器和反汇编器，单个指令的转发插件，例如用于调度协处理器访问，或者用于自动编排分析的插件。

### C.支持的目标
Avatar2旨在以低成本集成新目标。目前，它支持五个目标，已经提供了大量的分析组合。

#### The Gnu Debugger (GDB)
与GDB通信的能力可能是avatar2最重要的特性之一。独立目标允许调试GNU/Linux软件。此外，许多端点都提供了用于调试的gdbserver。由于目标和协议的分离，avatar2能够与所有这些端点进行通信。

#### OpenOCD
现代的cpu和mcu，特别是那些用于嵌入式设备，暴露标准化的调试端口，如联合行动测试组(JTAG)或串行线调试(SWD)端口。OpenOCD是一个开源工具，能够控制可以连接到这些端口的调试加密狗。这些加密狗与OpenOCD一起，可以用于执行软件的细粒度调试。当然，avatar2支持OpenOCD来执行嵌入式设备的分析。

#### Quick Emulator (QEMU)
QEMU是一个流行的模拟器，其核心是使用动态二进制转换来模拟为不同体系结构编写的软件。尽管它允许通过动态系统调用转换在其用户模式下模拟单个GNU/Linux程序，但avatar2也使用其完整的系统模拟模式来处理硬件外设。我们向QEMU添加了两个值得注意的组件，并将其作为avatar2项目的一部分进行维护。首先，我们介绍了一种新的仿真机，即可配置机，它能够以灵活的方式配置内存布局。这有利于与avatar2的内存表示的集成，同时也支持各种嵌入式设备。其次，我们添加了一组专用的avatar外设，它们负责在分析期间与其他目标进行交互。

#### PANDA
与架构无关的动态分析平台(PANDA)[12]是一个动态分析引擎，专注于实现可重复的逆向工程。PANDA基于QEMU，因此重用了在avatar2的QEMU目标中包含的相同组件。PANDA的优势在于其记录、重放和分析先前记录的具体执行的附加功能。

#### angr
符号执行和程序分析框架angr[24]提供了许多强大的动态分析功能。为了更好地与avatar2集成，对angr进行了一些小的添加。这些修改主要集中在angr的状态和内存管理上。更准确地说，添加了一种特殊的内存页面表示，以提供对其他目标内存的访问，并添加了几个自动过程来设置可用于avatar2的分析状态。此外，由于avatar2中的angr目标继承了angr对象，因此不需要直接修改angr。

## 4.使用案例
在本节中，我们将介绍三个案例研究，以演示avatar2的多功能性和动态多目标编排的有用性。与avatar2的其他部分一样，这些示例的完整源代码可以在https://github.com/avatartwo/ bar18_avatar2上公开获得。这些案例研究深入介绍了avatar2的几种可能用途，但并不详尽。实际上，我们将avatar2设计得尽可能多用途，允许各种应用程序和比这里介绍的更多的配置。

### A.促进先前研究的复制和再现
最近的倡议正在越来越多地推动开发过程，以促进系统安全领域的科学研究的复制[6]。但是，如果没有公开可用的示例源代码，则需要对结果进行复制。此外，当涉及到嵌入式设备时，复制以前的工作通常是复杂的。

我们选择HARVEY[14]，一个最近发布的PLC rootkit作为复制示例。通过这个例子，我们展示了avatar2可以作为一种轻量级的机制来创建脚本原型，以便复制以前的研究(或者共享脚本以促进可靠的复制)。这是一个复制研究的好例子，因为该出版物包含了复制它的所有必要细节，而没有公开的源代码或脚本。

在这里，我们只使用avatar2编写单个目标的脚本(而不是编排多个目标)。因此，本例不执行任何动态二进制分析。

HARVEY rootkit被设计为插入到Allen Bradley PLC的固件中。它修改了负责将物理输入和输出的更新转发到硬件的其他部分(如led和人机界面(HMI))的功能。因此，rootkit能够以隐秘的方式篡改PLC的I/O，而不会报告led或HMI上的可疑行为。为了部署所需的修改，HARVEY的作者描述了在PLC上部署受损固件的两种方法:a)通过使用JTAG调试访问来修补内存中的固件;b)通过滥用固件更新功能来持续上传恶意固件。在这种情况下，选项(a)是可能的，因为固件的部分被加载到主MCU的片上SRAM中并从其执行，根据设计，可以在运行时修改。另一方面，选项(b)要求利用固件更新过程。然而，该PLC的固件是加密签名的，安装修改后的固件要么需要能够创建具有冲突SHA-1哈希的新固件，要么需要知道PLC制造商的私钥，要么需要在此签名验证机制中存在缺陷。

虽然我们使用的PLC版本与原始版本略有不同，但我们能够使用avatar2和大约30行python(清单1)重现HARVEY的基本概念实现证明。图2显示了被HARVEY感染后的PLC:两个橙色led表示端口1和2上存在输入信号，尽管没有输入连接到PLC。

![](Avatar2-A%20Multi-target%20Orchestration%20Platform/Pasted%20image%2020230808100804.png)

![](Avatar2-A%20Multi-target%20Orchestration%20Platform/Pasted%20image%2020230808101131.png)

这个例子提供了关于avatar2框架的一些有趣的见解。第12行加载汇编器插件，它添加了汇编和将代码注入内存的功能，如第24-28行所做的那样。然后配置目标器(L. 14-17)，并将其初始化为独立目标器(L. 18)。但是，HARVEY的挂钩不能立即插入，因为次要固件代码必须首先加载到SRAM中。因此，我们在这些初始化函数(L. 20)之后插入一个断点，在开始执行(L.21)之前，等待断点被命中(L. 22)。然后插入钩子(L. 24至L.28)并继续执行(L. 30)。

虽然完整的rootkit可以在没有avatar2存在的情况下注入到固件中，但我们想强调的是，框架的使用为动态检测提供了一个集中和统一的接口，这大大简化了可复制性，反过来，可再现性。

### B.将符号执行扩展到复杂软件
尽管二进制软件的符号执行技术正在稳步发展，但由于各种原因，它的应用往往局限于相当简单的软件。限制因素可以是实现约束，例如缺少环境抽象，也可以是符号执行的一般问题，例如状态爆炸或SMT-Solvers的限制。

虽然我们的目标不是为这些限制提供一个通用的解决方案，但我们展示了avatar2的状态传输和同步功能可以用于将状态从具体执行的软件动态地传输到符号执行引擎中，否则这些状态将无法达到这样的执行状态。更具体地说，我们将分析流行的浏览器Firefox。我们选择这个特殊的程序是因为它的大小和复杂性，这使得使用诸如angr之类的符号引擎几乎不可能进行分析。

为了展示二进制分析的含义，我们将使用avatar2来发现浏览器javascript引擎的GLrendering引擎中人为插入的错误。虽然插入的错误本身是一个微不足道的空指针解引用，但其位置和触发条件受到CVE-20175459的启发。

如何利用avatar2的功能的基本思路非常简单:我们在GDB中执行Firefox，直到找到感兴趣的函数，然后将具体状态转换为angr，将一些攻击者控制的参数符号化到函数中，并进行探索，直到最终找到一个bug。与普通的符号执行相比，这种方法有很多优点。首先，它使被分析程序的初始化阶段能够以接近本机的速度执行。其次，符号执行从程序的有效具体状态开始，这减少了对过度近似的需要，随后减少了探索空间。这与让angr通过考虑执行周围的符号所有环境(包括内存)来分析二进制文件的单个函数形成对比，后者还会引导分析通过在程序的具体执行中不可能实现的路径。

虽然这个想法听起来很简单，但avatar2必须克服几个挑战。首先，angr存储与每个内存位置相关的各种元数据。因此，完全状态传输将破坏angr的内存表示能力。因此，在状态传输时，我们只将内存映射传输到angr，而不初始化内存。内存内容的传输发生在angr实际访问内存时，这有效地导致了read-on-copy原语。相反，写操作是本地的，它们不会被转发回Firefox进程，因为这会导致angr内部不同符号状态之间的不一致。

状态转移过程中的另一个问题是段寄存器，它不是由GDB导出的，也不容易被转移到通用寄存器中。我们创建了一个共享库注入到所分析的进程中，它使用arch_prctl系统调用来检索这些寄存器的值。在状态传输时，avatar2对寄存器状态进行快照，执行库函数来检索段寄存器，将它们转发给angr，并恢复正在分析的进程的原始状态。

我们必须克服的第三个挑战是常用的库函数。实际上，许多符号执行环境(如KLEE[3]或angr)并不以符号方式执行标准库函数(例如，printf, read)，因为它们的复杂性和与环境不必要的交互。相反，会执行更简单的函数存根，在angr术语中称为“SimProcedures”。为了从这种抽象的优点中获益，我们自动地将已知的SimProcedures与分析过程中出现的符号进行匹配。一旦找到匹配项，进程中的相应地址就与SimProcedure挂钩，有效地将函数抽象改造为转移到angr的状态。

感兴趣的读者可以在附录中找到用于查找错误的avatar2脚本。该脚本在我们的测试环境中运行大约9分钟，该环境由一个具有四个Intel Xeon E5-2650L内核和16GB RAM的VM组成。在符号探索期间，将执行36个基本块，并将21个唯一页面从GDB复制到angr。在本例中，这种方法本身的可观察效果很难检测，因为它会导致无效的内存访问，而angr和avatar2都很容易识别。

但是，仅使用angr很难找到导致这种无效内存访问的路径。事实上，当建议angr从包含bug的函数的开头开始探索而不从avatar2继承具体状态时，我们无法检测到这个bug。这样做的原因在于GL呈现功能涉及到对全局对象的频繁访问，这在完全符号化注释时阻碍了探索。另一种方法，即在angr中从头开始执行Firefox，同样无法发现这个bug。这有两个原因:首先，这个bug位于执行的深处，在实际找到这个bug之前，必须先探索太多的路径。其次，Firefox内部使用的各种机制目前还不能在angr中表达，比如线程间通信。

因此，angr可以通过使用初始具体状态胜过其他方法，该状态可以由分析人员手动注入，也可以使用avatar2从gdb中自动提取，如示例中所示。这完美地展示了框架提供的状态传输和同步原语的优势。
### C.固件执行的记录和交换
传统上，嵌入式设备固件的动态分析要么需要物理设备的存在，要么需要能够模拟固件。在这个例子中，我们展示了avatar2能够通过部分模拟固件来记录部分执行。这段记录可以在没有物理设备的情况下进行回放和分析。为了实现这一点，我们指示avatar2使用PandaTarget来模拟和记录固件的核心部分，而对硬件外设的内存访问被转发到物理设备，由avatar2的OpenOCDTarget控制。

在本例中，我们使用Nucleo STM32L152RE开发板作为物理目标，该开发板带有ARM Cortex-M3 MCU，其JTAG连接可通过板载USB接口使用。我们使用ARM mbed7的示例固件。与嵌入式代码一样，它对硬件的外设执行许多低级内存访问。单独的PANDA将无法模拟该固件的执行，因为如果没有对设备的特定外设进行适当的模拟，固件将无法正确执行。

相应的avatar2脚本如清单2所示，它有两个值得注意的地方。第3-12行负责avatar2和目标的常规设置。请注意，这次加载了编排插件，它允许以不同的方式控制目标的执行，如前面的示例所示。第14-18行定义了一个显式内存布局，包括由固件支持的ROM内存和内存映射I/O (MMIO)，它将使用avatar2的远程内存功能转发到物理设备。

![](Avatar2-A%20Multi-target%20Orchestration%20Platform/Pasted%20image%2020230808111942.png)

在定义内存之后，将初始化目标(第20行)，并设置实际的业务流程:第22行定义将首先使用哪个目标执行。第23行添加了转换，其中avatar2将执行从一个目标切换到另一个目标，同时同步synced_ranges参数指定的寄存器和内存范围。在这种情况下，只需要同步RAM范围，因为在此分析中，RAM范围是唯一一个位于多个目标的动态内存。最后一个参数stop指示avatar2在此转换之后停止业务流程。这种状态转移的原因在于希望在设备本身上执行物理设备的初始化功能，因为它们对主固件的分析不感兴趣。

下面一行(L. 25)启动自动编排。Avatar2将一直运行，直到遇到带有停止标志的转换，这在本例中是微不足道的，因为只定义了一个转换。因此，启用PANDA执行记录的第27行将在转换完成后执行，并且必须恢复自动编排(L. 28)。一旦固件执行的有趣部分被记录下来，编排和记录都可以停止(L. 32f)。之后，执行记录是可用的，并且可以在PANDA中重用(例如，执行进一步的分析)，而无需使用嵌入式设备。

这证明了avatar2在执行和内存之间的独特分离的重要性，它首先允许MMIO的转发。如果没有这一点，即使有物理设备存在，也不可能进行初始记录，因为底层硬件平台不能完全模拟。

## 5.讨论
为了有效地组合和编排不同的框架，avatar2需要足够通用，以支持具有不同设计理念、执行原语和作用域的各种框架。尽管我们认为通用到足以支持每个动态二进制分析框架是不可行的，但我们相信我们对目标、协议和端点的抽象和区分使各种框架成为avatar2的潜在目标。

实际上，我们设计avatar2是为了使添加新目标的实现开销尽可能简单。要添加新目标，分析人员首先需要确定与关联端点通信的协议实例。如果不能通过已经存在的协议控制端点，则附加协议的实现将需要大部分工作。然而，我们相信，通过为基于GDB和qemu的目标提供协议实现，已经有相当数量的潜在端点可以集成到avatar2中，而无需添加新的协议。一旦选择了正确的协议，就可以编写实际的目标类，它需要为特定于目标的功能提供接口，并提供初始化函数，该函数设置端点并将不同的协议连接到端点。

该框架的主要目标之一是使流行的动态二进制分析框架能够与嵌入式设备固件进行互操作。虽然三个示例中有两个是针对嵌入式设备的，但它们都依赖于JTAG接口的存在。不幸的是，在分析现实世界的硬件时，这样的接口并不总是可用的。但是，即使在这些情况下，avatar2也可以与这些硬件实例一起使用，例如，如果可以直接在设备上启动gdbserver，或者可以在运行时注入GDB存根，例如使用引导加载程序。然而，这些存根高度依赖于被分析目标的体系结构，很难以通用的方式抽象出来。虽然这样的存根已经存在于一些目标，但是，存根目前还不是avatar2当前版本的一部分，但是我们计划在将来提供这样的调试器作为动态可加载插件。

当嵌入式设备不通过MMIO通信，而是触发中断(例如，在新数据到达时)时，对嵌入式设备提出了额外的挑战。Avatar2在一些硬件上提供了对转发中断的实验性支持。然而，缺乏中断处理的通用性是该框架的一个限制。实际上，中断被触发和服务的方式与发生中断的硬件是紧密耦合的。因此，需要通过使用专门的协议来调度中断，从而以每个目标的方式实现中断。

## 6.讨论
尽管据我们所知，avatar2是第一次尝试以通用的方式灵活地结合调试器、模拟器和动态二进制分析框架，但一些工具已经被用于解决avatar2中也处理的特定子问题。

首先，一些现有的工具嵌入或集成了其他第三方工具。例如，Driller[25]也将angr[24]与AFL[30]结合起来，以从符号执行和模糊测试的优势中获益。类似地，FrankenPSE[28]允许在PySymEmu[13](一个符号执行工具)和GRR Fuzzer[26]之间共享快照。不幸的是，在撰写本文时，还没有提供FrankenPSE的开源版本，这使得与其他方法进行直接比较变得困难。

独立地，angr最近部署了模块化设计理念，允许在符号执行框架内交换不同的部分。因此，可以在框架中插入不同的执行引擎、中间表示(Intermediate Representation, IR)或约束求解器。

另一个受益于外部项目的工具的例子是radare2[19]。尽管它的核心是逆向工程框架，但由于自定义IR，它简化了代码仿真。然而，它被设计为能够控制各种调试器，并提供GDB和WinDBG的实现。除此之外，基于社区的插件正在将Miasm[10]等框架或Unicorn[20]等模拟器集成到radare2生态系统中。虽然这就像angr一样，已经实现了强大的分析功能，但是这个特定的工具，连同它最初的目的，是最重要的。

除了互连独立目标之外，其他工具也采用了解耦执行和内存的方法，例如surrogate[17]和Prospect[16]，它们都使用内存转发来分析嵌入式设备。因此，Prospect着重于通过转发访问设备驱动程序的系统调用来允许对基于Linux的目标进行部分模拟。另一方面，代理使用自定义硬件以高带宽转发MMIO访问，有效地实现了对嵌入式设备的近实时分析。

此外，许多具有不同用途的现代动态二进制分析框架都是基于QEMU的。例如，DECAF[15]专注于实时的虚拟机内省和污染，而PANDA[12]提供了记录和重播执行的原语，而高级分析插件则在执行的可重复重播期间使用。另一方面，Rev.ng[11]以恢复控制流图和功能边界作为后续分析的基本块而闻名，而S2E[5]则通过符号和集合执行的能力扩展了全系统仿真。此外，即使是分析嵌入式设备固件而不需要实际设备的工具也基于QEMU，例如Firmadyne[4]，它模拟了基于linux的固件的通用内核，以及LuaQEMU[7]，它在Lua中提供了硬件板的原型。

虽然所有这些工具都有自己的长处，而且已经相当强大，但它们在设计时很少考虑到互操作性。因此，这些工具中的大多数都为了自己的目的对QEMU进行了大量修改，从而有效地拒绝了与其他工具的轻松集成。另一方面，由avatar2完成的QEMU补丁是极简的，并且集中在代码库中，这使得这些工具很容易集成为avatar2的未来目标。

## 7.结论
在本文中，我们展示了能够互连流行的动态二进制分析框架的必要性。我们介绍了avatar2，这是一个基于python的工具，旨在能够动态编排各种框架、调试器和模拟器。该框架的初始实现已经能够在GDB、QEMU、angr、OpenOCD和PANDA之间编排执行，并提供易于使用的接口，将状态从一个工具传输到另一个工具。我们用三个用例展示了avatar2的多功能性，这绝不是框架提供的全部可能性。更具体地说，我们使用avatar2作为动态插桩工具来复制HARVEY，一个新颖的PLC rootkit，我们通过结合GDB和angr在Firefox中发现了一个人为插入的错误，我们通过使用PANDA和OpenOCD记录了一个嵌入式设备固件的执行情况。

总而言之，我们相信avatar2可以极大地提高动态二进制分析的技术水平，因为现在不同工具的优势可以组合到单个分析场景中。

## Appendix A
![](Avatar2-A%20Multi-target%20Orchestration%20Platform/Pasted%20image%2020230808113812.png)

![](Avatar2-A%20Multi-target%20Orchestration%20Platform/image-20231129102013905.png)

