# AFLNET: A Greybox Fuzzer for Network Protocols


# 翻译
## 摘要
服务器模糊测试很困难。与简单的命令行工具不同，服务器具有巨大的状态空间，只有使用定义良好的输入消息序列才能有效地遍历该状态空间。有效的序列在协议中指定。在本文中，我们提出了AFLNET，这是第一个用于协议实现的灰盒模糊器。与现有的协议模糊器不同，AFLNET采用突变方法并使用状态反馈来指导模糊过程。AFLNET以服务器和实际客户端之间记录的消息交换语料库作为种子，不需要协议规范或消息语法。AFLNET充当客户机，重播发送到服务器的原始消息序列的变体，并保留那些有效地增加代码或状态空间覆盖的变体。为了标识由消息序列执行的服务器状态，AFLNET使用服务器的响应代码。从这个反馈中，AFLNET识别状态空间中的渐进区域，并系统地转向这些区域。用AFLNET对两种流行的协议实现进行的案例研究表明，与最先进的技术相比，AFLNET的性能有了实质性的提升。AFLNET发现了两个新的CVE，它们被归类为临界(CVSS得分为Critical 9.8)。

## 1.引言
在协议实现中发现安全缺陷是至关重要的。协议由面向Internet的服务器使用，以有效可靠的方式相互通信或与客户端通信，协议指定确切的可以在两个或多个在线方之间交换的消息的序列和结构。然而，这种从世界任何地方与服务器通信的能力为远程代码执行攻击提供了充足的机会。攻击者甚至不需要对机器进行物理访问，例如，著名的“心脏出血”漏洞是OpenSSL中的一个安全漏洞，它是SSL/TLS协议的一种实现，承诺安全通信。

然而，发现协议实现中的漏洞也很困难。最先进的模糊测试方法存在一些挑战，如基于覆盖率的灰盒模糊(CGF)[1]，[2]和有状态黑盒模糊(SBF)[3]，[4]。首先，服务器是有状态的和消息驱动的。它从客户端获取一系列消息(又称请求)，处理这些消息并发送适当的响应。然而，实现的协议可能不完全对应于指定的协议。其次，服务器的响应依赖于当前消息和由早期消息控制的当前内部服务器状态。同时，普通的CGF fuzzers(如AFL及其扩展[5]-[7])既不知道服务器状态信息，也不知道要发送的消息的所需结构或顺序。这些CGF fuzzers主要设计用于测试无状态程序(例如，文件处理程序)，这些程序为当前输入产生输出，其中没有维护或考虑内部状态。

开发人员只有使用当前CGF方法来模糊协议实现的变通解决方案。他们需要编写测试harness来对被测服务器(SUT)的特定程序状态进行单元测试[2]，或者将消息序列连接到文件中，并将它们作为种子来执行正常的突变文件模糊测试[1]。这两种方法都有一些缺点。虽然单元测试在某些特定的程序状态下是有效的，但它可能无法彻底测试几个程序状态之间的交互/转换。此外，编写新的测试harness来维护正确的程序状态并避免误报通常需要大量的工作。重要的是，它不适用于端到端模糊测试，以测试源代码可能不可用的整个服务器。

处理连接的文件会导致查找bug的效率低下和无效。首先，对于每次模糊迭代，需要对整个选定的种子文件进行突变。给定一个文件f，该文件是通过连接从m1到mn的消息序列构建的，CGF会变异整个文件f，并平等地对待所有消息。假设消息mi是最有趣的消息(例如，探索它会导致更高的代码覆盖率和潜在的错误)，CGF在处理mi之前重复将无兴趣的消息m1突变为mi-1，并且它没有关注mi的知识。其次，由于缺乏状态转换信息，CGF可能会产生许多无效的消息序列，这些消息序列很可能被SUT拒绝。事实上，AFL的用户非常清楚这些限制，因此他们向其开发者组发送了几个请求和问题[8]。图1显示了AFL用户请求有状态模糊测试支持的两个请求。

![](images/Pasted%20image%2020230920200434.png)

由于前面提到的CGF在有状态服务器模糊测试上的局限性，最流行的技术仍然是有状态黑盒模糊测试(SBF)。学术界(如Sulley、BooFuzz[4]、[9])和工业界(如Peach、beSTORM[3]、[10])都开发了一些SBF工具。这些工具以有限状态机或图的形式遍历给定的协议模型，并利用在这些状态上接受的消息的数据模型/语法来生成(语法上有效的)消息序列并对SUT进行压力测试。然而，它们的有效性在很大程度上取决于给定状态模型和数据模型的完整性，这些模型通常是基于开发人员对协议规范的理解和客户端与服务器之间捕获的网络流量样本手动编写的。这些手动提供的模型可能无法正确捕获SUT内部实现的协议。协议规范包含数百页的proseform文本。实现的开发人员可能会误解现有的状态或添加新的状态或转换。此外，像其他黑盒方法一样，SBF没有为进一步的模糊测试保留有趣的测试用例。更具体地说，即使SBF可以产生导致新的有趣状态的测试用例，这些状态还没有在它的状态模型中定义，SBF也不会为进一步的探索保留这些有价值的测试用例。它也不会在运行时更新状态模型。

在这项工作中，我们介绍了AFLNET——第一个有状态CGF (SCGF)工具，以解决当前CGF和SBF方法的上述局限性。AFLNET使自动状态模型推理和覆盖率引导的模糊测试协同工作;模糊测试有助于生成新的消息序列来覆盖新的状态，并使状态模型逐渐更加完整。同时，动态构建的状态模型通过使用保留消息序列的状态覆盖率和代码覆盖率信息，将模糊测试推向更重要的代码部分。我们评估了AFLNET对两个著名协议的实现:文件传输协议(FTP)和实时流协议(RTSP)。我们的初步结果表明，AFLNET在代码覆盖率、状态空间覆盖率和bug查找能力方面的性能大大超过了最先进的技术。AFLNET在RTSP实现中暴露了两个以前未知的安全漏洞(CVE分配)。

我们计划在https://github.com/aflnet/aflnet上发布AFLNET的源代码。

## 2.案例：文件传输协议
我们首先非正式地介绍服务器通信背后的主要概念和本文中使用的术语。服务器是一个可以远程访问的软件系统，例如，通过互联网，客户端是一个软件系统，它使用服务器提供的服务。在我们的设置中，模糊器充当客户机，而服务器充当模糊测试目标。

为了交换信息，两个网络参与者都发送消息。消息是一个独特的数据包，消息序列是消息的向量，消息的有效顺序由协议控制。来自客户机的消息也称为请求，而来自服务器的消息称为响应。每个请求可以推进服务器状态，例如，从初始状态到身份验证。服务器状态是服务器在与客户端通信时的特定状态。

清单1显示了客户机和LightFTP[11]之间根据文件传输协议(FTP)进行的消息交换，LightFTP是一个实现FTP的服务器，也是我们评估的目标之一。从客户机发送的消息序列用红色突出显示。FTP指定客户端必须首先在服务器上验证自己，只有认证通过后，客户端才能发出其他命令(即传输参数命令和服务命令)。对于来自客户端的每个请求消息，FTP服务器用包含状态码的响应消息进行应答(例如，230\[login successful\] 或430\[invalid user/pass\])。响应中的状态码确保客户端请求得到确认，并通知客户端当前的服务器状态。

![](images/Pasted%20image%2020230920202057.png)

## 3.工具设计与实现
我们实现了我们的工具AFLNET作为流行和成功的灰盒模糊器AFL的扩展[1]，[12]。AFLNET的体系结构如图2所示。为了方便与服务器的通信，我们首先启用了套接字网络通信，这是普通AFL不支持的。AFLNET支持两个通道，一个用于发送，一个用于接收来自被测服务器的消息/响应。响应接收通道除了在所有CGF方法中实现的代码覆盖率反馈通道之外，还形成了状态反馈通道。AFLNET使用标准的C Socket API(即connect;poll;send和recv) 来实现此功能。为了确保AFLNET和测试服务器之间的适当同步，我们在请求之间添加了延迟。否则，有些服务器实现在发送和确认响应之前接收到新消息会断开连接。

![](images/Pasted%20image%2020230920202559.png)

AFLNET的输入是包含捕获的网络流量的pcap文件(例如，清单1所示的FTP客户机和FTP服务器之间的请求和响应)。要在pcap文件中记录客户机和服务器之间真实的消息交换，可以使用网络嗅探器(例如tcpdump)。可以使用包分析器提取相关的消息交换。例如，我们使用包分析器Wireshark自动提取FTP请求的序列。

AFLNET使用它的请求序列解析器(Request Sequence Parser)组件来生成消息序列的初始语料库。AFLNET使用特定于协议的消息结构信息，以正确的顺序从捕获的网络流量中提取单个请求。它首先从pcap文件中过滤出响应，以获得客户机请求的trace。然后，它解析过滤的trace，以识别跟踪中每个消息的开始和结束。我们实现了一个轻量级方法，该方法查找给定协议中指定的消息的报头和结束符。例如，每个FTP消息都以一个有效的FTP命令(例如，USER、PASS)开始，并以后跟换行字符(例如，0x0D0A)的回车符结束。此外，SCGF与序列中的每个消息关联相应的服务器状态转换(参见图3)这是通过逐个发送消息和解析响应来完成的。

![](images/Pasted%20image%2020230920203709.png)

状态机学习器(State Machine Learner)接受服务器响应，并用新观察到的状态和转换增强已实现的协议状态机(IPSM)。AFLNET将服务器响应读入字节缓冲区，提取协议中指定的状态码，并确定执行状态(转换)。如果服务器响应中有新的状态码，则添加一个表示新状态的新图节点。

目标状态选择器(Target State Seletor)从IPSM获取信息，以选择AFLNET接下来应该关注的状态。AFLNET使用几种启发式方法，这些方法可以从学习的IPSM中可用的统计数据中计算出来，以帮助目标状态选择器选择下一个状态。例如，为了识别模糊器盲点，即很少执行的状态，它选择状态s的概率与执行s的突变消息序列的比例(#fuzz)成反比。为了最大化发现新状态转换的可能性，AFLNET选择具有更高优先级的状态，这些状态在以前选择时特别成功地增加了代码或状态覆盖率(#paths)。值得注意的是，AFLNET只有在模糊过程工作了足够长的时间以积累统计数据后才开始应用这些启发式方法。开始时，目标状态选择器随机选择目标状态。

一旦选择了目标状态，序列选择器就会从序列语料库中选择可以到达状态的消息序列(即种子输入)。AFL/AFLNET将种子语料库(这里包含消息序列)实现为队列条目的链表。队列条目是包含有关种子输入的相关信息的数据结构。此外，AFLNET维护一个状态语料库，它包括(i)状态条目列表，即包含相关状态信息的数据结构，以及(ii)将状态标识符映射到执行与状态标识符对应的状态的队列条目列表的哈希映射。Sequence Selector利用哈希映射随机选择序列(如队列条目所示)来执行状态。










