2023 Usenix

# 翻译
## 摘要
评估嵌入式系统固件安全性的最新趋势是重新托管，即在虚拟环境中而不是在原始硬件平台上运行固件的艺术。固件重新托管的一个重要用例是动态发现安全漏洞的模糊测试。

然而，最先进的实现受到模拟器引起的高开销的影响，导致执行速度低于最佳水平。我们建议不进行模拟，而是采用近似本地的重新托管:在与目标设备共享指令集族的高性能系统上，将嵌入式固件作为Linux用户空间进程运行。我们通过SAFIREFUZZ实现了这种方法，SAFIREFUZZ是一个吞吐量优化的重新托管和模糊测试框架，适用于ARM Cortex-M固件。SAFIREFUZZ采用单片纯二进制固件映像，并使用高级仿真(HLE)和动态二进制重写，以低开销在功能强大得多的硬件上运行它们。通过复制HALucinator(最先进的基于HLE的二进制固件重托管系统)的实验，我们表明SAFIREFUZZ可以在24小时模糊测试活动期间平均提供690倍的吞吐量增加，同时覆盖多达30%的基本块。

## 1.引言
嵌入式系统已经无处不在。这些专用计算设备用于日常生活的所有领域，例如汽车系统、网络设备、医疗保健机器、智能家居设备等。由于它们之间的联系越来越紧密，保护它们的机密性、完整性和可用性变得越来越重要。与传统计算机相比，嵌入式设备通常不运行一个成熟的操作系统，而是一个单一的软件堆栈，它处理系统的各个方面:内存管理、中断、用户数据处理和硬件交互。这种所谓的设备固件经常将许多复杂的功能(如驱动程序和自定义解析器)暴露给可能受到攻击者控制的外部源，例如通过空中的无线数据，甚至来自TCP数据包。考虑到嵌入式系统和扩展攻击面的重要性，测试其固件的安全性是必不可少的。

安全分析的一种常用方法是模糊测试，这是一种自动化过程，在这种过程中，模糊测试器向目标提供半随机的、可能存在错误的输入，以发现有缺陷的极端情况。由于其有效性，该领域已成为越来越受欢迎的研究课题[41]。最近的重新托管领域通常通过创建虚拟执行环境来模糊嵌入设备的固件[24,47]。为了自动生成被目标接受的输入，现代的模糊器使用关于目标最后一次执行的反馈来选择进一步变异哪些输入。随着每次执行的输入逐渐覆盖更大数量的目标代码，吞吐量自然会下降。由于每个测试用例在目标中花费更多的时间，因此fuzzer每秒可以执行更少的测试用例，这减慢了对状态空间的进一步探索。因此，进一步提高模糊测试效能的一个角度是大幅提高执行速度。在更短的时间内针对相同的输入测试程序，使模糊器有更多的时间进一步探索目标。

在本文中，我们提出了SAFIREFUZZ，这是一种新的高性能的嵌入式二进制ARM固件重托管和模糊测试方法。与之前的工作(例如[20,33,35,46,50])使用通用模拟器重新托管目标固件不同，我们部署了一种我们称之为“近本机重新托管”的技术。我们的方法背后的核心观点是，强大的服务器和桌面ARM计算设备提供的执行模式和指令集与嵌入式系统上的执行模式和指令集非常相似。基于这一观察，我们创建了一个动态二进制重写引擎，以便直接在更强大的系统上运行固件，同时动态地插入模糊插桩工具。为了处理硬件交互，我们遵循HALucinator[20]提出的高级仿真(High-Level Emulation, HLE)方法，用基于HAL的钩子取代硬件交互。

正如我们将展示的那样，与最近的重新托管框架相比，我们的方法显著提高了执行速度，从而提高了模糊测试的效率，并发现了以前未检测到的错误。特别是，我们将SAFIREFUZZ与HALucinator[20](最先进的HLE重新托管方法)和Fuzzware(最近基于外围建模的重新托管方法)进行了比较。我们的评估表明，与HALucinator相比，SAFIREFUZZ可以提供高达690倍的加速，与Fuzzware相比，可以提供高达147倍的加速，从而在24小时的模糊测试运行中额外发现高达30%的基本块。

综上所述，我们做出了以下贡献:
- 我们提出SAFIREFUZZ:一个用于交互式执行嵌入式ARM固件的高性能近本机重托管框架。
- 我们证明了它适用于ARMv7-M二进制固件映像的高效模糊测试。为此，我们将进程内模糊与动态二进制重写技术紧密集成，并结合硬件抽象层(HAL)函数挂钩。
- 我们通过对HALucinator测试套件中的12个固件样本实施模糊测试来评估SAFIREFUZZ，并将其性能与最近的重新托管方法进行比较。我们还从头开始重新托管了两个新样本。我们的评估表明，接近本机的重新托管优于基于通用模拟器构建的重新托管方法。

## 2.背景
### 2.1 嵌入式系统与固件
嵌入式系统的特点是使用固件，固件负责驱动设备的硬件，同时提供更高级别的功能。为了与硬件交互，固件通常使用以下通道之一。

内存映射输入/输出(MMIO)在物理内存中为每个外设分配一个范围。这些范围中的每一个都被划分为MMIO寄存器。访问这些寄存器允许固件直接与其外设交互，例如，从外部源读取数据或打开LED。端口映射输入/输出(Port-Mapped Input/Output, PMIO)的行为类似于MMIO，不同之处在于专门的指令允许通过IO端口进行交互。DMA (Direct Memory Access)允许固件在外设和主存之间传输数据时绕过CPU。在缓慢内存传输的整个过程中，CPU不需要阻塞CPU，只需要通过与专门的DMA控制器外设交互来启动这个过程。外设通过中断指示特定事件的发生(例如，新数据的到达)。基于设备中断控制器的配置，固件然后在指定的中断服务例程(ISR)恢复执行。

### 2.2 ARM Cortex-A/M
ARM是嵌入式系统中最流行的指令集体系结构家族之一[12]。特别是，32位的ARMv7-M和ARMv7-A变体由于其低成本和能源效率而被广泛使用。ARMv7-A针对更复杂的嵌入式系统，具有两种不同的执行模式:在ARM模式下，处理器以4字节对齐的方式执行固定大小为4字节的指令。在Thumb模式下，指令由两个或四个字节组成，由此产生的两个字节对齐允许更密集的代码包装[3]，这有利于资源受限的嵌入式系统。这些模式可以通过分支目标未使用的最低有效位动态切换，而1表示在目标位置以thumb-模式执行，0表示在ARM模式执行。另一方面，ARMv7-M专门针对微控制器，只实现Thumb-v2指令集。

除此之外，最新的指令集家族ARMv8-A和ARMv8-A添加了AArch64扩展，它提供了64位指令集。虽然实现这些系列的cpu通常针对移动和桌面设备，但该扩展提供了在使用64位操作系统或管理程序时在较低异常级别(即EL1和EL2)上以32位模式执行的支持。

### 2.3 模糊测试
模糊测试是一种流行的自动漏洞发现方法，能够发现大量不同的漏洞。这些错误包括(但不限于)内存损坏错误(如缓冲区溢出、双自由度和释放后使用)和逻辑错误(如整数溢出、无限循环甚至竞争条件)。在覆盖引导的模糊测试中，模糊测试者使用执行反馈来确定感兴趣的输入。为此，fuzzer会在编译时(如果源代码可用)或稍后在二进制级别向目标程序添加插桩。插桩将覆盖信息报告给模糊测试引擎，例如，通过在位映射中跟踪已执行的分支。当一个输入生成唯一的覆盖率时，它被添加到模糊语料库中，以便随后对新测试用例的生成进行变异。

## 3.动机
重新托管是嵌入式固件虚拟执行环境的自动创建，它结合了多种方法来克服与模拟嵌入式系统(可能未知的)外围设备相关的挑战[24]。虽然早期的工作依赖于硬件在环仿真来卸载对物理设备的未知访问[35,37,48]，但无硬件重新托管成为实现嵌入式系统覆盖引导模糊测试的事实上的标准[20,25,31,33,40,45,46,51]。

Scharnowski等人[46]将克服由无硬件重托管方法部署的未知外围行为的方法分为三类:(1)高级仿真，(2)基于模式的MMIO建模，以及(3)基于符号执行的方法。第一类旨在通过挂钩硬件抽象层的库函数来消除对虚拟化固件的硬件访问。第二种方法使用启发式方法对MMIO寄存器进行分类，然后使用预定义的模型来响应访问。第三种方法旨在通过符号执行动态地解决推进固件执行的值。此外，最近的研究[52]提出了规范引导的仿真，其中MMIO外设模型来源于数据表和设备文档。

我们在表1中调查了最近的重托管系统，并注意到所有方法都被用于实现固件的模糊活动。然而，我们也观察到，除了Para-Rehosting[38]需要源代码访问外，所有被调查的rehosting系统都依赖于已经存在的模拟器来虚拟化固件。我们假设这是对模糊测试的阻碍，因为现成的模拟器是通用工具，并且从未在设计时考虑过模糊测试。

![](images/Pasted%20image%2020230721163118.png)

实现更快固件模糊检测的途径。仔细查看表1可以得到另一个细节:所有调查的基于仿真的重托管系统要么直接扩展QEMU，要么构建在基于QEMU的仿真器之上。这将QEMU的仿真方法提升为固件重新托管的事实标准。虽然QEMU为各种ISA提供了巨大的可扩展性和支持，但我们认为，仅仅依赖它的仿真功能会导致模糊测试效率的权衡。特别是，在检查最新技术的状态时，我们观察到以下普遍接受的性能障碍:

[R1]二进制提升和重编译。QEMU将客户代码提升到TinyCode，这是它的内部中间表示形式，然后应用插桩和即时(JIT)将每个块编译到主机体系结构。虽然这导致了对各种指令集的支持，但大多数重托管工作只关注于ARM架构。因此，我们认为高吞吐量固件fuzzer可能会考虑其他策略来获得额外的性能，例如直接二进制转换或二进制重写。

[R2]昂贵的内存访问调度。单片固件通常驻留在单个平面地址空间中。然而，QEMU是为部署MMU的更复杂的系统而开发的。为了在所有系统中模拟这一点，它的SoftMMU调度内存访问。这将导致显著的性能开销[17]。能够直接访问客户机内存而不需要间接访问将极大地提高客户机的执行速度，从而提高模糊测试。

[R3]基本块缓存和链。QEMU的核心性能优化之一是能够缓存已经翻译的块，并将多个块的执行链接在一起。然而，这种优化在AFL-QEMU的早期适应中是不可用的[11]。虽然在afl++中进行了主流化[26]，但我们观察到，各种重新托管解决方案是在遗留版本之上开发的，因此缺乏采用严重阻碍了模糊测试的性能。

[R4]缺乏进程内模糊测试。到目前为止，重新托管解决方案在一个单独的进程中运行它们的模糊测试引擎。然而，与在同一进程中嵌入fuzzer的解决方案相比，这会导致不必要的内核交互和上下文切换。

我们注意到，以前的工作已部分解决了一些障碍。例如，FirmWire[33]部署了基本的块缓存和链化优化，Frankstein[45]使用了QEMU的用户模式，从而消除了对SoftMMU的需求。然而，据我们所知，没有先前的工作系统地解决了所有障碍，并探索了高性能固件模糊器的可能性。

## 4.设计
### 4.1 概述
SAFIREFUZZ作为一个高效的重托管和执行引擎，克服了第3节中描述的障碍，用于固件模糊测试。我们提出的方法的核心是一种我们称之为“近原生重新托管”的技术。我们没有通过提升和重新编译来模拟固件(R1)，而是利用某些ARMv8-A内核提供与AArch32和Thumb指令集变体的用户空间兼容性这一事实。因此，我们可以通过二进制插桩直接在功能强大的内核上执行大部分固件代码。当我们在用户空间中镜像嵌入式设备的内存布局时，重写的指令不需要额外的逻辑来调度内存访问，从而规避(R2)。此外，我们的重写方法被优化为缓存已经插桩的块，最大限度地减少引擎开销(R3)。最后，我们将模糊逻辑嵌入到与引擎和重写固件相同的进程空间中，以最大限度地减少与主机操作系统(R4)所需的交互。

在下面，我们将描述SAFIREFUZZ的核心引擎，我们的动态重写方法，以及我们对重新托管挑战的解决方案。

### 4.2 重新托管和重写引擎
SAFIREFUZZ的引擎负责执行目标固件、处理重托管、重写指令和插入模糊插桩。对于处理未知的硬件外设，我们松散地遵循Clements等人[20]的高级仿真方法，因为挂钩相应的HAL很容易嵌入到我们的重写方法中。因此，引擎使用特定于固件的harness。在目标执行开始之前，harness通过在指定入口点重写第一个基本块来初始化内存范围并注册HAL钩子。

该引擎负责按需转换基本块，同时为模糊测试添加插桩，在需要时将执行转移到已注册的钩子，并部署中断近似机制。虽然所有这些任务都是至关重要的，但我们注意到，应该尽可能少地在引擎代码或操作系统中花费时间。因此，引擎只在它们的直接前辈第一次被执行时重写基本块，并保留已插桩的块的缓存。在块的初始重写和执行期间，可能需要多次跳转到引擎。在发出的基本块第一次完全执行后，引擎将消除从该块返回到自身的所有(现在不必要的)跳转。这样，对连续块的重写和分支解析只需发生一次。一次引擎运行的插桩开销是恒定的。

### 4.3 基本块重写
最简单的动态重写方法是指令的就地替换。虽然存在遵循这种方法的解决方案来替换单个指令[22]，但我们认为这在一般情况下是不可能的，特别是对于ARMv7-M，因为替换的指令可能比原始指令大。在顶部，我们需要为插装和挂钩插入额外的指令。这改变了指令之间的相对位置。由于ARM上的许多指令以与pc相关的方式操作，因此不能保证保留跳转目标。虽然使用控制流恢复启发式方法可以计算动态分支的目标和所需的更改[44]，但静态地推断寄存器内容并非易事。因此，我们在运行时动态地插桩二进制文件。由于任何基本块都不会重写超过一次，因此该方法的一次性开销可以忽略不计。我们在算法1中描述了重写过程，并在图1中进一步说明了基本块级别的重写过程。我们的近本机重寄存方法的一个优点是，大多数指令根本不需要重写，因为我们正在使用的Cortex-A内核上的AArch32执行状态与构建固件的Cortex-M之间没有不匹配。Cortex-M处理器使用Thumb-v2指令，其中大多数指令可以在支持AArch32模式的ARMv8-A目标平台上本机执行，没有分歧。pc修改指令和pc相对内存访问是仅有的两类需要重写的指令。这与通常部署的基于处理器仿真的重托管技术形成对比，在这种技术中，一个体系结构的指令在另一个体系结构上执行，所有指令都需要转换。

![](images/Pasted%20image%2020230725170732.png)

![](images/Pasted%20image%2020230725171630.png)

### 4.4 函数钩子
当重写一个新的基本块时，引擎会检查当前地址是否注册了钩子。用户可以提供这样一个用高级编程语言编写的函数。引擎向用户提供的代码发出跳转，然后在块执行时执行。SAFIREFUZZ中的钩子位置在设计上被限制为函数钩子。由于我们更改的所有(寄存器)状态都在执行的固件和用户代码之间共享，因此在利用新目标时，在全指令基础上编写钩子会更加复杂。此外，我们发现函数钩子在所有情况下都足以消除HLE重新托管的硬件交互。这个限制允许我们获得运行时性能，因为我们可以在我们的状态中做出某些假设保存和恢复例程，只要固件遵守通用的ARM调用约定。我们的方法引入的开销很小:上下文保存和恢复，包括跳转到钩子，由五条指令组成。这样的钩子，也称为处理程序，被设计用来模拟固件的一部分的行为。它们在执行期间取代了对硬件抽象层上的函数的调用，从而掩盖了固件中的外设访问。这个过程是基于hle的系统中外围设备管理的核心，而且我们接近原生的方法没有引入任何内在缺陷。通常实现的功能是模拟和处理中断，在模糊测试期间接受外部数据并使其可用于固件，或者用清理内存分配器替换内存分配器以增加安全违规的可观察性。当我们在我们的方法中对HAL上的功能建模时，可以促进跨固件重用。使用相同系统库或为相同微控制器开发的固件映像通常共享公共硬件抽象。哪个固件函数与哪个处理程序挂钩由用户在一个线束内决定(参见5.3)。固件的控制可以看作是代码中领域知识的规范。它们高度特定于特定的处理器或微控制器模型，并且必须处理固件的特性，从设置入口点到提供正确映射的内存。

### 4.5 中断近似
许多嵌入式设备依靠中断来传递信号和处理异步外部事件。例如，SysTick定时器存在于许多ARM微控制器中。单片实时操作系统(RTOS)使用它来轮询MMIO寄存器和调度新任务。因此，我们的重新托管解决方案需要一种模拟中断的方法，以便准确地执行这样的固件。

为此，我们实现了基于时钟的中断。虽然在我们接近本机的场景中，翻译中断并让Cortex-A主机系统处理它们在理论上是可能的，但是嵌入式设备上的中断通常是由外部外设触发的，它们的isr将尝试通过MMIO访问它们，因此在任何情况下都需要重写。以前的重新托管工作已经表明，中断近似足以模拟固件行为[25]，我们认为它有利于模糊测试:我们基于tick的计数器导致更高的确定性，从而导致可再现和可分析的程序痕迹。HALucinator使用与基本块级计数器类似的方法来触发计时器，我们的方法改进了HALucinator，使用间接调用级计数器和手动时钟更新钩子。我们在执行的特定点更新计时器并触发中断。钩住每个基本块会带来不必要的性能开销。

## 5.实现
### 5.1 引擎内部部件
我们使用Rust编程语言实现了SAFIREFUZZ。引擎核心由1481行源代码组成。另外1716行构成了整个实现的HAL处理程序，14个评估目标的harness加起来有2360行。用Capstone进行反汇编[4]。对于要发出的修改指令或新指令的汇编，我们使用Keystone[7]。

引擎处理所有任务，以允许在外部环境中执行固件。因此，它也执行许多模拟器必须处理的任务。

**分支解决**。当引擎重写一个以静态分支结束的基本块时，它会向引擎发出一个回调。在基本块的第一次执行时，这个跳转到引擎(也称为慢路径)被一个静态分支取代，将原始固件地址解析到重写的基本块的新位置。由于这样的分支目标计算只需要执行一次，因此删除跳转到引擎可以减少即将执行的开销。每个基本块只执行一次所有这些慢路径函数，然后跳过它们，这是一种主要的性能优化。

如果指令以非静态可解析的方式直接修改PC，即使用寄存器内容，则引擎需要在运行时解析目标。这些包括BX, BLX和MOV指令与PC作为目标寄存器。在重写的代码范围内解析目标基本块的正确地址的例程执行以下步骤:如果目标地址位于重写的代码范围内，则假定尾调用。然后，我们简单地用1或地址，以确保我们保持在拇指模式，并返回这个地址。否则，执行缓存查找。如果新的基本块还没有被缓存，引擎会重写它。随后，返回被重写块的真实地址。

分支解析函数也是引擎中断近似的锚点之一。中断可以注册为execute-every-nth-tick，其中tick是BLX跳转或手动放置钩子的执行。每次解析动态跳转时，分支计数器都会增加。如果中断是全局启用的，并且任何中断处理程序都注册了，那么如果已经通过了足够的tick，引擎就会触发中断。

跳转表通常编译为从数据段直接加载固定值到PC。当引擎遇到这种LDR PC时，\[…\]指令重写时，它发出一个跳转回引擎。此处理程序函数检查特定负载是否已经解析并缓存。在第一次调用的情况下，新的基本块被重写，并且加载读取的内存位置被新地址覆盖。从引擎返回时，执行原始指令并读取调整后的值，从而正确地调整PC机。ARMv7-M还增加了表分支的特性，使用偏移表产生与pc相关的分支。同样，执行被重定向回引擎，在那里执行表查找并计算相应的偏移量。有了这些信息，目标基本块(如果还没有缓存的话)就会被检测和提升。最后，在0中返回分支目标的地址。在新的基本块中，我们用返回值覆盖堆栈上特定于寄存器的偏移量，使我们能够在恢复执行上下文后控制寄存器内容。我们在附录A.2中提供了关于如何处理进一步的控制流修改指令的更多细节。

**上下文切换**。所有跳转回引擎都需要上下文保存和恢复。在跳转到用户定义的钩子的情况下，例程是最小的:引擎将r1推到堆栈上的r11，并在钩子结束时再次弹出它们。最后，引擎分支回到链接寄存器(LR)。这种方法只会产生可以忽略不计的开销。此外，它允许以比Unicorn等模拟器更自然的方式访问函数参数和返回值。在Unicorn中，钩子必须使用API调用来读写寄存器内容，而我们的框架公开了自然的应用程序二进制接口(ABI)。在解析引擎中的分支目标之前，需要完整的上下文保存。
这包括所有13个通用寄存器，LR以及应用程序状态寄存器(APSR)中的条件标志。

**内存访问**。在分支之后，pc相关内存访问是引擎在将基本块重写到另一个位置时需要修改的第二大指令类。在ARMv7-M中，使用与pc相关的LDR，小数据块通常与从它们加载的基本块共存。由于推断基本块背后的数据段有多大是很重要的，因此在基本块重写期间复制数据是很重要的。因此，我们静态地解析地址，并用来自原始代码站点的绝对负载替换pc相对负载。图2显示了引擎的内存布局。

**缓存**。为了尽量减少在热路径执行期间在引擎内部花费的时间，我们缓存了各种数据点。

用Capstone和Keystone重新组装指令是非常昂贵的。因此，我们尽可能缓存和重用块。一个例子是，当将引用原始代码站点中的位置的分支替换为针对重写块的分支时，会产生宽分支(B.W)。由于机器码指令编码的是偏移量而不是绝对地址，因此它具有很高的重用潜力。将组装好的字节插入到固定大小的数组中，并按所需的偏移量执行查找。像BLX这样的动态分支指令每次都必须得到解析，因为寄存器内容和跳转目标可能会改变。这需要查找，使用固件中的原始地址来检索新代码站点中等效的基本块的位置。由于在这两种情况下，我们的map键都是线性地址空间中的值，并且具有明确定义的上界，因此我们可以使用一个简单的数组作为数据结构。这里，第i个元素包含了原始地址i的重写基本块的地址。这允许我们在一条指令中进行查找。我们不仅为BLX指令的目标存储这样的映射，而且为引擎发出新块的每个地址存储这样的映射。

**处理器缓存维护**。由于我们的引擎不仅会发出一次新指令，还会修改已经发出的基本块，因此我们必须处理ARMv7-A核心的非统一缓存架构。这样的内核为指令和数据访问提供了独立的、不一致的缓存，当涉及到自我修改代码时，可能会导致问题和严重的不一致。虽然可以在运行时覆盖内存中的指令，但处理器仍然可能由于缺少一致性而执行旧的或无效的指令。在每一次指令重写之后，也就是说，在内存中覆盖一条已经至少执行过一次的指令，我们需要在相应的内存范围内使两个缓存失效。这些指令的下一次读取将缓存丢失，处理器将正确地从内存加载新版本。缓存刷新和缓存丢失都是例外。它们对于保证重写方法的一致性是严格必要的，并且在测试期间观察到的开销可以忽略不计。

### 5.2 Fuzzer
我们实现的一个核心构建块是fuzzer。LibAFL[27]提供了突变后端。我们选择它的磁盘语料库来存储输入队列和找到的目标。线束作为我们引擎的入口点，并从模糊器的角度定义固件。首先，它从LibAFL检索模糊测试输入，然后启动单个执行。作为反馈机制，我们使用映射观察者的组合，跟踪覆盖映射的状态(在每个条件分支上更新)，以及执行时间和超时。对于调度，我们采用一种有利于小测试用例的策略。突变是按照AFL的浩劫方法执行的，就像LibAFL中实现的那样。该方法包括位翻转、整数覆盖、块删除和块复制。我们的框架还公开了指定一个令牌文件的选项，模糊器将使用该令牌文件来改变新的输入。AFL中的令牌是特定于领域的字节序列，例如HTML或XML中的标记，便于模糊器生成有意义的输入。LibAFL的Launcher组件结合了所有这些部分，并处理模糊进程的启动和重启。

**覆盖率跟踪**。为了启用覆盖引导的模糊测试，引擎需要跟踪覆盖并使其被模糊测试后端观察到。我们通过在静态位图中设置值来实现非碰撞边缘覆盖跟踪，该位图的地址和大小在编译时已知。为了跟踪覆盖率，引擎在每个条件分支和表分支之后插入一个额外的基本块。对于每个以前未见过的边，SAFIREFUZZ增加一个全局计数器，作为全局位映射的唯一标识符和索引。插入的指令在执行时更新相应的条目。这种方法，新的基本块由七个指令组成，其中只有一个内存访问，最大限度地减少了引入的开销，同时仍然为模糊器提供有意义的见解。我们选择了布尔覆盖率图，而不是点击数方法，以进一步减少开销，因为实验表明，在许多情况下，普通边缘覆盖率甚至优于AFL的默认点击数指标[28]。

**并行性**。LibAFL启动器允许扩展到任意数量的内核。多个模糊测试实例可以自动并行启动，覆盖图等信息可以同步。每个核心运行自己的进程和单独的引擎实例，没有共享缓存。通过这种方式，我们可以避免执行过期或不一致的重写代码视图，这可能会导致一个实例执行当前由另一个实例重写的基本块，而不需要昂贵的缓存一致性认证。

### 5.3 Harnessing
SAFIREFUZZ中的Harnesses是在编译时提供的，并且是用Rust编写的，框架的其余部分也是如此。为了在保持可用性的同时允许灵活的配置，引擎公开了一组接口，开发人员必须实现这些接口，也就是说，引擎可以调用这些函数来处理重新托管过程的各个部分。这包括但不限于一个设置函数，在引擎初始化时调用一次，例如，设置内存段并将固件映像复制到正确的位置，以及一个处理内存恢复和重置计时器和自定义分配器的重置函数。

## 6.评估
在我们的评估中，我们着手回答以下三个研究问题:
- RQ1.SAFIREFUZZ与固件模糊测试的最新技术相比如何?
- RQ2。SAFIREFUZZ的核心性能提升和剩余障碍是什么?
- RQ3。SAFIREFUZZ能否识别以前未知或未检测到的漏洞?

为了回答(RQ1)，我们从之前关于固件安全和重托管的研究中选择了12个固件目标[20,25,30,31,42,51]，并比较了不同配置下SAFIREFUZZ与HALucinator[6]和Fuzzware[46]的模糊测试效果。基于这些结果，我们对SAFIREFUZZ的性能(RQ2)进行了详细分析。最后，为了回答(RQ3)，我们首先讨论SAFIREFUZZ发现的12个固件样本中以前未检测到的错误，然后将我们的方法应用于两个新目标。

除非另有说明，我们在运行64位Ubuntu 18.04的HoneyComb LX2 ARM工作站上执行所有实验。该系统采用16个ARM Cortex-A72内核，时钟速率高达2 GHz, 32 GB DDR4内存，频率为3200 MT/s, 128 GB m.2SSD。
### 6.1 实验设置
**目标选择**。我们根据其在先前研究中的流行程度选择了目标，并特别关注HALucinator[20]，因为这是最新的基于二进制hal的重托管框架。所有选择用于评估的目标都是针对Cortex-M内核编译的。特定的SAFIREFUZZ控制遵循HALucinator的挂钩和实现，以确保在提供相同输入时语义上相同的行为。我们概述了表2中的目标，并在附录A.3中详细介绍了硬件抽象层上四个示例目标的挂钩函数。

![](images/Pasted%20image%2020230810111901.png)

### 6.2 与最先进的比较
### 6.3 性能分析
### 6.4 漏洞
## 7.讨论
## 8.相关工作
**动态二进制重写**。使用动态二进制重写为其他软件创建虚拟执行环境是一个众所周知的概念。例如，最初的VMWare Workstation实现[15]通过系统级x86到x86的转换和敏感操作的捕获和模拟方法为x86系统提供了虚拟化功能。类似地，QEMU[13]允许通过动态二进制转换来模拟不同的硬件平台。然而，这些方法都不是为启用低级固件模糊测试而定制的。设计上可以接受性能上的轻微折衷，并且来自客户机的硬件访问可能需要复杂的模拟后端。相比之下，SAFIREFUZZ的近本机重托管方法允许在功能更强大的主机上运行针对嵌入式ISA变体的代码，只要这两个变体属于同一家族(例如，ARMv6-M和ARMv8-A)。

尽管如此，各种框架探索了用于模糊测试的二进制重写，例如F RIDA的Stalker模式[29]或afl++的Qemu-和Unicorn模式[26]。虽然这些框架的目标是提供优化的重写技术来降低运行时开销，但它们都没有考虑到近本机重新托管的可能性。在应用插桩之前，afl++的Qemu-和Unicorn将二进制代码提升到TCG(它的中间表示)，Frida要求模糊目标的ISA与主机的ISA匹配。

**静态二进制重写**。近年来，人们提出了各种用于模糊测试的静态重写方法。retrowrite[21]、StochFuzz[49]或ZAFL[43]等框架将大部分一次性重写成本转移到静态离线阶段。因此，在运行期间重写被保持在最低限度或完全消除。虽然与基于源代码的工具测试相比，这些方法达到了具有竞争力的性能，但在撰写本文时，这些框架都不支持固件模糊测试。它们都关注x86或AArch64 ISA，并且对目标二进制文件的布局有很强的假设，例如代码和数据段之间的明确区别或与位置无关的代码。我们注意到，这些能够实现高效静态重写的假设很少适用于二进制固件，这就是为什么我们对SAFIREFUZZ采用动态重写方法的原因。

**重托管**。近年来，重新托管[24,47]使各种类型的嵌入式系统能够进行模糊测试，包括基于linux的物联网设备[36,50]，无线芯片组[33,40,45]，以及具有单片固件的深度嵌入式设备[16,20,25,31,38,38,46,51]。SAFIREFUZZ直接从这些框架和原型中获得灵感，特别是从HALucinator[20]和Para-Rehosting[38]等基于hali的重托管方法中获得灵感。然而，与SAFIREFUZZ相比，大多数先前的重托管方法侧重于为目标固件创建仿真环境，而不是研究高效模糊测试解决方案的可能性。

最明显的例外是FirmAFL和Fuzzware。FirmAFL旨在提高基于linux的固件的模糊测试效率，通过使用QEMU的用户模式模拟器对单个应用程序进行模糊测试，同时在需要时选择性地使用全系统仿真来提供额外的运行时上下文。另一方面，Fuzzware针对单片固件，并将fuzzer集成到外围建模过程中，同时使用本地动态符号执行来缩小可能的输入空间。虽然这两种解决方案都提供了对固件模糊测试的补充，但它们都依赖于基于qemu的仿真引擎，并且与SAFIREFUZZ不同，它们没有探索一种低开销的二进制重写替代方法。

在我们工作的同时，MetaEmu[18]和ICICLE[19]旨在通过扩大可重构架构的范围来推进最先进的技术。与SAFIREFUZZ近乎原生的重写相反，这两个框架都使用Ghidra的处理器和指令集定义来自动派生虚拟化的执行环境。MetaEmu还可以同时重新安置和分析多个连接的目标。尽管他们确实关注性能并实现了多个IR优化通道，但他们并没有将自己的方法与之前工作中的实际目标进行基准测试。与SAFIREFUZZ不同的是，它们只在几个微基准测试中表现得略好于Unicorn。虽然ICICLE将重点放在模糊测试上，但他们的主要贡献是有效的与体系结构无关的工具。与SAFIREFUZZ相比，他们的框架——基于即时编译的PCode和SoftMMU——没有从根本上重新思考仿真，并且实现了与Unicorn相当的性能。

## 9.结论
在这项工作中，我们研究了改进二进制固件模糊测试的最新方法的可能性。我们的引擎，称为SAFIREFUZZ，利用HAL级挂钩和动态二进制重写，将低级ARM Cortex-M固件重新托管到更强大的ARM Cortex-A系统上。

我们通过对基于HAL的重新托管方法的最新固件套件实施模糊测试来评估SAFIREFUZZ。我们的性能分析表明，与目前最先进的24小时模糊测试活动相比，SAFIREFUZZ的吞吐量平均提高了690倍，基本块覆盖率提高了30%。

总的来说，SAFIREFUZZ表明，在设计重托管系统时，仿真效率是一个重要因素，其最终目标是模糊测试嵌入式设备固件。我们希望我们工作的见解将成为未来更快的固件fuzzers的基础。

## 可用性
SAFIREFUZZ的源代码，以及所有的评估工具和实验代码，都可以在https://github.com/pr0me/SAFIREFUZZ上公开获得。



