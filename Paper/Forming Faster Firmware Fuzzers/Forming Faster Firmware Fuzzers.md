2023 Usenix

# 翻译
## 摘要
评估嵌入式系统固件安全性的最新趋势是重新托管，即在虚拟环境中而不是在原始硬件平台上运行固件的艺术。固件重新托管的一个重要用例是动态发现安全漏洞的模糊测试。

然而，最先进的实现受到模拟器引起的高开销的影响，导致执行速度低于最佳水平。我们建议不进行模拟，而是采用近似本地的重新托管:在与目标设备共享指令集族的高性能系统上，将嵌入式固件作为Linux用户空间进程运行。我们通过SAFIREFUZZ实现了这种方法，SAFIREFUZZ是一个吞吐量优化的重新托管和模糊测试框架，适用于ARM Cortex-M固件。SAFIREFUZZ采用单片纯二进制固件映像，并使用高级仿真(HLE)和动态二进制重写，以低开销在功能强大得多的硬件上运行它们。通过复制HALucinator(最先进的基于hle的二进制固件重托管系统)的实验，我们表明SAFIREFUZZ可以在24小时模糊测试活动期间平均提供690倍的吞吐量增加，同时覆盖多达30%的基本块。

## 1.引言
嵌入式系统已经无处不在。这些专用计算设备用于日常生活的所有领域，例如汽车系统、网络设备、医疗保健机器、智能家居设备等。由于它们之间的联系越来越紧密，保护它们的机密性、完整性和可用性变得越来越重要。与传统计算机相比，嵌入式设备通常不运行一个成熟的操作系统，而是一个单一的软件堆栈，它处理系统的各个方面:内存管理、中断、用户数据处理和硬件交互。这种所谓的设备固件经常将许多复杂的功能(如驱动程序和自定义解析器)暴露给可能受到攻击者控制的外部源，例如通过空中的无线数据，甚至来自TCP数据包。考虑到嵌入式系统和扩展攻击面的重要性，测试其固件的安全性是必不可少的。

安全分析的一种常用方法是模糊测试，这是一种自动化过程，在这种过程中，模糊测试器向目标提供半随机的、可能存在错误的输入，以发现有缺陷的极端情况。由于其有效性，该领域已成为越来越受欢迎的研究课题[41]。最近的重新托管领域通常通过创建虚拟执行环境来模糊嵌入设备的固件[24,47]。为了自动生成被目标接受的输入，现代的模糊器使用关于目标最后一次执行的反馈来选择进一步变异哪些输入。随着每次执行的输入逐渐覆盖更大数量的目标代码，吞吐量自然会下降。由于每个测试用例在目标中花费更多的时间，因此fuzzer每秒可以执行更少的测试用例，这减慢了对状态空间的进一步探索。因此，进一步提高模糊测试效能的一个角度是大幅提高执行速度。在更短的时间内针对相同的输入测试程序，使模糊器有更多的时间进一步探索目标。

在本文中，我们提出了SAFIREFUZZ，这是一种新的高性能的嵌入式二进制ARM固件重托管和模糊测试方法。与之前的工作(例如[20,33,35,46,50])使用通用模拟器重新托管目标固件不同，我们部署了一种我们称之为“近本机重新托管”的技术。我们的方法背后的核心观点是，强大的服务器和桌面ARM计算设备提供的执行模式和指令集与嵌入式系统上的执行模式和指令集非常相似。基于这一观察，我们创建了一个动态二进制重写引擎，以便直接在更强大的系统上运行固件，同时动态地插入模糊插桩工具。为了处理硬件交互，我们遵循HALucinator[20]提出的高级仿真(High-Level Emulation, HLE)方法，用基于HAL的钩子取代硬件交互。

正如我们将展示的那样，与最近的重新托管框架相比，我们的方法显著提高了执行速度，从而提高了模糊测试的效率，并发现了以前未检测到的错误。特别是，我们将SAFIREFUZZ与HALucinator[20](最先进的HLE重新托管方法)和Fuzzware(最近基于外围建模的重新托管方法)进行了比较。我们的评估表明，与HALucinator相比，SAFIREFUZZ可以提供高达690倍的加速，与Fuzzware相比，可以提供高达147倍的加速，从而在24小时的模糊测试运行中额外发现高达30%的基本块。

综上所述，我们做出了以下贡献:
- 我们提出SAFIREFUZZ:一个用于交互式执行嵌入式ARM固件的高性能近本机重托管框架。
- 我们证明了它适用于ARMv7-M二进制固件映像的高效模糊测试。为此，我们将进程内模糊与动态二进制重写技术紧密集成，并结合硬件抽象层(HAL)函数挂钩。
- 我们通过对HALucinator测试套件中的12个固件样本实施模糊测试来评估SAFIREFUZZ，并将其性能与最近的重新托管方法进行比较。我们还从头开始重新托管了两个新样本。我们的评估表明，接近本机的重新托管优于基于通用模拟器构建的重新托管方法。

## 2.背景
### 2.1 嵌入式系统与固件
嵌入式系统的特点是使用固件，固件负责驱动设备的硬件，同时提供更高级别的功能。为了与硬件交互，固件通常使用以下通道之一。

内存映射输入/输出(MMIO)在物理内存中为每个外设分配一个范围。这些范围中的每一个都被划分为MMIO寄存器。访问这些寄存器允许固件直接与其外设交互，例如，从外部源读取数据或打开LED。端口映射输入/输出(Port-Mapped Input/Output, PMIO)的行为类似于MMIO，不同之处在于专门的指令允许通过IO端口进行交互。DMA (Direct Memory Access)允许固件在外设和主存之间传输数据时绕过CPU。在缓慢内存传输的整个过程中，CPU不需要阻塞CPU，只需要通过与专门的DMA控制器外设交互来启动进程。外设通过中断指示特定事件的发生(例如，新数据的到达)。基于设备中断控制器的配置，固件然后在指定的中断服务例程(ISR)恢复执行。

### 2.2 ARM Cortex-A/M
ARM是嵌入式系统中最流行的指令集体系结构家族之一[12]。特别是，32位的ARMv7-M和ARMv7-A变体由于其低成本和能源效率而被广泛使用。ARMv7-A针对更复杂的嵌入式系统，具有两种不同的执行模式:在ARM模式下，处理器以4字节对齐的方式执行固定大小为4字节的指令。在Thumb模式下，指令由两个或四个字节组成，由此产生的两个字节对齐允许更密集的代码包装[3]，这有利于资源受限的嵌入式系统。这些模式可以通过分支目标未使用的最低有效位动态切换，而1表示在目标位置以thumb-模式执行，0表示在ARM模式执行。另一方面，ARMv7-M专门针对微控制器，只实现Thumb-v2指令集。

除此之外，最新的指令集家族ARMv8-A和ARMv8-A添加了AArch64扩展，它提供了64位指令集。虽然实现这些系列的cpu通常针对移动和桌面设备，但该扩展提供了在使用64位操作系统或管理程序时在较低异常级别(即EL1和EL2)上以32位模式执行的支持。

### 2.3 模糊测试
模糊测试是一种流行的自动漏洞发现方法，能够发现大量不同的漏洞。这些错误包括(但不限于)内存损坏错误(如缓冲区溢出、双自由度和释放后使用)和逻辑错误(如整数溢出、无限循环甚至竞争条件)。在覆盖引导的模糊测试中，模糊测试者使用执行反馈来确定感兴趣的输入。为此，fuzzer会在编译时(如果源代码可用)或稍后在二进制级别向目标程序添加插桩。插桩将覆盖信息报告给模糊测试引擎，例如，通过在位映射中跟踪已执行的分支。当一个输入生成唯一的覆盖率时，它被添加到模糊语料库中，以便随后对新测试用例的生成进行变异。

## 3.动机
重新托管是嵌入式固件虚拟执行环境的自动创建，它结合了多种方法来克服与模拟嵌入式系统(可能未知的)外围设备相关的挑战[24]。虽然早期的工作依赖于硬件在环仿真来卸载对物理设备的未知访问[35,37,48]，但无硬件重新托管成为实现嵌入式系统覆盖引导模糊测试的事实上的标准[20,25,31,33,40,45,46,51]。

Scharnowski等人[46]将克服由无硬件重托管方法部署的未知外围行为的方法分为三类:(1)高级仿真，(2)基于模式的MMIO建模，以及(3)基于符号执行的方法。第一类旨在通过挂钩硬件抽象层的库函数来消除对虚拟化固件的硬件访问。第二种方法使用启发式方法对MMIO寄存器进行分类，然后使用预定义的模型来响应访问。第三种方法旨在通过符号执行动态地解决推进固件执行的值。此外，最近的研究[52]提出了规范引导的仿真，其中MMIO外设模型来源于数据表和设备文档。

我们在表1中调查了最近的重托管系统，并注意到所有方法都被用于实现固件的模糊活动。然而，我们也观察到，除了Para-Rehosting[38]需要源代码访问外，所有被调查的rehosting系统都依赖于已经存在的模拟器来虚拟化固件。我们假设这是对模糊测试的阻碍，因为现成的模拟器是通用工具，并且从未在设计时考虑过模糊测试。

![](images/Pasted%20image%2020230721163118.png)

实现更快固件模糊检测的途径。仔细查看表1可以得到另一个细节:所有调查的基于仿真的重托管系统要么直接扩展QEMU，要么构建在基于QEMU的仿真器之上。这将QEMU的仿真方法提升为固件重新托管的事实标准。虽然QEMU为各种ISA提供了巨大的可扩展性和支持，但我们认为，仅仅依赖它的仿真功能会导致模糊测试效率的权衡。特别是，在检查最新技术的状态时，我们观察到以下普遍接受的性能障碍:

[R1]二进制提升和重编译。QEMU将客户代码提升到TinyCode，这是它的内部中间表示形式，然后应用插桩和即时(JIT)将每个块编译到主机体系结构。虽然这导致了对各种指令集的支持，但大多数重托管工作只关注于ARM架构。因此，我们认为高吞吐量固件fuzzer可能会考虑其他策略来获得额外的性能，例如直接二进制转换或二进制重写。

[R2]昂贵的内存访问调度。单片固件通常驻留在单个平面地址空间中。然而，QEMU是为部署MMU的更复杂的系统而开发的。为了在所有系统中模拟这一点，它的SoftMMU调度内存访问。这将导致显著的性能开销[17]。能够直接访问客户机内存而不需要间接访问将极大地提高客户机的执行速度，从而提高模糊测试。

[R3]基本块缓存和链。QEMU的核心性能优化之一是能够缓存已经翻译的块，并将多个块的执行链接在一起。然而，这种优化在AFL-QEMU的早期适应中是不可用的[11]。虽然在afl++中进行了主流化[26]，但我们观察到，各种重新托管解决方案是在遗留版本之上开发的，因此缺乏采用严重阻碍了模糊测试的性能。

[R4]缺乏进程内模糊测试。到目前为止，重新托管解决方案在一个单独的进程中运行它们的模糊测试引擎。然而，与在同一进程中嵌入fuzzer的解决方案相比，这会导致不必要的内核交互和上下文切换。

我们注意到，以前的工作已部分解决了一些障碍。例如，FirmWire[33]部署了基本的块缓存和链化优化，Frankstein[45]使用了QEMU的用户模式，从而消除了对SoftMMU的需求。然而，据我们所知，没有先前的工作系统地解决了所有障碍，并探索了高性能固件模糊器的可能性。

## 4.设计
### 4.1 概述
SAFIREFUZZ作为一个高效的重托管和执行引擎，克服了第3节中描述的障碍，用于固件模糊测试。我们提出的方法的核心是一种我们称之为“近原生重新托管”的技术。我们没有通过提升和重新编译来模拟固件(R1)，而是利用某些ARMv8-A内核提供与AArch32和Thumb指令集变体的用户空间兼容性这一事实。因此，我们可以通过二进制插桩直接在功能强大的内核上执行大部分固件代码。当我们在用户空间中镜像嵌入式设备的内存布局时，重写的指令不需要额外的逻辑来调度内存访问，从而规避(R2)。此外，我们的重写方法被优化为缓存已经检测的块，最大限度地减少引擎开销(R3)。最后，我们将模糊逻辑嵌入到与引擎和重写固件相同的进程空间中，以最大限度地减少与主机操作系统(R4)所需的交互。

在下面，我们将描述SAFIREFUZZ的核心引擎，我们的动态重写方法，以及我们对重新托管挑战的解决方案。

### 4.2 重新托管和重写引擎
SAFIREFUZZ的引擎负责执行目标固件、处理重托管、重写指令和插入模糊插桩。对于处理未知的硬件外设，我们松散地遵循elements等人[20]的高级仿真方法，因为挂钩相应的HAL很容易嵌入到我们的重写方法中。因此，引擎使用特定于固件的harness。在目标执行开始之前，harness通过在指定入口点重写第一个基本块来初始化内存范围并注册HAL钩子。















