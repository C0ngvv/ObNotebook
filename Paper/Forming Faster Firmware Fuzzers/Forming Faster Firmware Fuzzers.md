2023 Usenix

# 翻译
## 摘要
评估嵌入式系统固件安全性的最新趋势是重新托管，即在虚拟环境中而不是在原始硬件平台上运行固件的艺术。固件重新托管的一个重要用例是动态发现安全漏洞的模糊测试。

然而，最先进的实现受到模拟器引起的高开销的影响，导致执行速度低于最佳水平。我们建议不进行模拟，而是采用近似本地的重新托管:在与目标设备共享指令集族的高性能系统上，将嵌入式固件作为Linux用户空间进程运行。我们通过SAFIREFUZZ实现了这种方法，SAFIREFUZZ是一个吞吐量优化的重新托管和模糊测试框架，适用于ARM Cortex-M固件。SAFIREFUZZ采用单片纯二进制固件映像，并使用高级仿真(HLE)和动态二进制重写，以低开销在功能强大得多的硬件上运行它们。通过复制HALucinator(最先进的基于HLE的二进制固件重托管系统)的实验，我们表明SAFIREFUZZ可以在24小时模糊测试活动期间平均提供690倍的吞吐量增加，同时覆盖多达30%的基本块。

## 1.引言
嵌入式系统已经无处不在。这些专用计算设备用于日常生活的所有领域，例如汽车系统、网络设备、医疗保健机器、智能家居设备等。由于它们之间的联系越来越紧密，保护它们的机密性、完整性和可用性变得越来越重要。与传统计算机相比，嵌入式设备通常不运行一个成熟的操作系统，而是一个单一的软件堆栈，它处理系统的各个方面:内存管理、中断、用户数据处理和硬件交互。这种所谓的设备固件经常将许多复杂的功能(如驱动程序和自定义解析器)暴露给可能受到攻击者控制的外部源，例如通过空中的无线数据，甚至来自TCP数据包。考虑到嵌入式系统和扩展攻击面的重要性，测试其固件的安全性是必不可少的。

安全分析的一种常用方法是模糊测试，这是一种自动化过程，在这种过程中，模糊测试器向目标提供半随机的、可能存在错误的输入，以发现有缺陷的极端情况。由于其有效性，该领域已成为越来越受欢迎的研究课题[41]。最近的重新托管领域通常通过创建虚拟执行环境来模糊嵌入设备的固件[24,47]。为了自动生成被目标接受的输入，现代的模糊器使用关于目标最后一次执行的反馈来选择进一步变异哪些输入。随着每次执行的输入逐渐覆盖更大数量的目标代码，吞吐量自然会下降。由于每个测试用例在目标中花费更多的时间，因此fuzzer每秒可以执行更少的测试用例，这减慢了对状态空间的进一步探索。因此，进一步提高模糊测试效能的一个角度是大幅提高执行速度。在更短的时间内针对相同的输入测试程序，使模糊器有更多的时间进一步探索目标。

在本文中，我们提出了SAFIREFUZZ，这是一种新的高性能的嵌入式二进制ARM固件重托管和模糊测试方法。与之前的工作(例如[20,33,35,46,50])使用通用模拟器重新托管目标固件不同，我们部署了一种我们称之为“近本机重新托管”的技术。我们的方法背后的核心观点是，强大的服务器和桌面ARM计算设备提供的执行模式和指令集与嵌入式系统上的执行模式和指令集非常相似。基于这一观察，我们创建了一个动态二进制重写引擎，以便直接在更强大的系统上运行固件，同时动态地插入模糊插桩工具。为了处理硬件交互，我们遵循HALucinator[20]提出的高级仿真(High-Level Emulation, HLE)方法，用基于HAL的钩子取代硬件交互。

正如我们将展示的那样，与最近的重新托管框架相比，我们的方法显著提高了执行速度，从而提高了模糊测试的效率，并发现了以前未检测到的错误。特别是，我们将SAFIREFUZZ与HALucinator[20](最先进的HLE重新托管方法)和Fuzzware(最近基于外围建模的重新托管方法)进行了比较。我们的评估表明，与HALucinator相比，SAFIREFUZZ可以提供高达690倍的加速，与Fuzzware相比，可以提供高达147倍的加速，从而在24小时的模糊测试运行中额外发现高达30%的基本块。

综上所述，我们做出了以下贡献:
- 我们提出SAFIREFUZZ:一个用于交互式执行嵌入式ARM固件的高性能近本机重托管框架。
- 我们证明了它适用于ARMv7-M二进制固件映像的高效模糊测试。为此，我们将进程内模糊与动态二进制重写技术紧密集成，并结合硬件抽象层(HAL)函数挂钩。
- 我们通过对HALucinator测试套件中的12个固件样本实施模糊测试来评估SAFIREFUZZ，并将其性能与最近的重新托管方法进行比较。我们还从头开始重新托管了两个新样本。我们的评估表明，接近本机的重新托管优于基于通用模拟器构建的重新托管方法。

## 2.背景
### 2.1 嵌入式系统与固件
嵌入式系统的特点是使用固件，固件负责驱动设备的硬件，同时提供更高级别的功能。为了与硬件交互，固件通常使用以下通道之一。

内存映射输入/输出(MMIO)在物理内存中为每个外设分配一个范围。这些范围中的每一个都被划分为MMIO寄存器。访问这些寄存器允许固件直接与其外设交互，例如，从外部源读取数据或打开LED。端口映射输入/输出(Port-Mapped Input/Output, PMIO)的行为类似于MMIO，不同之处在于专门的指令允许通过IO端口进行交互。DMA (Direct Memory Access)允许固件在外设和主存之间传输数据时绕过CPU。在缓慢内存传输的整个过程中，CPU不需要阻塞CPU，只需要通过与专门的DMA控制器外设交互来启动这个过程。外设通过中断指示特定事件的发生(例如，新数据的到达)。基于设备中断控制器的配置，固件然后在指定的中断服务例程(ISR)恢复执行。

### 2.2 ARM Cortex-A/M
ARM是嵌入式系统中最流行的指令集体系结构家族之一[12]。特别是，32位的ARMv7-M和ARMv7-A变体由于其低成本和能源效率而被广泛使用。ARMv7-A针对更复杂的嵌入式系统，具有两种不同的执行模式:在ARM模式下，处理器以4字节对齐的方式执行固定大小为4字节的指令。在Thumb模式下，指令由两个或四个字节组成，由此产生的两个字节对齐允许更密集的代码包装[3]，这有利于资源受限的嵌入式系统。这些模式可以通过分支目标未使用的最低有效位动态切换，而1表示在目标位置以thumb-模式执行，0表示在ARM模式执行。另一方面，ARMv7-M专门针对微控制器，只实现Thumb-v2指令集。

除此之外，最新的指令集家族ARMv8-A和ARMv8-A添加了AArch64扩展，它提供了64位指令集。虽然实现这些系列的cpu通常针对移动和桌面设备，但该扩展提供了在使用64位操作系统或管理程序时在较低异常级别(即EL1和EL2)上以32位模式执行的支持。

### 2.3 模糊测试
模糊测试是一种流行的自动漏洞发现方法，能够发现大量不同的漏洞。这些错误包括(但不限于)内存损坏错误(如缓冲区溢出、双自由度和释放后使用)和逻辑错误(如整数溢出、无限循环甚至竞争条件)。在覆盖引导的模糊测试中，模糊测试者使用执行反馈来确定感兴趣的输入。为此，fuzzer会在编译时(如果源代码可用)或稍后在二进制级别向目标程序添加插桩。插桩将覆盖信息报告给模糊测试引擎，例如，通过在位映射中跟踪已执行的分支。当一个输入生成唯一的覆盖率时，它被添加到模糊语料库中，以便随后对新测试用例的生成进行变异。

## 3.动机
重新托管是嵌入式固件虚拟执行环境的自动创建，它结合了多种方法来克服与模拟嵌入式系统(可能未知的)外围设备相关的挑战[24]。虽然早期的工作依赖于硬件在环仿真来卸载对物理设备的未知访问[35,37,48]，但无硬件重新托管成为实现嵌入式系统覆盖引导模糊测试的事实上的标准[20,25,31,33,40,45,46,51]。

Scharnowski等人[46]将克服由无硬件重托管方法部署的未知外围行为的方法分为三类:(1)高级仿真，(2)基于模式的MMIO建模，以及(3)基于符号执行的方法。第一类旨在通过挂钩硬件抽象层的库函数来消除对虚拟化固件的硬件访问。第二种方法使用启发式方法对MMIO寄存器进行分类，然后使用预定义的模型来响应访问。第三种方法旨在通过符号执行动态地解决推进固件执行的值。此外，最近的研究[52]提出了规范引导的仿真，其中MMIO外设模型来源于数据表和设备文档。

我们在表1中调查了最近的重托管系统，并注意到所有方法都被用于实现固件的模糊活动。然而，我们也观察到，除了Para-Rehosting[38]需要源代码访问外，所有被调查的rehosting系统都依赖于已经存在的模拟器来虚拟化固件。我们假设这是对模糊测试的阻碍，因为现成的模拟器是通用工具，并且从未在设计时考虑过模糊测试。

![](images/Pasted%20image%2020230721163118.png)

实现更快固件模糊检测的途径。仔细查看表1可以得到另一个细节:所有调查的基于仿真的重托管系统要么直接扩展QEMU，要么构建在基于QEMU的仿真器之上。这将QEMU的仿真方法提升为固件重新托管的事实标准。虽然QEMU为各种ISA提供了巨大的可扩展性和支持，但我们认为，仅仅依赖它的仿真功能会导致模糊测试效率的权衡。特别是，在检查最新技术的状态时，我们观察到以下普遍接受的性能障碍:

[R1]二进制提升和重编译。QEMU将客户代码提升到TinyCode，这是它的内部中间表示形式，然后应用插桩和即时(JIT)将每个块编译到主机体系结构。虽然这导致了对各种指令集的支持，但大多数重托管工作只关注于ARM架构。因此，我们认为高吞吐量固件fuzzer可能会考虑其他策略来获得额外的性能，例如直接二进制转换或二进制重写。

[R2]昂贵的内存访问调度。单片固件通常驻留在单个平面地址空间中。然而，QEMU是为部署MMU的更复杂的系统而开发的。为了在所有系统中模拟这一点，它的SoftMMU调度内存访问。这将导致显著的性能开销[17]。能够直接访问客户机内存而不需要间接访问将极大地提高客户机的执行速度，从而提高模糊测试。

[R3]基本块缓存和链。QEMU的核心性能优化之一是能够缓存已经翻译的块，并将多个块的执行链接在一起。然而，这种优化在AFL-QEMU的早期适应中是不可用的[11]。虽然在afl++中进行了主流化[26]，但我们观察到，各种重新托管解决方案是在遗留版本之上开发的，因此缺乏采用严重阻碍了模糊测试的性能。

[R4]缺乏进程内模糊测试。到目前为止，重新托管解决方案在一个单独的进程中运行它们的模糊测试引擎。然而，与在同一进程中嵌入fuzzer的解决方案相比，这会导致不必要的内核交互和上下文切换。

我们注意到，以前的工作已部分解决了一些障碍。例如，FirmWire[33]部署了基本的块缓存和链化优化，Frankstein[45]使用了QEMU的用户模式，从而消除了对SoftMMU的需求。然而，据我们所知，没有先前的工作系统地解决了所有障碍，并探索了高性能固件模糊器的可能性。

## 4.设计
### 4.1 概述
SAFIREFUZZ作为一个高效的重托管和执行引擎，克服了第3节中描述的障碍，用于固件模糊测试。我们提出的方法的核心是一种我们称之为“近原生重新托管”的技术。我们没有通过提升和重新编译来模拟固件(R1)，而是利用某些ARMv8-A内核提供与AArch32和Thumb指令集变体的用户空间兼容性这一事实。因此，我们可以通过二进制插桩直接在功能强大的内核上执行大部分固件代码。当我们在用户空间中镜像嵌入式设备的内存布局时，重写的指令不需要额外的逻辑来调度内存访问，从而规避(R2)。此外，我们的重写方法被优化为缓存已经插桩的块，最大限度地减少引擎开销(R3)。最后，我们将模糊逻辑嵌入到与引擎和重写固件相同的进程空间中，以最大限度地减少与主机操作系统(R4)所需的交互。

在下面，我们将描述SAFIREFUZZ的核心引擎，我们的动态重写方法，以及我们对重新托管挑战的解决方案。

### 4.2 重新托管和重写引擎
SAFIREFUZZ的引擎负责执行目标固件、处理重托管、重写指令和插入模糊插桩。对于处理未知的硬件外设，我们松散地遵循elements等人[20]的高级仿真方法，因为挂钩相应的HAL很容易嵌入到我们的重写方法中。因此，引擎使用特定于固件的harness。在目标执行开始之前，harness通过在指定入口点重写第一个基本块来初始化内存范围并注册HAL钩子。

该引擎负责按需转换基本块，同时为模糊测试添加插桩，在需要时将执行转移到已注册的钩子，并部署中断近似机制。虽然所有这些任务都是至关重要的，但我们注意到，应该尽可能少地在引擎代码或操作系统中花费时间。因此，引擎只在它们的直接前辈第一次被执行时重写基本块，并保留已插桩的块的缓存。在块的初始重写和执行期间，可能需要多次跳转到引擎。在发出的基本块第一次完全执行后，引擎将消除从该块返回到自身的所有(现在不必要的)跳转。这样，对连续块的重写和分支解析只需发生一次。一次引擎运行的插桩开销是恒定的。

### 4.3 基本块重写
最简单的动态重写方法是指令的就地替换。虽然存在遵循这种方法的解决方案来替换单个指令[22]，但我们认为这在一般情况下是不可能的，特别是对于ARMv7-M，因为替换的指令可能比原始指令大。在顶部，我们需要为插装和挂钩插入额外的指令。这改变了指令之间的相对位置。由于ARM上的许多指令以与pc相关的方式操作，因此不能保证保留跳转目标。虽然使用控制流恢复启发式方法可以计算动态分支的目标和所需的更改[44]，但静态地推断寄存器内容并非易事。因此，我们在运行时动态地插桩二进制文件。由于任何基本块都不会重写超过一次，因此该方法的一次性开销可以忽略不计。我们在算法1中描述了重写过程，并在图1中进一步说明了基本块级别的重写过程。我们的近本机重寄存方法的一个优点是，大多数指令根本不需要重写，因为我们正在使用的Cortex-A内核上的AArch32执行状态与构建固件的Cortex-M之间没有不匹配。Cortex-M处理器使用Thumb-v2指令，其中大多数指令可以在支持AArch32模式的ARMv8-A目标平台上本机执行，没有分歧。pc修改指令和pc相对内存访问是仅有的两类需要重写的指令。这与通常部署的基于处理器仿真的重托管技术形成对比，在这种技术中，一个体系结构的指令在另一个体系结构上执行，所有指令都需要转换。

![](images/Pasted%20image%2020230725170732.png)

![](images/Pasted%20image%2020230725171630.png)

### 4.4 函数钩子
当重写一个新的基本块时，引擎会检查当前地址是否注册了钩子。用户可以提供这样一个用高级编程语言编写的函数。引擎向用户提供的代码发出跳转，然后在块执行时执行。SAFIREFUZZ中的钩子位置在设计上被限制为函数钩子。由于我们更改的所有(寄存器)状态都在执行的固件和用户代码之间共享，因此在利用新目标时，在全指令基础上编写钩子会更加复杂。此外，我们发现函数钩子在所有情况下都足以消除HLE重新托管的硬件交互。这个限制允许我们获得运行时性能，因为我们可以在我们的状态中做出某些假设保存和恢复例程，只要固件遵守通用的ARM调用约定。我们的方法引入的开销很小:上下文保存和恢复，包括跳转到钩子，由五条指令组成。这样的钩子，也称为处理程序，被设计用来模拟固件的一部分的行为。它们在执行期间取代了对硬件抽象层上的函数的调用，从而掩盖了固件中的外设访问。这个过程是基于hle的系统中外围设备管理的核心，而且我们接近原生的方法没有引入任何内在缺陷。通常实现的功能是模拟和处理中断，在模糊测试期间接受外部数据并使其可用于固件，或者用清理内存分配器替换内存分配器以增加安全违规的可观察性。当我们在我们的方法中对HAL上的功能建模时，可以促进跨固件重用。使用相同系统库或为相同微控制器开发的固件映像通常共享公共硬件抽象。哪个固件函数与哪个处理程序挂钩由用户在一个线束内决定(参见5.3)。固件的控制可以看作是代码中领域知识的规范。它们高度特定于特定的处理器或微控制器模型，并且必须处理固件的特性，从设置入口点到提供正确映射的内存。

### 4.5 中断近似
许多嵌入式设备依靠中断来传递信号和处理异步外部事件。例如，SysTick定时器存在于许多ARM微控制器中。单片实时操作系统(RTOS)使用它来轮询MMIO寄存器和调度新任务。因此，我们的重新托管解决方案需要一种模拟中断的方法，以便准确地执行这样的固件。

为此，我们实现了基于时钟的中断。虽然在我们接近本机的场景中，翻译中断并让Cortex-A主机系统处理它们在理论上是可能的，但是嵌入式设备上的中断通常是由外部外设触发的，它们的isr将尝试通过MMIO访问它们，因此在任何情况下都需要重写。以前的重新托管工作已经表明，中断近似足以模拟固件行为[25]，我们认为它有利于模糊测试:我们基于tick的计数器导致更高的确定性，从而导致可再现和可分析的程序痕迹。HALucinator使用与基本块级计数器类似的方法来触发计时器，我们的方法改进了HALucinator，使用间接调用级计数器和手动时钟更新钩子。我们在执行的特定点更新计时器并触发中断。钩住每个基本块会带来不必要的性能开销。

## 5.实现
### 5.1 引擎内部部件
我们使用Rust编程语言实现了SAFIREFUZZ。引擎核心由1481行源代码组成。另外1716行构成了整个实现的HAL处理程序，14个评估目标的线束加起来有2360行。用Capstone进行拆卸[4]。对于要发出的修改指令或新指令的汇编，我们使用Keystone[7]。

引擎处理所有任务，以允许在外部环境中执行固件。因此，它也执行许多模拟器必须处理的任务。

分支机构解决。当引擎重写一个以静态分支结束的基本块时，它会向引擎发出一个回调。在基本块的第一次执行时，这个跳转到引擎(也称为慢路径)被一个静态分支取代，将原始固件地址解析到重写的基本块的新位置。由于这样的分支目标计算只需要执行一次，因此删除跳转到引擎可以减少即将执行的开销。每个基本块只执行一次所有这些慢路径函数，然后跳过它们，这是一种主要的性能优化。

## 9.结论
在这项工作中，我们研究了改进二进制固件模糊测试的最新方法的可能性。我们的引擎，称为SAFIREFUZZ，利用HAL级挂钩和动态二进制重写，将低级ARM Cortex-M固件重新托管到更强大的ARM Cortex-A系统上。

我们通过对基于HAL的重新托管方法的最新固件套件实施模糊测试来评估SAFIREFUZZ。我们的性能分析表明，与目前最先进的24小时模糊测试活动相比，SAFIREFUZZ的吞吐量平均提高了690倍，基本块覆盖率提高了30%。

总的来说，SAFIREFUZZ表明，在设计重托管系统时，仿真效率是一个重要因素，其最终目标是模糊测试嵌入式设备固件。我们希望我们工作的见解将成为未来更快的固件fuzzers的基础。

## 可用性
SAFIREFUZZ的源代码，以及所有的评估工具和实验代码，都可以在https://github.com/pr0me/SAFIREFUZZ上公开获得。



