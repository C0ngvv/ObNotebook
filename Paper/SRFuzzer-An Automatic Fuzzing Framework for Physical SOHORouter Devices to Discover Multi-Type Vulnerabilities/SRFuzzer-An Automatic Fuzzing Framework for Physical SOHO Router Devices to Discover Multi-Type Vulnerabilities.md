# SRFuzzer: An Automatic Fuzzing Framework for Physical SOHO Router Devices to Discover Multi-Type Vulnerabilities
![](images/Pasted%20image%2020231010083547.png)
2019 ACSAC

# 翻译
## 摘要
SOHO (small office/home office)路由器为终端设备接入Internet提供服务，在网络空间中扮演着重要的角色。不幸的是，这些路由器普遍存在安全漏洞，特别是在web服务器模块中，极大地危害了最终用户。为了发现这些漏洞，对SOHO路由器的web服务器模块进行模糊测试是最流行的解决方案。然而，由于缺乏输入规范、缺乏路由器内部运行状态、缺乏测试环境恢复机制等原因，其有效性受到限制。此外，模糊测试通常只报告内存损坏漏洞，而无法发现其他漏洞，例如基于web的漏洞。

在本文中，我们提出了一个解决方案SRFuzzer来解决这些问题。它是一个完全自动化的模糊测试框架，用于测试物理SOHO设备。它利用KEY-VALUE数据模型和CONF-READ通信模型两种输入语义模型，连续有效地生成测试用例，并通过电源管理自动恢复测试环境。它还协调多种突变规则和多种监控机制，触发多种类型的漏洞。据我们所知，这是SOHO路由器的第一个全流程全自动模糊测试框架。我们在5家厂商的10台流行路由器上运行了SRFuzzer。总共发现了208个独特的异常行为，其中97个已被确认为零日漏洞。实验结果表明，SRFuzzer在发现的漏洞类型和数量方面优于最先进的解决方案。

关键字：模糊测试，IoT，自动化漏洞检测，数据不一致

## 1.引言
越来越多的终端设备，如笔记本电脑、平板电脑、智能手机、智能家居设备和可穿戴设备，被用于社交生活。它们通常通过小型办公室和家庭办公室(SOHO)路由器连接到互联网。SOHO路由器将终端用户与外部互联网隔离开来[15]，处理终端用户的全部流量，处于突出地位。SOHO路由器的安全性比以往任何时候都更加重要。

不幸的是，SOHO路由器普遍存在安全漏洞[4]，[29]。根据最近的一份报告[6]，83%的流行路由器包含易受攻击的代码。这些漏洞是攻击者利用的主要目标之一。2018年，Cisco Talos发现针对Linksys、MikroTik、NETGEAR和TP-Link网络设备的恶意软件VPNFilter，这些设备都是SOHO路由器，在至少54个国家感染了至少50万台设备[5]。此外，领先的漏洞获取平台Zerodium[3]在2018年增加了对路由器的需求。因此，发现SOHO路由器的漏洞就显得尤为重要。

SOHO路由器的典型架构如图1的右侧所示。SOHO路由器作为网络设备，为接入它的终端设备提供路由等网络服务。更重要的是，由于缺乏用户界面(例如键盘、视频、鼠标)，它还利用web服务进行管理和配置。这些web服务由一些广泛使用的协议提供，例如超文本传输协议(HTTP)。本文将这些协议称为管理协议。

![](images/Pasted%20image%2020231010090004.png)

典型的管理协议是通过在原始设备中嵌入web服务器(后端)来实现的。通常，不同路由器中的web服务器是由设备供应商定制的，因此更容易受到攻击。最近的研究[12]，[15]，[11]表明，大多数被识别的SOHO路由器漏洞都与web服务有关，例如PHP服务器端脚本中的命令注入漏洞和处理移动应用程序web请求时的内存破坏漏洞。因此，本文也着重于发现SOHO路由器web服务器的漏洞

模糊测试(即模糊测试)被认为是一种发现漏洞的强大技术。然而，除了基于应用程序的模糊测试框架IoTFuzzer[11]外，对SOHO路由器web服务器的模糊测试(FWSR)研究很少。该方法借助可控制设备的移动APP程序逻辑，生成有意义的测试用例，触发设备bug。虽然它部分解决了FWSR的问题，但总的来说，FWSR仍然具有挑战性。

**挑战1:模糊专用系统**

SOHO路由器作为嵌入式设备，其功能是专用的，不容易扩展。因此，在测试过程中无法直接获取设备内部的运行状态，在测试过程中使设备卡住，也很难恢复其正常运行状态。这使得FWSR难以持续有效地进行。虽然基于仿真的模糊测试是一种很有前途的获取内部执行信息来指导模糊测试的方法，但它在全系统模式下对各种路由器的仿真受到限制。(见第6节)

**挑战2:分析输入语义**

web服务器的输入遵循标准协议，如超文本传输协议(HyperText Transfer Protocol, HTTP)，但其内部编码交换信息的数据在路由器之间格式各异。如果不调查内部数据和信息交换过程的格式，FWSR在代码覆盖方面是无效的。

**挑战3:发现多类型漏洞**

如上所述，web服务器几乎是由供应商从前端到后端定制的。因此，FWSR不仅应该发现web漏洞，如命令注入和跨站点脚本，还应该发现内存损坏。不幸的是，不同类型的漏洞需要由不同的有效载荷触发，并且需要通过不同的方法进行监控。这些要求使得FWSR的设计更加困难。

**我们的方法**

在本文中，我们提出了一个基于物理设备的FWSR自动模糊测试框架来解决上述挑战。通过自动生成种子和自动功率控制，连续驱动模糊过程。为了对输入语义建模，它利用两个模型来约束测试用例，即，KEY-VALUE数据模型(简称K-V模型)来描述请求的内部数据格式，以及CONF-READ通信模型(简称C-R模型)来描述请求的时间序列。此外，我们的框架协调了不同的突变规则和多种监控机制，有效触发了内存破坏、命令注入、跨站脚本攻击和信息泄露等四类漏洞。据我们所知，它是FWSR的第一个全流程全自动框架。此外，通过收集web请求和监控运行状态的一点人工努力，它可以胜过全自动模糊测试。

首先，为了自动生成种子，我们的框架采用基于爬虫的方法，从运行设备自动收集web请求头和请求内容[20]。同时，为了使设备从“僵尸”状态恢复，我们增加了一个基于Wi-Fi插头的电源控制模块，当设备卡住时强制重启。此外，我们的框架直接测试物理设备。设计决策是通用的和实用的，因为它不需要模拟固件，模拟固件对许多路由器来说是不可行的。

其次，我们的框架可以触发更深层次的bug，而无需固件逆向工程或插桩(反馈引导模糊技术[43]所需要的)。该框架利用K-V和C-R模型分别对数据格式和请求序列进行精确建模，从而对实际输入进行变异。通过K-V模型，我们能够区分值的数据类型，并分配不同的突变规则。通过C-R模型，我们可以构建多阶段通信，在一定的运行状态下触发bug。

第三，针对不同类型的漏洞，我们将其归纳为数据不一致漏洞。为了发现它们，我们将突变与监测结合起来。更具体地说，我们设计了六个突变规则和三个监测机制。当对给定类型的漏洞进行模糊测试时，我们选择适当的突变规则和监视机制。

我们已经实现了SRFuzzer解决方案的原型，并将其部署在现实环境中。为了评估其有效性和普遍性，我们在5家厂商的10台流行路由器上运行了SRFuzzer。得益于全面的新监控方法，我们获得了208个独特的异常行为。几乎一半的异常行为被确认为属于上述四种漏洞类型的101个独特问题。在向相应厂商负责地披露漏洞后，我们共获得了97个分配的ID，即43个CVE ID, 52个PSV ID和2个CNVD ID。

**贡献**。本文的贡献如下:

- 我们提出了一个全自动模糊测试框架来发现FWSR的各种漏洞。我们通过产生种子和自动恢复装置的方式来持续激励模糊测试。
- 我们设计了KEY-VALUE数据模型和CONF-READ通信模型，揭示了漏洞发生的根本原因，指导了漏洞的突变，并将6条突变规则与3种监控机制相协调，提高了漏洞发现的有效性。
- 我们实现了一个原型SRFuzzer，并在10个真实的SOHO路由器上对其进行了评估。总共在208个独特的异常行为中发现了101个已确认的问题，其中97个已被供应商确认为零日漏洞。结果表明，SRFuzzer在漏洞发现能力方面优于最先进的解决方案。

本文组织如下:第2节介绍了我们克服挑战的动机和见解。第3节概述了SRFuzzer并描述了详细的设计。第4节介绍了实验和评价。我们的框架和相关工作的缺点将在第5节和第6节中讨论。最后，我们在第七节进行总结。

## 2.动机
SRFuzzer的设计目标是为FWSR构建一个自动模糊测试框架，并尽可能多地发现漏洞。基于固件仿真构建框架是很简单的。然而，由于各种专用组件内置路由器的多样性，这种解决方案通常是非常困难的。我们认为，这将是一个通用的框架，自动模糊物理SOHO路由器直接，虽然它仍然具有挑战性。

在本节中，我们首先介绍我们关注的漏洞以及我们环境的假设。然后，我们总结了在对真实世界的路由器进行自动模糊测试时所面临的设计挑战。基于C-R和K-V模型分析了路由器漏洞的根本原因，并结合实例进行了分析。

### 2.1 范围和假设
除了网络服务外，为了管理和配置，还将web服务嵌入到SOHO路由器中。它们通常由标准协议提供，包括超文本传输协议(HTTP)、简单对象访问协议(SOAP)、通用即插即用协议(UPnP)等。这些协议由供应商实现，用于设置Wi-Fi密码、查找终端设备等。我们将这些协议称为管理协议，本文主要讨论HTTP协议。此外，我们假设SOHO路由器使用内置的WAN/LAN web服务，而不是移动到web服务[11]作为其默认设置。

SOHO路由器典型的管理协议实现由前端、后端和数据库三个主要部分组成。前端显示路由器的当前设置，并指导用户进行配置。后端解析从前端接收的请求并配置相关服务。数据库将当前配置存储在几个地方，例如NVRAM、数据库和配置文件。图2以CONF和READ操作的形式描述了这些部件的工作流程。

![](images/Pasted%20image%2020231010102830.png)

图2还显示了工作流中四种典型的漏洞类型。内存损坏和命令注入的漏洞通常发生在后端，而XSS通常发生在前端。前端和后端都可能出现信息泄露漏洞。不同类型的漏洞可以由不同的原因触发，例如，内存损坏通常是由于用户的输入处理不当而触发的。本文中的信息披露是指未经适当许可而访问具有特权的数据。另外两个漏洞是常见的web漏洞，大多数XSS问题都是存储在路由器中的XSS。

### 2.2 自动化整个模糊测试过程
实现FWSR自动化最重要的步骤是输入生成和运行恢复。

如上所述，web服务器的实现在不同的设备供应商之间是不同的，这意味着对每个服务器的请求格式也不同。由于难以采用一般的基于生成的模糊方法，我们选择了基于突变的模糊方法。为了自动收集种子，这是基于突变的模糊算法所必需的，我们设计了一个爬虫来获取尽可能多的请求。同时，应该小心处理与web服务的交互，以保持服务器的运行。这些请求根据特定的规则(将在2.3节中讨论)发生变化，并被馈送到物理SOHO路由器。

一旦特定的测试用例导致服务器失败，SRFuzzer应该观察到发生的情况，并将模糊测试驱动到下一个测试中。通常，在标准计算机系统上对软件进行模糊测试时，重新启动或恢复崩溃的进程相对来说是微不足道的。相反，在没有人为干扰的情况下，复位或重新启动卡住的SOHO路由器并不容易。路由器在模糊处理过程中陷入“僵尸”状态主要有两个原因。首先，当web服务器的进程被一个错误的请求崩溃时，可能没有响应被发送回来。其次，某些设备的自我保护机制会在某些特殊情况下禁止访问web服务器。

为了自动重启web服务器，我们利用电源控制设备来管理SOHO路由器。具体来说，我们使用了现在广泛使用的智能插头。每个智能插头都为路由器供电，并由SRFuzzer控制。它通过Wi-Fi连接到SRFuzzer。一旦SRFuzzer监测到卡住的路由器，它就会通过插头的内部API发送插头重启命令，从而重启设备。然后，WEB服务器可以从崩溃状态中恢复。

### 2.3 深度模糊测试
覆盖引导的模糊测试技术，如AFL[43]，在很大程度上增强了传统的基于突变的模糊测试。由于对代码插装的要求，它们对于现实世界的专用设备是不可行的。此外，路由器漏洞的根本原因是请求处理过程中的数据不一致，这使得这些技术很难提高FWSR的有效性。我们设计了KEY-VALUE数据模型和CONF-READ通信模型来描述请求的语义，即请求内部数据的格式和不同请求之间的关系，并指导突变规则的设计。文中给出了一个动机案例，以更具体的方式说明这些模型。

**激励的例子**。为了说明突变规则的设计挑战，我们提供了一个通过HTTP请求配置网络时间协议(NTP)的过程。图1的左半部分显示了一般流程，图3显示了与该流程相关的后端处理过程。

![](images/Pasted%20image%2020231010090004.png)

![](images/Pasted%20image%2020231010104454.png)

配置路由器的NTP选项通常有三个步骤:(i)路由器管理员发送一个HTTP GET请求，通过URL访问配置网页，例如“http://192.1 68.0.1/apply.cgi/NTP_debug.htm”。他/她还获得了ntpserver1的当前域名，该域名由图3中第9-13行所示的read_ntpserver1()使用。我们称这个过程为READ操作。(ii)管理员通过HTTP POST请求修改域名。ntpserver1的新域名通过后端过程conf_ntpserver1()提交并存储到数据库中。我们称这个过程为CONF操作。(iii)他/她检查新提交的域名是否被另一个READ操作正确配置。

**KEY-VALUE数据模型**。假设配置过程现在处于CONF操作中，原始请求显示在图4的上半部分。后端处理请求如图3的第3、6、7行所示，并出现命令注入问题。函数conf_ntpserver1()将从请求中匹配字符串“ntpserver1”，然后获得域名。域名被用作/usr/bin/config命令的参数，该命令将由system()依次执行。但是，如果请求包含像“ntpserver1=;reboot;”这样的字符串，则会有命令注入，并且在执行/usr/bin/config命令后会调用shell命令“reboot;”。

![](images/Pasted%20image%2020231010105452.png)

触发此漏洞的输入需要两个条件，即“ntpserver1=”字符串保持不变，config命令格式保持有效。因此，在这种情况下，对原始请求执行随机突变以生成测试用例可能是没有意义的。

为了在READ和CONF操作中生成有意义的测试用例，我们设计了KEY-VALUE数据模型来描述单个请求上的约束。每个请求都应该由键值对(简称k-v对)组成，其中键代表变量名，如“ntpserver1”，并且保持不变。该值可以被赋给变量，因此它应该与键的类型要求一致。例如，如果某个键需要输入“域名”，则该值应该精确为域名。虽然原始请求可能采用其他数据格式，例如:Json和xml，模型仍然可以很好地工作。

我们通过根据值标记k-v对上的属性来描述键和值之间的一致性。我们总结了三种类型的属性:数字、固定字符串和可变字符串。这些属性指导k-v对值的变化。因此，在从原始请求中解析k-v对并标记它们之后，可以更有效地生成种子。

CONF-READ通信模型。图3中显示的另一个漏洞是基于堆栈的溢出。这个溢出存在于函数read_ntpserver1()的第12行，它在使用ntp之前不检查它的长度。需要注意的是，ntp的值是在函数conf_ntpserver1()的第3行设置的，它的长度约束与变量info的长度不一致。因此，当从数据库读取格式不正确的域名时，可能会触发该漏洞，该数据库在第7行中设置，长度在0x50和0x80之间。

在这种情况下，单个请求不足以触发漏洞，因此我们设计了CONF-READ通信模型，形成多请求测试输入。该模型由两个相关操作组成，即CONF操作和READ操作。在CONF操作中构造设置或修改设备配置的请求，在READ操作中构造获取相应配置的请求。

吸取的教训。根据对图2中的配置工作流的分析和激励示例，我们将漏洞的根本原因归结为数据不一致。与key ntpserver1不一致的value会导致CONF操作触发命令注入。同时，conf_ntpserver1()和read_ntpserver1()之间的长度不一致导致在READ操作时触发内存损坏。通过将K-V模型与C-R模型耦合，SRFuzzer可以揭示K-V配对数据和时间相关请求中的数据不一致性。因此，它能够检测到SOHO路由器web服务器的深层漏洞。

### 2.4 发现多种类型漏洞
在这个模糊测试框架中，在CONF或READ操作中发现和触发多种类型的漏洞是必要的，但也是困难的。如2.3节所述，我们可以根据K-V模型设计各种变异规则。特别是对于带有“可变字符串”属性的值，我们设计了不同的突变规则，分别触发溢出、空指针解引用、命令注入和存储XSS的异常行为。此外，我们建立了不同类型的通信来触发在CONF或READ操作中发生的漏洞。

设备一旦触发漏洞，就会出现后端崩溃、响应异常或执行意外命令等异常行为。对于后端漏洞的监控，仅使用最常用的专用设备监控方法活性检测[32]是不够的。该方法仅通过检查连接状态来监视异常行为。实际上，正常的连接状态(如HTTP中的状态码200)并不总是表示正常的行为，例如，触发注入的命令执行也可以返回正确的连接状态。

我们设计了两种通用的监视机制来捕捉异常行为，即基于响应的监视器和基于代理的监视器。基于响应的监视器不仅检查连接状态，还检查可能包含额外信息的响应内容。基于代理的监视器接收来自目标路由器的网络访问。受[11]结论的启发，我们还设计了一种可选的基于信号的监视器。它可以捕获更多的内存损坏(即静默内存损坏[32])，代价是将编译后的可执行文件植入设备。通过将突变规则与监控机制耦合，可以检测出多种类型的漏洞。

## 3.详细设计
在本节中，我们给出了SRFuzzer的详细设计。如图5所示，SRFuzzer由五个协调工作的模块组成。一旦连接到路由器，它就会通过种子生成器模块收集有效的种子。然后，它将种子输入mutator模块，以根据各种突变规则生成突变请求。最后，SRFuzzer通过突变器、监视器和电源控制模块的协作来触发和监控异常行为。

![](images/Pasted%20image%2020231010151337.png)

（1）种子生成器。为了生成用于突变的初始测试用例，即种子，种子生成器通过Request Collector子模块收集原始请求，并将它们解析为k-v对。然后用属性标记所有k-v对，这可以指导以后的突变。Request Collector子模块由两部分组成，一个是通用爬虫(默认设置)，用于自动收集请求，另一个是可选的被动爬虫(通过与用户交互收集更多请求)。

（2）Mutator。Mutator通过两个子模块突变选择器(Mutation Selector)和模式选择器(Pattern Selector)的合作，为SOHO路由器生成突变请求。在K-V模型的指导下，根据K-V对的属性和被发现的漏洞类型，选择变异规则并应用于每个K-V对的值。在Pattern Selector子模块中，请求的类型和顺序是基于C-R模型决定的。模式选择器可以生成一个请求，其类型为CONF操作或READ操作。同时，它也可以生成一系列请求，例如，在CONF操作之后的READ操作。

（3）Monitor。为了与Mutator模块紧密协作并监视更多异常行为，monitor模块由两个公共监视器组成，一个基于响应的监视器和一个基于代理的监视器。基于响应的漏洞通常可以监控三种类型的漏洞，即内存损坏、XSS和信息泄露。需要注意的是，对于信息泄露漏洞，它监视没有足够访问权限的目标URL的响应。基于代理的监视器用于命令注入和XSS漏洞。此外，还提供了一个可选的基于信号的监视器，用于捕获更深层次的内存损坏。它是基于ptrace系统调用开发的，可以监控SIGSEGV和SIGABRT等信号。

(4)电源控制。为了对物理路由器进行连续模糊测试，引入了电源控制模块。它由一个智能插头支持，以控制设备的功率。该模块由Monitor模块控制。如果后端服务陷入“僵尸”状态，即没有响应，将向插头发送控制命令，设备将重新启动。

(5)配置。为了提高模糊测试效率，我们还为各个模块提供了自定义配置。所有这些配置都是可选的。我们为通用爬虫配置缺省门户的IP地址。我们还为具有可变字符串属性的值提供了突变增强技术，以触发更多异常行为。为了简化基于信号的监视器的部署，我们开发了一个路由器的植入工具包。通过这个工具包，我们可以将基于信号的监视器自动放置到设备中。

### 3.1 种子生成器
这个模块的目的是为下面的模糊测试生成种子。我们使用Request Generator收集原始请求，然后将它们存储到Request Database中。最后，我们利用Key-Value解析器将请求解析为带有属性标记的k-v对。

正如我们在2.3节中提到的，典型的CONF操作是web通信的第二步，如图4所示。Request Collector子模块旨在重复此步骤，并捕获两个爬虫程序的原始请求。默认情况下，SRFuzzer使用通用爬虫自动收集请求。然而，被动爬虫可以改善收集效果。

一般的爬虫使用默认URL作为输入，然后通过解析网页的输入元素自动填充网页。同时，它识别页面的所有url，然后像传统的爬虫一样递归地填充它们。它还将请求存储到请求数据库中。如果在爬行过程中发生交互，例如提供特定信息，SRFuzzer会从预定义的数据库中随机选择数据继续爬行。

被动爬虫是一个半自动的工具包，它打开一个网页，等待用户输入来填充网页。在提交配置后，被动爬虫将请求存储到请求数据库中，并为下一个网页做准备。这种爬虫通常用于从用户输入的网页(如登录页面)生成种子。

此外，为了尽可能多地收集原始请求并方便稍后的属性标记过程，这两个爬虫会对同一个web页面进行10次填充。

如前所述，K-V模型以细粒度的方式描述管理协议。然而，我们可以从k-v对中挖掘更多信息以进行更深入的模糊分析。KEY-VALUE解析器分析原始请求并将它们分成k-v对。同时，根据k-v对的值对其属性进行标注。

后端的值处理过程中有两个特性。首先，该值通常作为可变字符串处理，后端解析关键信息以构建相关配置。其次，总是有一些有效性检查，例如判断一个值是数字还是固定字符串。因此，如果固定字符串发生了变化，则无法通过检查，并且受检查保护的代码变得不可访问。因此，我们将k-v对标记为三个类型属性，即数字、固定字符串和可变字符串。k-v对的属性决定了应用于k-v对的变异规则。默认情况下，所有k-v对都标有属性“可变字符串”。算法1给出了k-v对的属性标注过程。

![](images/Pasted%20image%2020231010191736.png)

总之，Seed Generator将每个唯一的原始请求转换为几个种子。每个种子包含URL和一组数据元组，每个元组包含一个键、一个值和属性。图4显示了从原始请求到种子的转换过程。

### 3.2 变异
从2.3节可知，触发漏洞的最关键因素是值的变异。构建突变规则有两个指导。首先，漏洞的根本原因是数据不一致，特别是变量字符串，所以如何改变每个k-v元组的值更重要。其次，不同类型的漏洞之间存在明显差异，突变规则应根据漏洞类型触发异常行为。

算法2给出了每个种子的变异算法。我们将元组和URL的变异分开，因为同时变异它们的效率很低。为了变异种子，我们从每个种子中随机选择一些元组。根据每个元组的属性，用相应的变异规则对其值进行变异。数字和固定字符串属性的突变规则很简单，而对于可变字符串，则有四种突变规则来触发不同类型的异常行为:

(1) 对于缓冲区溢出:为了触发溢出漏洞，该框架通常会将原始值重复几次。如果键为空值，则使用从预定义数据库中选择的随机有效负载数来分配键。

(2)对于null指针解引用:对于非空值的键，本框架提供空值，触发潜在的null指针解引用漏洞。

(3)对于命令注入:为了配合基于代理的监视器，SRFuzzer使用基于ping或wget等内置工具的畸形有效负载构造值。如果触发命令注入，这些有效负载将连接到外部基于代理的监视器，该监视器包含一个代理服务器。如果这个监视器捕捉到从路由器发送的请求，它将收集有关异常行为的详细信息。它还可以帮助有效地定位漏洞，以便进行后续分析。

(4)对于存储XSS:有两条规则来构造XSS的有效载荷。最常见的有效负载包含用于弹出消息框的格式错误的JavaScript代码。如果基于响应的监视器捕获到包含“xss_”字符串前缀的消息框，则记录异常并定位漏洞元组。为基于代理的监视器构建的另一个有效负载类似于命令注入规则，例如，"\<script>(new Image()).src= "http://PROXY_SERVER/MUTATION_KEY_INFO/" \</script>"。

![](images/Pasted%20image%2020231010191754.png)

对于变量字符串的所有突变规则，我们还使用特殊字符，如“;”、“$”、空白字符和各种引号，以触发更多异常行为。这些特殊字符可以帮助绕过后端中的有效性检查。例如，inet_addr(const char \*cp)函数只提取字符串中第一个空格之前的部分，检查是否为合法的IP地址。因此，“IP+空格+附加字符串”形式的值会被错误地认为是有效的IP地址。对于第3条和第4条突变规则，我们将键编码为突变值，以帮助定位确切的k-v对。

对于URL突变，该框架生成的URL包含特殊路径或敏感文件路径，如“/etc/passwd”或“/etc/shadow”，在模糊测试时超出了权限。如果可以使用正常响应访问格式不正确的URL，则基于响应的监视器将将其报告为异常行为。

表1显示了如何将这些规则应用于图4中所示的激励示例。原值为“http://DEVICE_IP/apply.cgi?/NTP_debug.htm”和“time.test1.com”。

![](images/Pasted%20image%2020231010193016.png)

### 3.3 触发和监控异常行为
设备常用的模糊检测方法是在发送突变报文后监测响应状态。在这个过程中总是有一个通信。然而，它只对C-R模型的CONF操作中出现的漏洞有用。我们还需要触发READ操作中出现的漏洞。为了克服这个限制，我们在CONF操作之后立即触发READ操作。我们还分离了请求阶段和监视方法。并且，在每个通信周期结束后，我们将CONF操作回滚到初始值。

正如我们在2.4节中提到的，因为“活动检查”仅限于响应的有效信息，它几乎不能监视各种类型的漏洞，也不能捕获更深层次的异常行为，比如子进程中发生的内存损坏。为了弥补其局限性，我们将活动性检查扩展为基于响应的监视器。此外，我们还设计了基于代理的监控器和基于信号的监控器，进一步提高了监控性能。图6显示了三种典型的监视机制及其监视范围。

![](images/Pasted%20image%2020231010194654.png)

(1)基于响应的监控器:除了活动性检查外，分析通信的响应内容可以监控在前端触发的XSS问题。我们为CONF操作期间发生变化的每个键制作有效负载，并在分离的READ操作期间分析响应内容。然后我们就可以很容易地找到触发异常行为的关键因素。此外，还可以通过判断响应状态来监控信息披露。

(2)基于代理的监控:针对命令注入和XSS问题，Mutator模块制作畸形载荷请求外部路由器的服务器。我们在路由器可以接近的局域网中建立一个监控服务器。因此，当路由器访问监控服务器时，我们可以检测命令注入和XSS问题。通过与精心制作的有效负载合作，基于代理的监视器可以有效地定位易受攻击的URL和触发异常行为的关键k-v对。

(3)基于信号的监控:对于内存损坏，最常见的信号是SIGSEGV和SIGABRT。这两个信号总是在进程时出现，即使子进程崩溃。因此，监控这些信号可以捕捉到更多的真阳性异常行为，减少误报。对于基于linux的路由器，我们可以开发基于ptrace系统调用的监控。

尽管基于信号的监视器可以比基于响应的监视器更广泛和准确地监视内存损坏，但它需要将二进制文件植入路由器的许可，这并非总是如此。因此，只有满足权限要求的设备才能利用此监视器。获取此权限有三种方式，即通过调试shell、利用命令注入等已知漏洞、连接内置串口。我们还开发了一个植入工具包，可以自动将可执行文件放入设备中。

因为三个监视器单独工作，我们必须为它们同步请求和异常行为。我们为每个请求和每个异常行为记录时间戳，以确保请求与异常行为相关。
## 4.实验和评估
### 4.1 实现
我们已经用大约12000行Python代码和500行C代码实现了自动模糊测试框架。

对于Seed Generator模块，我们使用Selenium实现了一个通用爬虫和一个被动爬虫[35]。对于Monitor模块，我们分别实现了三种类型的监视器。具体来说，基于信号的监视器采用strace[39]用C语言实现，尽可能利用设备特性、已知漏洞或串口植入设备。它作为静态链接的二进制文件与Buildroot[8]交叉编译。现在，它支持多种架构，包括x86、x86-64、ARM32 (LE)、ARM32 (BE)、MIPS32 (BE)和MIPS32 (LE)。

为了在设备挂起时重新启动设备，SRFuzzer首先通过尝试反复建立与目标设备的TCP连接来监视设备状态。如果多次不能正常建立TCP连接，则通过Power Control模块重启设备。我们基于Mi Smart Plug[2]，借助python-miio[34]协议实现了该模块。

### 4.2 实验设置
