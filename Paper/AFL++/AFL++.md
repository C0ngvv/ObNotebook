# AFL++: Combining Incremental Steps of Fuzzing Research
2020年
## 摘要
在本文中，我们提出了afl++，一个社区驱动的开源工具，它包含了最先进的模糊研究，使研究具有可比性，可重复性，可组合性，最重要的是可用性。它提供了各种新颖的特性，例如自定义突变API，能够在许多阶段扩展模糊处理过程。有了它，有经验的安全测试人员也可以编写针对特定目标的变异程序。我们希望afl++成为一种新的基准工具，不仅适用于当前，而且适用于未来的研究，因为它可以快速测试新技术，不仅可以评估单一技术与最新技术的有效性，还可以与其他技术相结合。本文给出了一个精心挑选的模糊技术的评价，揭示了这样一个事实，即每一种新的模糊方法都可以提高某些目标的性能-它降低了其他目标的性能。这是一个洞察未来的模糊研究应该在他们的评估中考虑。

## 1.引言
模糊的研究是一个蓬勃发展的领域。Fuzzing以完全自动化的方式发现各种bug。近年来，Fuzztesting在信息安全社区引起了极大的兴趣，并在不同领域引发了进步。在Shoshitaishvili等人进行的测试中，符号辅助模糊识别的漏洞几乎是符号执行[39]的三倍。

旨在改进模糊化的开发技术的数量增长了[28]——有时甚至没有完整的功能代码。此外，模糊技术通常是正交和独立开发的，因此将它们结合起来可能是一个漫长的过程。工业界和OSS社区很难决定哪些研究值得关注。相反，他们可能会坚持基本的设置，即使现代研究可以更快地为他们的目标找到更多的错误。另一方面，研究人员自己可能很难评估他们的新工具，并且可能发现自己无法将功能与解决模糊中不同但相关问题的兼容技术结合起来——例如为他们的突变子选择最近的种子调度。一个新的反馈概念可能无法充分发挥其潜力，如果它不能与现有的技术相结合，解决其他问题——比如克服困难的比较指令——由于缺乏统计数据而减少论文研究的影响。

在本文中，我们试图通过提高广泛可用的、有研究支持的模糊化标准，并为研究人员提供可扩展的API来解决这些问题。我们提出了一种新的模糊框架，afl++。未来的研究可以使用afl++作为新的基线。它使研究人员有可能评估他们的建议与afl++中已经实现的最先进的正交特性的组合，并大大减少了实现工作。与此同时，它为行业专业人员提供了大量易于使用的功能，这些功能改编自前沿研究，可以极大地改善fuzzing活动的结果。afl++是由Zalewski[47]设计的流行覆盖引导fuzzer AFL的一个重新设计的分支，它已被证明是学术界和工业界的坚实基础。

之所以选择AFL作为基础，是因为在这个项目开始的时候，它已经有18个月没有维护了，而与此同时，有很多社区补丁和学术分支可用。因此，这提供了一个完美的开端。这对于LIBFUZZER和HONGGFUZZ来说是不可能的，因为它们仍然被积极维护，相比之下仍然没有享受重大的分叉和增强(ENTROPIC[9]和Vranken的增强[41]是显著的例外)。

虽然afl++一开始只是AFL的补丁和分支的集合，但随着时间的推移，我们重新实现了非基于AFL的研究，如REDQUEEN[5]，以及对AFL的研究级扩展，使它们可以用于afl++的生产。然后，我们在这个最先进的技术之上添加了新的功能，这也将在本文中讨论。

总而言之，这篇论文将对一年来活跃的、开源的模糊化研究给出深刻的见解，讨论经验教训，并讨论新颖的自定义突变API，这是一种实现新颖模糊化研究的方法。

### 1.1 贡献
1. 我们提出afl++，将最近的模糊研究纳入一个可用的工具。
2. 我们讨论afl++的新颖的自定义突变API，这是一种可行的、经得起未来检验的实现和结合未来研究的方法。
3. 使用afl++，我们相互评估所包含的技术和特性的选择。我们展示了每种技术是如何依赖于目标的——这对未来的研究非常有意义。

afl++和所有相关工件都是开源软件，可在GitHub上获得:https://github.com/AFLplusplus 。本研究的测试用例可在FuzzBench[22]上获得。

## 2.最先进的
美国Fuzzy Lop (AFL)[47]是有史以来使用最广泛、最成功的覆盖制导模糊机之一。它是目前各种模糊相关出版物的基准。在本节中，我们将讨论AFL和过去几年所做的研究，以深入改进这种模糊器的具体方面，但尽可能简洁。本节中解释的概念与afl++直接相关，将在第3节中介绍。

### 2.1 American Fuzzy Lop
AFL是一种变异的、覆盖率引导的模糊器。它改变了一组测试用例，以达到程序中以前未探索的点。当这种情况发生时，触发新覆盖的测试用例被保存为测试用例队列的一部分。

#### 2.1.2 覆盖率指导的反馈
AFL的覆盖反馈是一种混合度量，将边缘覆盖与在一次运行中各自边缘执行的次数相结合。这个计数是2的幂，以避免路径爆炸。一个输入被认为是有趣的(即保存到队列中)，如果它为一条边探索了至少一个新桶。在执行过程中，这些桶或点击数(hitcounts)被记录到共享位图(bitmap)中，其中每个字节代表一条边。这个地图的大小是有限的，所以碰撞是可能的。AFL使用加权最小集覆盖的近似来维持一组有利的测试用例-就覆盖而言-以速度和大小为权重。

使用覆盖反馈AFL还尝试，对于队列中的每个测试用例，减少测试用例的大小，提高目标的速度，同时在称为修剪的阶段保持不变的覆盖率。

#### 2.1.2 变异
AFL的突变可分为确定性(deterministic)和浩劫(havoc)两类。确定性阶段包括测试用例内容上的单个确定性突变，比如位翻转、添加、用一组公共感兴趣的值(例如-1、INT_MAX，…)的整数替换等等。在havoc中，突变是随机堆叠的，也包括对测试用例大小的更改(例如添加或删除输入的部分)。此外，在稍后的阶段，AFL可能会将两个测试用例合并为一个，并在所谓的拼接(splicing)阶段应用破坏。

#### 2.1.3 Forkserver
为了避免execve()的开销，AFL使用所谓的forkserver。fuzzer将一个forkserver注入目标，通过IPC机制控制。每当AFL需要执行一个测试用例时，它就写入输入，然后告诉目标fork自己。子进程将执行测试用例，父进程等待这个时候。forkserver也可以稍后在目标中分叉。在这种情况下，fuzzer不需要每次运行昂贵的初始化和启动例程。

#### 2.1.4 持续模式
持久模式(persistent mode)极大地提高了性能。因为fork()是已知的瓶颈，对于持久模式，目标不会对每个测试用例进行fork。相反，循环可以修补到目标中，每次迭代执行一个测试用例。为了工作，每次迭代都需要造成最小的状态更改。

### 2.2 智能调度
现代的覆盖率引导模糊器可以实现不同的优先级算法来调度模糊管道中的各种元素。调度器的目标通常是通过智能的测试用例选择来提高总体覆盖率和错误检测。

#### 2.2.1 AFLFast
Böhme等人的FLFAST\[11\]表明需要强调低频路径，以探索更多的分支和发现更多的bug。对AFL开发的几个改进不仅强调了公共路径，目的是暴露额外的程序行为。他们强调了两个问题:
1. 为了强调低频路径，模糊器应该以什么顺序挑选种子?
2. 我们能否调整每个种子产生的输入量(能量)?

作者通过一组新颖的搜索策略解决了第一个问题，通过引入六种功率调度来计算模糊过程中收集的参数的能量。

#### 2.2.2 MOpt
MOPT[25]作为种子调度的一个横向问题，引入了突变调度。在这项工作中，Lyu等人使用自定义粒子群优化算法探索了赋予变异算子不同概率的可能性。这种优化提高了fuzzer快速发现覆盖范围的能力。在他们AFL的补丁中，作者将模糊阶段分为以下两个模块。Pilot，一个评估操作人员的模块，根据有效性分配概率。编码模块生成突变，将试验期间发现的概率考虑在内。

### 2.3 绕过障碍
传统上，覆盖引导的模糊器会遇到阻碍探索其背后代码的障碍。典型的障碍是较大的比较，如字符串和校验和检查。为了解决这个问题，人们进行了一系列的研究。

#### 2.3.1 LAF-Intel
LAF-INTEL[2]是一项旨在绕过硬多字节比较的工作，通过将它们拆分为多个单字节比较。这样，这些比较可以一个字节一个字节地传递，覆盖引导的模糊器接收每个部分的反馈。最初的实现是一组LLVM传递，分隔整数比较，但当在编译时知道其中一个参数时，也会调用字符串比较函数，如strcmp。LAFIntel详细介绍：







## Questions
What is a **baseline tool**?
What is IPC?
What is Persistent Mode？