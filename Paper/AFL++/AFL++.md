# AFL++: Combining Incremental Steps of Fuzzing Research
2020年
## 摘要
在本文中，我们提出了afl++，一个社区驱动的开源工具，它包含了最先进的模糊研究，使研究具有可比性，可重复性，可组合性，最重要的是可用性。它提供了各种新颖的特性，例如自定义突变API，能够在许多阶段扩展模糊处理过程。有了它，有经验的安全测试人员也可以编写针对特定目标的变异程序。我们希望afl++成为一种新的基准工具，不仅适用于当前，而且适用于未来的研究，因为它可以快速测试新技术，不仅可以评估单一技术与最新技术的有效性，还可以与其他技术相结合。本文给出了一个精心挑选的模糊技术的评价，揭示了这样一个事实，即每一种新的模糊方法都可以提高某些目标的性能-它降低了其他目标的性能。这是一个洞察未来的模糊研究应该在他们的评估中考虑。

## 1.引言
模糊的研究是一个蓬勃发展的领域。Fuzzing以完全自动化的方式发现各种bug。近年来，Fuzztesting在信息安全社区引起了极大的兴趣，并在不同领域引发了进步。在Shoshitaishvili等人进行的测试中，符号辅助模糊识别的漏洞几乎是符号执行[39]的三倍。

旨在改进模糊化的开发技术的数量增长了[28]——有时甚至没有完整的功能代码。此外，模糊技术通常是正交和独立开发的，因此将它们结合起来可能是一个漫长的过程。工业界和OSS社区很难决定哪些研究值得关注。相反，他们可能会坚持基本的设置，即使现代研究可以更快地为他们的目标找到更多的错误。另一方面，研究人员自己可能很难评估他们的新工具，并且可能发现自己无法将功能与解决模糊中不同但相关问题的兼容技术结合起来——例如为他们的突变子选择最近的种子调度。一个新的反馈概念可能无法充分发挥其潜力，如果它不能与现有的技术相结合，解决其他问题——比如克服困难的比较指令——由于缺乏统计数据而减少论文研究的影响。

在本文中，我们试图通过提高广泛可用的、有研究支持的模糊化标准，并为研究人员提供可扩展的API来解决这些问题。我们提出了一种新的模糊框架，afl++。未来的研究可以使用afl++作为新的基线。它使研究人员有可能评估他们的建议与afl++中已经实现的最先进的正交特性的组合，并大大减少了实现工作。与此同时，它为行业专业人员提供了大量易于使用的功能，这些功能改编自前沿研究，可以极大地改善fuzzing活动的结果。afl++是由Zalewski[47]设计的流行覆盖引导fuzzer AFL的一个重新设计的分支，它已被证明是学术界和工业界的坚实基础。

之所以选择AFL作为基础，是因为在这个项目开始的时候，它已经有18个月没有维护了，而与此同时，有很多社区补丁和学术分支可用。因此，这提供了一个完美的开端。这对于LIBFUZZER和HONGGFUZZ来说是不可能的，因为它们仍然被积极维护，相比之下仍然没有享受重大的分叉和增强(ENTROPIC[9]和Vranken的增强[41]是显著的例外)。

虽然afl++一开始只是AFL的补丁和分支的集合，但随着时间的推移，我们重新实现了非基于AFL的研究，如REDQUEEN[5]，以及对AFL的研究级扩展，使它们可以用于afl++的生产。然后，我们在这个最先进的技术之上添加了新的功能，这也将在本文中讨论。

总而言之，这篇论文将对一年来活跃的、开源的模糊化研究给出深刻的见解，讨论经验教训，并讨论新颖的自定义突变API，这是一种实现新颖模糊化研究的方法。

### 1.1 贡献
1. 我们提出afl++，将最近的模糊研究纳入一个可用的工具。
2. 我们讨论afl++的新颖的自定义突变API，这是一种可行的、经得起未来检验的实现和结合未来研究的方法。
3. 使用afl++，我们相互评估所包含的技术和特性的选择。我们展示了每种技术是如何依赖于目标的——这对未来的研究非常有意义。

afl++和所有相关工件都是开源软件，可在GitHub上获得:https://github.com/AFLplusplus 。本研究的测试用例可在FuzzBench[22]上获得。

## 2.最先进的
美国Fuzzy Lop (AFL)[47]是有史以来使用最广泛、最成功的覆盖制导模糊机之一。它是目前各种模糊相关出版物的基准。在本节中，我们将讨论AFL和过去几年所做的研究，以深入改进这种模糊器的具体方面，但尽可能简洁。本节中解释的概念与afl++直接相关，将在第3节中介绍。

### 2.1 American Fuzzy Lop
AFL是一种变异的、覆盖率引导的模糊器。它改变了一组测试用例，以达到程序中以前未探索的点。当这种情况发生时，触发新覆盖的测试用例被保存为测试用例队列的一部分。

#### 2.1.2 覆盖率指导的反馈
AFL的覆盖反馈是一种混合度量，将边缘覆盖与在一次运行中各自边缘执行的次数相结合。这个计数是2的幂，以避免路径爆炸。一个输入被认为是有趣的(即保存到队列中)，如果它为一条边探索了至少一个新桶。在执行过程中，这些桶或点击数(hitcounts)被记录到共享位图(bitmap)中，其中每个字节代表一条边。这个地图的大小是有限的，所以碰撞是可能的。AFL使用加权最小集覆盖的近似来维持一组有利的测试用例-就覆盖而言-以速度和大小为权重。

使用覆盖反馈AFL还尝试，对于队列中的每个测试用例，减少测试用例的大小，提高目标的速度，同时在称为修剪的阶段保持不变的覆盖率。

#### 2.1.2 变异
AFL的突变可分为确定性(deterministic)和浩劫(havoc)两类。确定性阶段包括测试用例内容上的单个确定性突变，比如位翻转、添加、用一组公共感兴趣的值(例如-1、INT_MAX，…)的整数替换等等。在havoc中，突变是随机堆叠的，也包括对测试用例大小的更改(例如添加或删除输入的部分)。此外，在稍后的阶段，AFL可能会将两个测试用例合并为一个，并在所谓的拼接(splicing)阶段应用破坏。

#### 2.1.3 Forkserver
为了避免execve()的开销，AFL使用所谓的forkserver。fuzzer将一个forkserver注入目标，通过IPC机制控制。每当AFL需要执行一个测试用例时，它就写入输入，然后告诉目标fork自己。子进程将执行测试用例，父进程等待这个时候。forkserver也可以稍后在目标中分叉。在这种情况下，fuzzer不需要每次运行昂贵的初始化和启动例程。

#### 2.1.4 持续模式
持久模式(persistent mode)极大地提高了性能。因为fork()是已知的瓶颈，对于持久模式，目标不会对每个测试用例进行fork。相反，循环可以修补到目标中，每次迭代执行一个测试用例。为了工作，每次迭代都需要造成最小的状态更改。

### 2.2 智能调度
现代的覆盖率引导模糊器可以实现不同的优先级算法来调度模糊管道中的各种元素。调度器的目标通常是通过智能的测试用例选择来提高总体覆盖率和错误检测。

#### 2.2.1 AFLFast
Böhme等人的FLFAST\[11\]表明需要强调低频路径，以探索更多的分支和发现更多的bug。对AFL开发的几个改进不仅强调了公共路径，目的是暴露额外的程序行为。他们强调了两个问题:
1. 为了强调低频路径，模糊器应该以什么顺序挑选种子?
2. 我们能否调整每个种子产生的输入量(能量)?

作者通过一组新颖的搜索策略解决了第一个问题，通过引入六种功率调度来计算模糊过程中收集的参数的能量。

#### 2.2.2 MOpt
MOPT[25]作为种子调度的一个横向问题，引入了突变调度。在这项工作中，Lyu等人使用自定义粒子群优化算法探索了赋予变异算子不同概率的可能性。这种优化提高了fuzzer快速发现覆盖范围的能力。在他们AFL的补丁中，作者将模糊阶段分为以下两个模块。Pilot，一个评估操作人员的模块，根据有效性分配概率。编码模块生成突变，将试验期间发现的概率考虑在内。

### 2.3 绕过障碍
传统上，覆盖引导的模糊器会遇到阻碍探索其背后代码的障碍。典型的障碍是较大的比较，如字符串和校验和检查。为了解决这个问题，人们进行了一系列的研究。

#### 2.3.1 LAF-Intel
LAF-INTEL[2]是一项旨在绕过硬多字节比较的工作，通过将它们拆分为多个单字节比较。这样，这些比较可以一个字节一个字节地传递，覆盖引导的模糊器接收每个部分的反馈。最初的实现是一组LLVM传递，分隔整数比较，但当在编译时知道其中一个参数时，也会调用字符串比较函数，如strcmp。LAFIntel详细介绍：

1. 将>=(和<=)运算符简化为>(<)和\==比较链;
2. 将有符号整数比较更改为纯符号比较和无符号比较的链;
3. 将所有位宽为64位、32位或16位的无符号整数比较拆分为8位的多次比较链;

#### 2.3.2 RedQueen
最近，基于KAFL[36]的REDQUEEN[5]探索了绕过硬比较和校验和检查的可能性，就像之前的文献[35][12][33][44]一样，但没有使用昂贵的技术，如污点跟踪[46]或符号执行[6,37]。这个模糊器主要关注定义为Input-To-State (I2S)的比较，这是一种与至少一个操作数中的输入有直接依赖关系的比较类型。作者表明，许多路障比较都属于这种类型，并开发了一种技术来定位和绕过它们。REDQUEEN首先在其着色colorization阶段增加输入中的熵，用随机数据替换字节，同时保持测试用例的覆盖率。通过这种方式，观察I2S比较的操作数，fuzzer可以减少在输入中定位其位置的猜测次数。然后，REDQUEEN改变输入，替换从比较中提取的I2S令牌，并再次使用该信息来定位校验和检查并修补它们。在每个模糊阶段结束时，REDQUEEN再次使用I2S替换来修复新生成的感兴趣输入的校验和。如果失败，则补丁校验和被检测为已删除补丁的假阳性。

### 2.4 变异结构化输入
模糊器的一个常见问题是，它们可能生成大部分无效输入，使得解析阶段之后的程序状态不可访问。解决这个问题的方法是使用输入模型，有效地减少生成输入的空间。这允许基于反馈的模糊器探索程序中的深层路径。

#### 2.4.1 AFLSmart
Pham等人将结构化模糊引入AFL:AFLSMART[34]。AFLSMART使用PEACH[14] pits作为输入模型格式，这是一种广泛使用的结构化黑盒模糊规范。这种选择使得重用为PEACH编写的协议规范成为可能。AFLSMART在第一次从队列中提取测试用例时解析测试用例。它以一种懒惰的方式，延迟破解，允许AFLSMART回退到AFL，如果它在探索覆盖方面足够好，而不浪费时间解析。解析步骤的结果是一个表示AST的虚拟结构。AFLSMART引入了高阶结构突变，使虚拟结构而不是原始字节发生突变。它可以被配置为只使用这些结构突变，或者在《浩劫》中将它们与其他结构突变堆叠在一起。

## 3. 模糊测试的新基线
在本节中，我们将解释afl++的工程背景。afl++的核心是AFL的分叉版本，fuzzer是一部分学术模糊研究的基础，在行业中也得到了广泛的应用。本节描述afl++在上面添加了什么，包括第2节中讨论的许多特性。afl++并不局限于这里讨论的特性。可用性和工程方面的小进步超出了本文的范围。要深入了解这个小而有效的改进，请参阅afl++文档[18]。

### 3.1 种子调度
afl++合并了AFLFAST，并扩展了额外的功率计划。这包括AFLFAST的所有调度:fast, coe, explore, quad, lin, exploit。这些调度是以下变量的函数:
1. 从队列中选择种子的时间;
2. 相同种子覆盖率下产生的输入数量;
3. 通常具有相同覆盖率的生成测试用例的平均数量;

默认的调度是explore。此外，afl++还添加了mmopt和稀有调度。Mmopt增加了最新种子的分数，以帮助深入研究新发现的路径。Rare忽略了种子的运行时(与所有其他调度不同)，并将重点放在具有很少被其他种子覆盖的边缘的种子上，这是[24][10]所示的有效度量。

### 3.2 变异器
与传统的确定性和Havoc管道相比，afl++包含了更多的突变子。突变子可以与其他突变子联合使用。

#### 3.2.1 自定义变异API
afl++可以很容易地扩展到学术界的新研究，并适应于特定目标的漏洞发现。为此，它提供了一个不断增长的API。当前状态如下所示。

自定义突变器允许模糊研究在afl++之上构建新的调度、突变和最小化，而不需要对AFL进行分叉和修补，这是当前许多工具的情况。最初对此的支持是在Holler的AFL分叉[19]中独立开发的，但得到了许多新功能的扩展。插件可以用C ABI兼容语言编写，甚至可以用Python进行原型化。例如，使用当前的API, AFLSMART可以完全重写为afl++插件。目前可以实现以下功能:

**`afl_custom_(de)init`**  每个自定义突变器都可以使用这些自解释函数来初始化或反初始化模块`afl_custom_init`和`afl_custom_deinit`。afl++的伪随机生成器种子被传递给init。自定义突变器应该确保在给定相同种子的情况下，模糊结果是可重复的。

**`Afl_custom_queue_get`** 是一个回调函数，它决定自定义模糊器是否应该模糊当前队列条目。在这个例程中，用户还可以为输入执行相关元数据的初始化，例如，用于结构化模糊的虚拟结构。

**`Afl_custom_fuzz`** 对给定输入执行自定义突变。它接受一个额外的测试用例。

**`Afl_custom_havoc_mutation`** 对给定的输入执行一个自定义突变。在破坏阶段，这种突变与其他突变叠加在一起。`afl_custom_havoc_mutation_probability`返回自定义突变在启用调优时被调用的概率(默认为6%，受AFLSMART的启发)。

**`afl_custom_post_process`** 在某些情况下，自定义突变器返回的突变数据的格式不适合直接使用此输入执行目标。例如，当使用libprotobuf-mutator时，返回的数据是对应于给定语法的protobuf格式，首先需要将其转换为目标的纯文本格式。在这种情况下，或者为了固定校验和和大小，用户可以定义afl_custom_post_process函数。

**`Afl_custom_queue_new_entry`** 在向队列添加一个新的测试用例后被调用，这是一个将元数据存储在磁盘上的有用钩子。

**Trimming支持**

在afl++(第2.1.1节)中实现的通用裁剪例程可能会破坏复杂格式的结构。当您的目标可以处理输入的一部分(导致覆盖)，然后在剩余的输入上出现错误时，情况尤其如此。在这种情况下，实现一个定制的修剪例程是有意义的。API由多个方法组成，因为在每个修剪步骤之后，覆盖位图必须与修剪前的地图相对。

Afl_custom_init_trim在每次修剪操作开始时被调用，并接收初始缓冲区。它应该返回这个输入上可能的迭代步骤数(例如，如果输入有n个元素，其中一个应该被删除，则返回n-1)。如果实现的修剪算法不允许确定(剩余的)步数，那么它可以返回1，表示可以执行进一步的修剪，这将在afl_custom_post_trim返回0时执行。

Afl_custom_trim对于每个修剪操作都被调用。它会记住当前状态，因此可以节省每次迭代的重新解析步骤。它应该返回经过修剪的输入缓冲区，其中返回的数据长度不能超过初始输入数据。

在每个修剪操作之后调用Afl_custom_post_trim，以告知修剪步骤是否成功(就相同的覆盖率而言)。该方法必须返回下一个修剪迭代索引(从0到afl_custom_init_trim中返回的最大步数)。

#### 3.2.2 Input-To-State 变异器
afl++实现了一个基于REDQUEEN的I2S替换的突变子。除了上面描述的内容外，我们还对原始实现进行了一些优化。

首先，在增加输入中字节的熵方面，着色colorization似乎非常有效，但如果一个关键字段(例如大小字段)随机突变，则会大大降低模糊器的速度。我们扩展了着色，不仅在覆盖位图的散列保持不变时保持突变区域，而且在执行速度保持在原始速度的2倍范围内时也保持突变区域。这种改善似乎使REDQUEEN的病理靶点有所不同。

另一个扩展是每个比较的概率模糊。如果模糊器在试图绕过一个比较时未能生成一个有趣的输入，下一次这个比较将以较低的概率进行模糊。这避免了在看似I2S但实际上不是I2S的无法解决的比较上花费太多时间。

**CmpLog Instrumentation** 这个突变器不像最初的REDQUEEN实现那样使用断点记录操作数的比较，而是使用一个类似于Fioraldi等人在WEIZZ[15]中使用的共享表。每次比较都将最近256次执行的操作数记录在fuzzer和target之间共享的256 MB表中。

表的第一部分维护每个比较的元数据，比如大小、ID和实际执行数。在缓存位置方面，可以以一种有效的方式遍历512 KB的总大小。如果没有使用比较，元数据就足以注册，并且与操作数对应的内存永远不会被访问。该工具可用于LLVM和QEMU工具。

#### 3.2.3 MOpt Mutator 
afl++实现了MOpt的Core和Pilot模式。除此之外，MOPT还针对afl++进行了修补，这样它就可以与输入到状态突变器结合使用。最重要的是，afl++支持MOPT与标准突变模式的交织。

### 3.3 插桩
afl++支持几种后端插桩：LLVM、GCC、QEMU、Unicorn和QBDI。最重要的是，它提供了一个代理模块，可以适应将测试用例转发到目标，并为afl-fuzz提供任何类型的覆盖，甚至是远程和非覆盖，例如安培消耗或JTAG的分支地址。表1恢复了第3节中讨论的每个检测后端最重要特性的实现状态。

![](images/Pasted%20image%2020230411213102.png)





## Questions
What is a **baseline tool**?
What is IPC?
What is Persistent Mode？