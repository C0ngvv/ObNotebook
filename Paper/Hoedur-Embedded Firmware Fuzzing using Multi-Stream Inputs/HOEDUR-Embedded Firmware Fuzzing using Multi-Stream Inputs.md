2023 Usenix

# 翻译
## 摘要
嵌入式系统及其多样化、相互连接的组件构成了我们数字基础设施的支柱。尽管它们很重要，但以可扩展的方式分析它们的安全性仍然是难以捉摸和具有挑战性的。最近的固件重新托管工作为嵌入式系统带来了可扩展的动态分析，使自动化漏洞评估的模糊测试变得可行。由于这些工作侧重于设备行为建模而不是模糊测试，因此它们以一种特殊的方式与现成的模糊测试器集成。他们将传统的平面二进制模糊测试输入重新解释为一系列硬件响应。在实践中，这为模糊器提供了一个脆弱、不透明、难以有效改变的输入布局。

我们的工作是基于这样的见解，即虽然固件仿真最近显着成熟，但输入空间以一种无效的方式呈现给模糊器。我们提出了一种基于多流输入的固件感知模糊集成方法，我们将之前的平面、顺序和不透明的固件模糊输入重新组织为多个严格类型和内聚的流。这允许我们的模糊器HOEDUR执行类型感知的突变并维护其进程。它还使固件模糊检测能够使用最先进的突变技术。总的来说，我们发现这些技术显著提高了模糊测试的有效性。我们的评估表明，HOEDUR的覆盖范围是最先进的固件fuzzers的5倍，发现其他fuzzers无法发现的错误，并且发现已知错误的速度高达550倍。HOEDUR总共发现了23个以前未知的漏洞。

## 1.引言
嵌入式系统无处不在，相互连接，是智能家居、关键基础设施以及物联网的核心。从安全的角度来看，它们是具有挑战性的，因为它们是多样化的，也就是说，没有通用的体系结构，不同的供应商使用定制的硬件和软件来构建嵌入式系统。此外，这些系统连续地处理来自多个硬件外设的输入，例如串行数据、传感器读数和无线数据包。这对测试这些系统的安全性提出了重大挑战。解决这些挑战的一个特别有前途的方法是自动固件重新托管，它允许不同的固件在通用模拟器中运行[13,18,28,47,60]。该领域的最新进展使动态分析技术得以扩展[55]。

其中一些固件重托管方法应用模糊测试(fuzzing)[13,18,47,60]，这是一种动态分析技术，向被测系统发送随机输入。然而，这些工作主要集中在建模硬件外设行为，以成功地在模拟器中运行给定的固件映像。他们没有专门研究固件模糊测试过程本身。相反，他们以特别的方式将现成的模糊器集成到他们的系统中。在现有的工作中，仿真器naïvely以一种平坦的方式依次转换fuzzer提供的字节[18,47,60]。每次固件访问其外设之一时，fuzzer提供的下几个字节将被动态解释以服务于请求。

我们确定了现有模糊器的这种临时集成的两个固有问题:首先，也是最重要的是，模糊器生成的输入的这种平面处理导致输入结构由于其顺序性质而变得脆弱;即使对早期输入字节的最小更改也可能改变固件执行路径，因此，也可能在雪崩效应中改变对以下模糊输入字节的解释。这是因为固件不断地处理来自多个硬件源的数据。为了响应从不同外设(例如温度传感器)获取的数据，固件可能会中断其当前处理以对其环境中的变化做出反应。中断对于及时响应外部事件至关重要。因此，固件的执行流直接依赖于模糊器生成的数据。由于在其任务之间频繁切换固件逻辑，每个任务的数据分散在输入中。例如，固件可能会中断检索IPv6数据包以读取传感器值。这种中断消耗数据，使得IPv6数据包在模糊器生成的输入中被分割。这反过来又使许多现有的突变技术(如多字节算术或基于字典的插入)失效，因为它们假定数据是连续的。因此，突变经常放弃模糊化进程，因为先前结构良好的输入被不同地解释。通用模糊器的临时集成的第二个缺点是，模糊器不能解释嵌入式固件特定的行为。例如，固件被设计为运行无限长的时间，而通用应用程序通常处理有限的输入。

在这项工作中，我们设计了一个利用多流输入表示的固件感知模糊器。与之前的工作相反，将硬件行为表示为平面二进制输入，我们将固件输入细分为多个数据流，每个数据流代表硬件寄存器的不同使用。这将产生包含强类型数据的结构良好的输入格式。我们的多流方法有多个优点:首先，我们可以改变与一个特定硬件特性(一个数据流)相关的数据，而不会影响另一个硬件特性(另一个数据流)的现有语义。与平面二进制输入格式相比，这稳定了我们的输入，允许模糊器保持进度。其次，我们的强类型数据流允许我们执行类型感知的突变。第三，我们现在能够收集每个流的性能指标，模糊器可以使用它来优先考虑输入中状态丰富的部分的变化。

我们的方法的一个具有挑战性的方面是数据流的绝对数量:由于固件通常访问大量硬件寄存器，我们需要数百个流。因此，手动识别和配置它们是不可行的。我们通过为仿真期间观察到的每个唯一硬件访问自动分配数据流来解决这个问题。第二个挑战在于，与实际的应用程序数据相反，大多数硬件寄存器表示的是设备的低级状态，相当无趣。这使得大多数数据流在经过某一点后不希望发生广泛的变化。为了关注随时间变化的有趣数据，我们利用大小加权版本的Thompson采样来调度数据流进行突变。

我们在一个名为HOEDUR的原型中实现了我们的方法。我们在先前工作评估中使用的32个固件映像的样本集上评估HOEDUR。我们的评估表明，HOEDUR的覆盖范围是同类最先进固件fuzzers的5倍，触发已知bug的速度提高了550倍。HOEDUR还发现了23个以前未知的错误，包括8个新错误，这些错误包含在以前工作的数据集中的固件映像中。我们已经以负责任的方式向他们各自的供应商披露了这些问题。到目前为止，已经分配了22名cve。

综上所述，我们做出了以下主要贡献:
- 我们提出了一种新颖的多流固件输入表示，它允许固件模糊器有效地改变输入并保持模糊进程。
- 我们介绍了HOEDUR的设计和实现，HOEDUR是一种高效的固件感知模糊器，利用我们的多流输入表示。
- 在综合评估中，我们表明我们的方法使HOEDUR在固件模糊测试中明显优于最先进的模糊测试器。作为评估的一部分，HOEDUR发现了23个新漏洞，我们负责任地向各自的供应商披露了这些漏洞。

为了促进对该主题的研究，我们将在https://github.com/fuzzware-fuzzer/HOEDUR上发布HOEDUR和实验数据集。

## 2.固件模糊测试
在介绍我们的多流固件输入表示之前，我们简要概述了固件模糊测试和该领域的挑战。

### 2.1 嵌入式系统固件
嵌入式系统通常是专门构建的，可以由许多不同的外围设备组成。在这些系统上运行的软件被称为固件。由于大小和资源限制，固件通常使用许多专用操作系统中的一种来构建。所谓的裸机固件也可以在没有操作系统的情况下自己实现所需的功能。固件负责嵌入式系统提供的所有功能，从业务逻辑到与其外围设备通信的驱动程序。嵌入式固件中的逻辑任务通常与操作系统库紧密耦合。这与通用软件形成了对比，在通用软件中，任务是隔离的，只与操作系统交互，使用一组系统调用。具有强耦合任务的固件也称为单片固件。

### 2.2 固件与外设通信
为了与周围的硬件外设通信，固件驱动程序使用一些不同目的的机制，例如，内存映射输入/输出(MMIO)来修改和/或检索外设的状态。每个外设在分配给它的物理地址空间内都有一个内存区域。在这个内存区域内，外设公开一组MMIO寄存器。对这些寄存器的存储操作允许固件修改外设状态(例如设置其配置)，而加载操作允许固件检索外设状态或读取实际数据。由于给定的系统通常包含各种外设，这些外设又包含多个MMIO寄存器，这些寄存器又由不同的位域组成，因此固件通常以数百到数千种不同的方式与硬件交互。

除了固件发起的MMIO之外，外设还可以通过中断请求(IRQ)通知固件异步事件，例如新数据的到达。IRQ是由硬件外设或固件向CPU发出的信号。CPU将挂起当前的任务，并切换到相应的中断服务例程(ISR)来处理请求。

作为外围设备通信的第三种方式，一些嵌入式系统也使用直接存储器访问(DMA)。顾名思义，这允许外设在不涉及CPU的情况下读写物理内存。这与微控制器单元(MCU)上的固件执行代码异步工作，用于高吞吐量设备，并通过MMIO和中断进行协调。

### 2.3 基于重托管的固件模糊测试
固件重新托管描述了在原始物理设备之外的虚拟环境中执行固件映像的过程[55]。成功地重新托管固件映像需要环境模拟不同物理硬件外设的行为。更具体地说，重托管环境需要提供前面介绍的通信机制，也就是说，它需要生成从MMIO寄存器加载的值，引发中断，并用数据填充DMA输入缓冲区。

正如先前的工作所证明的那样，可以提供一个薄仿真层，并使用模糊器生成的输入来近似外围设备的行为以进行动态分析[18,47,60]。这种方法对广泛的测试很有吸引力，因为这种通用类型的重托管不需要专门的硬件或特定于目标的模拟器，因此可以很好地与通用计算资源进行扩展。

最近的重托管环境[18,47,60]允许模糊器通过以流方式消耗平面模糊输入来近似外围设备行为。每当固件与其外设通信时，例如，通过加载MMIO寄存器或从新的DMA缓冲区读取，仿真器从模糊器的二进制输入文件中绘制下一个所需的字节数。模拟器将这些下一个字节解释为外设的响应。这使得最先进的模糊器易于集成，因为仿真器可以像普通应用程序一样对模糊器起作用。与命令行程序一样，模拟器接受一个平面二进制输入文件，从中读取，并逐块地使用其内容，以顺序响应外设访问。

## 3.固件输入表示
为了说明为什么当前处理模糊器输入的方法不足，我们首先需要讨论固件如何处理来自其外围设备的输入。然后，我们分析了通过平面输入的临时集成如何转化为固件行为，以及这种平面输入表示如何影响模糊器应用有意义的突变和有效探索固件行为的能力。然后，我们确定了指导我们设计多流固件模糊测试的潜在改进领域。

### 3.1 固件输入处理
在其普通操作期间，固件在其主执行上下文中运行。主上下文可以由单个循环组成，也可以分成几个任务，每个任务处理自己类型的硬件输入。每当外设通过引发IRQ指示一个事件时，主执行将被挂起，并执行ISR来处理中断。处理完所有挂起的中断后，固件在其主上下文中恢复执行。在不同的上下文中执行期间，固件不断访问MMIO寄存器以与其周围的外设进行交互。

为了我们的分析，并作为一个运行的例子，我们描述了流行的开源3D打印机固件Marlin的简化版本[16]。在其核心，固件接受GCode形式的串行输入，其中包含打印指令。固件将这些指令转换为打印头的动作。在操作过程中，固件还必须跟踪打印头的运动。图1以简化的形式概述了Marlin源代码。特色代码包含三个执行上下文:主循环(main)以及两个中断处理程序(isr_usart和isr_timer)。主循环管理加热和处理GCode指令。isr_usart将所需的输入字符添加到GCode环缓冲区中，isr_timer通过gpio连接的磁传感器定期检查移动限制。如果达到限制，Marlin固件执行一个函数来处理这种情况。图2显示了固件如何从不同的执行上下文中访问其外设MMIO寄存器。正如我们所看到的，固件逻辑在其不同的上下文中切换，随着时间的推移交织多个外设访问。

![](images/Pasted%20image%2020230816112821.png)

![](images/Pasted%20image%2020230816113124.png)

### 3.2 处理平面输入
给定这个示例固件，它与外设访问交织在一起，我们现在讨论如何将一个平坦的、顺序的输入转换为来自这些外设的响应。然后，我们分析了平面表示如何在常见突变下使输入不稳定，即，改变输入的给定部分是怎样可能会改变其后续部分的含义。

首先，我们定义平坦输入保持稳定意味着什么。如果解释不同输入部分的上下文保持不变，我们认为输入是稳定的。例如，假设我们的3D打印机输入的字节序列被解释为GCode指令。现在，当模糊器改变输入时，相同的字节仍然应该被解释为GCode(如果是这种情况，则输入是稳定的)。然而，如果这些GCode字节中的一些现在被不同地解释(例如，作为磁传感器的GPIO输出而不是GCode)，则输入的语义含义发生变化:输入可能不再包含有效的GCode序列(我们说输入不稳定)。

因此，为了使扁平输入保持稳定，需要保持以下属性:
1. 在给定上下文中执行的访问数量需要保持不变。
2. 跨不同上下文的访问顺序需要保持不变。

如果给定的突变改变了固件执行的访问的数量或顺序，则平坦输入变得不稳定。为了了解简单的突变如何以不同的方式导致平坦输入变得不稳定，我们考虑在示例输入的两个不同位置进行单比特翻转(一种通常在模糊测试期间应用的突变)。图3显示了这两个突变。

![](images/Pasted%20image%2020230816113759.png)

首先，考虑一个模糊器改变对isr_usart状态寄存器SR的第一次访问的响应。这样的位翻转改变了寄存器值的语义，从表示有串行数据字节可用变为表示没有数据字节可用。此更改的效果如图3(b)所示:不执行对数据寄存器DR的额外访问，isr_usart将立即返回并在主循环中恢复执行，而不访问USART数据寄存器。现在，主循环(x轴上4和5之间的绿色背景)恢复并将之前的GCode字符(红色框)重新解释为温度值。接下来，之前在主上下文中解释的输入字节现在将在isr_timer(蓝色背景)中使用，依此类推。这是执行上下文中访问数量的变化导致雪崩效应中输入不稳定的一个示例。

第二个更微妙的输入不稳定性来源是时序行为的变化。由于外设访问的交错特性，计时行为的改变会影响执行上下文之间的访问顺序。考虑改变打印头高度传感器寄存器(isr_timer中的IDR)外围响应的位翻转突变。相反不是指示传感器尚未触发，而是高度信号更早一个tick达到。此更改的效果如图3(c)所示。它指示先前在该时间点未指示的终止状态条件。因此，isr_timer现在需要额外的时间来执行进一步的处理逻辑。在isr_timer执行所需的额外时间内，下一个USART中断发生，导致isr_usart在isr_timer之后直接执行，而不允许main消耗值22。结果，isr_usart在它自己的上下文中(红色背景)消耗值22，导致与前面示例中类似的雪崩效应和输入不稳定。

在这些例子中，我们已经看到了不同类型的雪崩效应使平坦输入不稳定。通用fuzzers(通常不适用于固件)的基本假设是逻辑连接输入的空间局部性。换句话说，通用模糊器假定输入的逻辑连接部分在输入中彼此靠近。如果是这样的话，通用突变是有效的。例如，如果网络数据包中的大小字段在输入中被编码为四个连续字节，则典型的算术突变(将四个字节转换为整数，然后将其减少以引起整数下溢)可以很好地工作。另一方面，如果不存在这样的空间局部性(即，大小字段的字节分布在整个输入文件中)，则这种突变将变得无效。同样的概念也适用于输入不稳定性的雪崩效应;输入的逻辑连接部分越多，分布在突变的输入文件中，输入不稳定性的雪崩效应就越显著。

### 3.3 扁平输入的缺点
由于以平坦、顺序的方式处理输入，我们确定了阻碍有效模糊器集成的三个主要挑战:

**进度丢失**。由于平面输入的不稳定性，模糊器经常在变异时丢弃有意义的语义。因此，模糊器很难进一步前进，特别是当固件对其输入格式强制执行复杂要求时。

**缺少类型信息**。平面二进制输入的不透明特性隐藏了仿真器对模糊器可用的信息，因为模糊器无法将特定输入字节与类型信息关联起来。这包括MMIO寄存器访问的大小和访问发生的顺序。如果没有这些关于如何使用不同类型输入的信息和反馈，模糊器就无法执行上下文感知和类型感知的突变。

**不适用的突变**。由于固件不断地交织其对外设的访问，逻辑连接的部件分散在平面二进制输入中。这使许多已建立的突变类型失效，这些类型隐含地假设输入的逻辑连接部分位于相邻的输入字节。示例包括从字典中插入令牌和对相邻字节进行算术操作，例如将四个字节转换为整数，然后进行减法或加法(这已被证明可以揭示整数下溢/溢出等问题)。

## 4.设计
为了应对这些挑战，我们提出了HOEDUR，这是第一种模糊测试方法，它可以识别底层固件，并能够将固件输入拆分为多个严格类型的数据流。与之前使用通用和固件无关的fuzzers相比，HOEDUR可以考虑特定于固件的执行反馈，并在多流输入格式上操作。

图4显示了我们的方法的概述。HOEDUR的设计有两个不同的部分:首先，我们使用一个模拟器，它提供特定于固件的反馈，并从多流输入提供硬件值。其次，我们设计了一个固件感知模糊器。在下文中，我们将详细描述这两个方面，并强调我们在设计中需要克服的独特挑战。

![](images/Pasted%20image%2020230816154206.png)

### 4.1 模拟器
我们的仿真器基于指令集架构(ISA)仿真器(图4中虚线显示)，我们在其中加载并执行要测试的固件。每当固件访问硬件外设时，仿真器在运行时确定该访问的上下文。我们将访问上下文定义为由以下三部分组成:(i)程序计数器，(ii)请求的MMIO寄存器的地址，以及(iii)访问大小。在访问上下文中包括程序计数器意味着，我们不是对每个访问设备或MMIO寄存器分组数据流，而是根据每个MMIO寄存器的唯一访问位置(i) (ii)使用更细粒度的分区。这是基于观察到MMIO寄存器可能在固件代码的不同部分用于不同目的。

在第3节中可以找到一个例子，其中固件从USART外设访问两种类型的寄存器;状态寄存器SR由位标志组成，而数据寄存器DR提供GCode字符。虽然没有包含在图1所示的简化源代码中，但固件可以在不同的代码位置检查状态寄存器的不同位标志(数据可用性，错误条件位，…)．

对于这些访问上下文中的每一个，我们创建一个提供外围响应值的相关数据流。访问的大小定义了流中包含的值的基本(字节级)数据类型，这样所有流都是严格类型的。为了获得更细粒度(位级)的类型粒度，我们进一步将前面工作中介绍的MMIO访问模型集成到我们的模拟器中[47]。

所有数据流的集合表示一个多流输入。由于固件被设计为无限期运行(注意图1第2行中的while(true)循环)，我们需要确定何时停止运行给定(多流)输入的模拟器。一旦固件试图访问任何耗尽的数据流，我们就终止模拟运行，这意味着数据流提供的所有响应值都已经被消耗。

在每次运行期间，模拟器收集额外的运行时信息，这些信息构成了我们的fuzzer的固件感知反馈的基础。首先，我们收集边缘覆盖，我们通过消除主执行上下文和中断处理之间的转换产生的边缘，以特定于固件的方式修改边缘覆盖。这避免了模糊器的干扰，因为固件主循环和中断处理之间的切换不再引入误导性的覆盖(这种切换可以在主执行上下文的任何地方发生，从而快速填充覆盖位图)。其次，我们跟踪特定于固件的执行度量并定义其限制，包括引发中断和执行基本块的最大数量。导致仿真运行超过这些限制的输入不一定会导致通用模糊器所认为的超时。然而，这样的输入仍然需要相对较长的时间来执行，从而减慢了模糊测试。除了在仿真运行期间节省时间外，固件感知模糊器还可以利用这些执行度量的反馈来优化其输入调度。

### 4.2 多流输入变异
我们将多流输入的突变建立在成熟的突变类型上。其中包括整数运算、插入和输入拼接。我们以不同的方式使这些突变类型适应我们的多流输入:

类型感知。对于每个包含类型化值(例如，8、16或32位整数)的数据流，我们根据它们的实际类型对离散值进行变异。例如，这允许我们将32位值插入到已知需要32位整数的流中。相比之下，以前的fuzzers既不知道插入的正确位置，也不知道要使用的正确数据类型。盲目地推测位置和数据类型会导致我们在3.2节中研究的先前fuzzers的破坏性雪崩效应。

Cross-value突变。正如我们在3.2节中看到的，在通用突变中，将一系列字节转换为更大的整数并执行算术运算是常见的做法，从而将后续字节作为一个单元进行突变。我们将这个概念推广到数据流中的连续值:我们将数据流中的多个连续值组合成一个更大的数据流，执行算术运算，并将结果作为连续值写回来。

作为特定于固件的调整，我们甚至为更宽的值类型(例如，对于保存32位整数的数据流)组合值。我们通过从每个值中提取一个字节(例如，最低有效字节)来组合这些更宽的值，然后像往常一样组合它们。对于固件模糊检测来说，组合大于8位整数的值是可取的，原因如下:虽然固件通常将数据(例如网络数据包)逐字节存储到其解析缓冲区中，但固件首先需要从MMIO寄存器加载每个值。这个MMIO寄存器可能是32位宽，导致数据流保存32位整数。

Cross-stream突变。对于多流输入，某些突变，如输入拼接(即，将数据从不同的输入复制到突变的输入)在两个维度上是有意义的:面向流和时间顺序。例如，我们可能希望将特定类型的数据从一个数据流复制到另一个数据流(关于3D打印机的例子，我们可能希望从另一个输入复制GCode)。在这里，我们可以简单地将连续的值从一个流复制到另一个流。在其他情况下，我们可能更喜欢在时间框架内复制所有外围交互(例如，将磁传感器读数的特定序列与相应的GCode片段结合起来)。出于这个原因，我们为每个适用的突变引入了两种模式:mono(用于单个流)和chrono(用于一组按时间顺序的交互)。

输入扩展。回想一下，固件被设计为无限期运行，因此需要无限量的输入。随着时间的推移，它还可能发现新的访问上下文，这需要动态添加数据流。这与通用模糊测试目标不同，后者通常需要一个有限的、通常是单个的输入文件。为了成功地模糊测试固件，我们需要平衡两个极端:一个非常短的输入几乎没有通过固件引导过程，和一个无限长的输入。对于新发现的数据流，我们提供一组初始的随机值。我们还添加了一个明显的突变，在多流输入通常已经耗尽之后，模糊器指示模拟器提供一些随机值。这通过扩展输入的数据流来扩展输入。这是一个进一步的固件特定的附加功能，它允许仿真继续进行，并避免由于固件输入的突然终止而导致仿真在有趣的代码位置突然停止。

### 4.3 调度数据流进行突变
在改变一个输入之前，模糊器自然需要选择一个要改变的输入。对于多流输入，我们还需要决定我们想要改变多流输入中的哪个数据流。选择一个数据流进行突变是具有挑战性的，原因有三:(1)数据流的数量很高，因为固件通常访问一系列外围寄存器，每个寄存器来自潜在的多个代码位置。这将导致数百或数千个访问上下文和数据流。(2)大多数数据流不希望发生突变。这样做的原因是，大多数流表示的状态寄存器对有意义的固件功能没有贡献。虽然改变这些寄存器对于寻找合适的底层硬件状态非常重要，但是超过一定的阈值，改变状态寄存器就会变得无效。(3)静态度量不足以作为数据流调度的基础。例如，数据流可能很大，但可能不会影响重要的固件状态空间(例如，连续轮询状态寄存器或数据寄存器，其中存在一个驱动存根，从中读取但不实现逻辑)。数据流最初也可能很重要，但后来变得无关紧要(例如，在引导过程或硬件初始化中涉及的状态寄存器)。

由于这些原因，我们需要数据流突变调度机制随着时间的推移进行调整。虽然最初有规律地改变每个数据流，但它最终需要优先考虑保存有意义数据的数据流，比如前面第3节提到的GCode指令数据。

### 4.3.1 流选择





## 5.实现
我们的实现由两个组件组成:一个模拟器和我们的固件感知模糊器HOEDUR。虽然模糊器逻辑与平台无关，但我们的原型模拟器针对ARM Cortex-M MCU，因为该平台被广泛采用，并且可以将我们的方法与最先进的工作进行比较。我们将在https://github.com/fuzzware-fuzzer/hoedur上开源我们的原型实现。
### 5.1 模拟器
仿真器主要由ISA仿真器和附加逻辑组成，以响应给定多流输入的外设访问。我们采用现有的QEMU系统仿真[4]作为HOEDUR仿真器组件的核心，QEMU是一种广泛应用于多个ISA的系统仿真器。

在我们的实现过程中，我们努力保持对QEMU本身的修改尽可能小，以便将来能够重新基于新的QEMU版本(增加205行，删除101行)。这主要是通过将QEMU构建为动态链接库并用Rust单独实现外部仿真器逻辑(例如解释多流输入)来实现的[38]。

我们将QEMU用于已设置内存区域的动态配置机器。对于配置为MMIO的内存区域，我们添加模拟器回调来处理这些外设访问。我们在每个QEMU翻译块的开始注入一个回调，以收集覆盖信息并完全控制执行。我们使用这个回调来更新覆盖位图和控制执行时间。这包括强制执行限制和确定性地注入中断。为了避免代价高昂的进程fork，我们使用模拟器状态的快照，包括它的CPU和内存，以促进快速恢复。

我们有时需要用随机数据扩展输入。当添加了新发现的数据流或由于第4.2节中描述的显式突变时，就会发生这种情况。为了扩展输入，我们对当前模拟运行中要向耗尽的数据流添加多少新的随机值设置了限制。每当生成一个随机值时，我们就递减这个限制，并在该限制达到零后结束仿真运行。

### 5.2 Fuzzer
fuzzer整体设计基于libFuzzer[37]，部分借鉴了AFL[58]和afl++[20]。libFuzzer采用的显著特征包括各种输入mutators和Böhme等人[5]引入的ENTROPIC输入能量。总的来说，我们的fuzzer是在大约13500行Rust代码中实现的。

我们还采用了AFL的突变叠加策略，在执行每个输入之前分别应用4、8、16或32个突变。如第4.3节所述，我们根据寻找新覆盖的成功程度来调整选择给定数据流进行突变的概率。这要求我们确定给定数据流上的突变是否有助于产生新的覆盖范围。我们对有趣的输入进行后处理，产生新的覆盖范围，以减少该度量范围内的噪声。在将其提交到语料库之前，我们重新运行输入多次，同时逐步修剪那些对新覆盖没有贡献的堆叠突变。
































