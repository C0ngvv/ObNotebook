2023 Usenix

# 翻译
## 摘要
嵌入式系统及其多样化、相互连接的组件构成了我们数字基础设施的支柱。尽管它们很重要，但以可扩展的方式分析它们的安全性仍然是难以捉摸和具有挑战性的。最近的固件重新托管工作为嵌入式系统带来了可扩展的动态分析，使自动化漏洞评估的模糊测试变得可行。由于这些工作侧重于设备行为建模而不是模糊测试，因此它们以一种特殊的方式与现成的模糊测试器集成。他们将传统的平面二进制模糊测试输入重新解释为一系列硬件响应。在实践中，这为模糊器提供了一个脆弱、不透明、难以有效改变的输入布局。

我们的工作是基于这样的见解，即虽然固件仿真最近显着成熟，但输入空间以一种无效的方式呈现给模糊器。我们提出了一种基于多流输入的固件感知模糊集成方法，我们将之前的平面、顺序和不透明的固件模糊输入重新组织为多个严格类型和内聚的流。这允许我们的模糊器HOEDUR执行类型感知的突变并维护其进程。它还使固件模糊检测能够使用最先进的突变技术。总的来说，我们发现这些技术显著提高了模糊测试的有效性。我们的评估表明，HOEDUR的覆盖范围是最先进的固件fuzzers的5倍，发现其他fuzzers无法发现的错误，并且发现已知错误的速度高达550倍。HOEDUR总共发现了23个以前未知的漏洞。

## 1.引言
嵌入式系统无处不在，相互连接，是智能家居、关键基础设施以及物联网的核心。从安全的角度来看，它们是具有挑战性的，因为它们是多样化的，也就是说，没有通用的体系结构，不同的供应商使用定制的硬件和软件来构建嵌入式系统。此外，这些系统连续地处理来自多个硬件外设的输入，例如串行数据、传感器读数和无线数据包。这对测试这些系统的安全性提出了重大挑战。解决这些挑战的一个特别有前途的方法是自动固件重新托管，它允许不同的固件在通用模拟器中运行[13,18,28,47,60]。该领域的最新进展使动态分析技术得以扩展[55]。

其中一些固件重托管方法应用模糊测试(fuzzing)[13,18,47,60]，这是一种动态分析技术，向被测系统发送随机输入。然而，这些工作主要集中在建模硬件外设行为，以成功地在模拟器中运行给定的固件映像。他们没有专门研究固件模糊测试过程本身。相反，他们以特别的方式将现成的模糊器集成到他们的系统中。在现有的工作中，仿真器naïvely以一种平坦的方式依次转换fuzzer提供的字节[18,47,60]。每次固件访问其外设之一时，fuzzer提供的下几个字节将被动态解释以服务于请求。

我们确定了现有模糊器的这种临时集成的两个固有问题:首先，也是最重要的是，模糊器生成的输入的这种平面处理导致输入结构由于其顺序性质而变得脆弱;即使对早期输入字节的最小更改也可能改变固件执行路径，因此，也可能在雪崩效应中改变对以下模糊输入字节的解释。这是因为固件不断地处理来自多个硬件源的数据。为了响应从不同外设(例如温度传感器)获取的数据，固件可能会中断其当前处理以对其环境中的变化做出反应。中断对于及时响应外部事件至关重要。因此，固件的执行流直接依赖于模糊器生成的数据。由于在其任务之间频繁切换固件逻辑，每个任务的数据分散在输入中。例如，固件可能会中断检索IPv6数据包以读取传感器值。这种中断消耗数据，使得IPv6数据包在模糊器生成的输入中被分割。这反过来又使许多现有的突变技术(如多字节算术或基于字典的插入)失效，因为它们假定数据是连续的。因此，突变经常放弃模糊化进程，因为先前结构良好的输入被不同地解释。通用模糊器的临时集成的第二个缺点是，模糊器不能解释嵌入式固件特定的行为。例如，固件被设计为运行无限长的时间，而通用应用程序通常处理有限的输入。

在这项工作中，我们设计了一个利用多流输入表示的固件感知模糊器。与之前的工作相反，将硬件行为表示为平面二进制输入，我们将固件输入细分为多个数据流，每个数据流代表硬件寄存器的不同使用。这将产生包含强类型数据的结构良好的输入格式。我们的多流方法有多个优点:首先，我们可以改变与一个特定硬件特性(一个数据流)相关的数据，而不会影响另一个硬件特性(另一个数据流)的现有语义。与平面二进制输入格式相比，这稳定了我们的输入，允许模糊器保持进度。其次，我们的强类型数据流允许我们执行类型感知的突变。第三，我们现在能够收集每个流的性能指标，模糊器可以使用它来优先考虑输入中状态丰富的部分的变化。

我们的方法的一个具有挑战性的方面是数据流的绝对数量:由于固件通常访问大量硬件寄存器，我们需要数百个流。因此，手动识别和配置它们是不可行的。我们通过为仿真期间观察到的每个唯一硬件访问自动分配数据流来解决这个问题。第二个挑战在于，与实际的应用程序数据相反，大多数硬件寄存器表示的是设备的低级状态，相当无趣。这使得大多数数据流在经过某一点后不希望发生广泛的变化。为了关注随时间变化的有趣数据，我们利用大小加权版本的Thompson采样来调度数据流进行突变。

我们在一个名为HOEDUR的原型中实现了我们的方法。我们在先前工作评估中使用的32个固件映像的样本集上评估HOEDUR。我们的评估表明，HOEDUR的覆盖范围是同类最先进固件fuzzers的5倍，触发已知bug的速度提高了550倍。HOEDUR还发现了23个以前未知的错误，包括8个新错误，这些错误包含在以前工作的数据集中的固件映像中。我们已经以负责任的方式向他们各自的供应商披露了这些问题。到目前为止，已经分配了22名cve。

综上所述，我们做出了以下主要贡献:
- 我们提出了一种新颖的多流固件输入表示，它允许固件模糊器有效地改变输入并保持模糊进程。
- 我们介绍了HOEDUR的设计和实现，HOEDUR是一种高效的固件感知模糊器，利用我们的多流输入表示。
- 在综合评估中，我们表明我们的方法使HOEDUR在固件模糊测试中明显优于最先进的模糊测试器。作为评估的一部分，HOEDUR发现了23个新漏洞，我们负责任地向各自的供应商披露了这些漏洞。

为了促进对该主题的研究，我们将在https://github.com/fuzzware-fuzzer/HOEDUR上发布HOEDUR和实验数据集。

## 2.固件模糊测试
在介绍我们的多流固件输入表示之前，我们简要概述了固件模糊测试和该领域的挑战。

### 2.1 嵌入式系统固件
嵌入式系统通常是专门构建的，可以由许多不同的外围设备组成。在这些系统上运行的软件被称为固件。由于大小和资源限制，固件通常使用许多专用操作系统中的一种来构建。所谓的裸机固件也可以在没有操作系统的情况下自己实现所需的功能。固件负责嵌入式系统提供的所有功能，从业务逻辑到与其外围设备通信的驱动程序。嵌入式固件中的逻辑任务通常与操作系统库紧密耦合。这与通用软件形成了对比，在通用软件中，任务是隔离的，只与操作系统交互，使用一组系统调用。具有强耦合任务的固件也称为单片固件。

### 2.2 固件与外设通信
为了与周围的硬件外设通信，固件驱动程序使用一些不同目的的机制，例如，内存映射输入/输出(MMIO)来修改和/或检索外设的状态。每个外设在分配给它的物理地址空间内都有一个内存区域。在这个内存区域内，外设公开一组MMIO寄存器。对这些寄存器的存储操作允许固件修改外设状态(例如设置其配置)，而加载操作允许固件检索外设状态或读取实际数据。由于给定的系统通常包含各种外设，这些外设又包含多个MMIO寄存器，这些寄存器又由不同的位域组成，因此固件通常以数百到数千种不同的方式与硬件交互。

除了固件发起的MMIO之外，外设还可以通过中断请求(IRQ)通知固件异步事件，例如新数据的到达。IRQ是由硬件外设或固件向CPU发出的信号。CPU将挂起当前的任务，并切换到相应的中断服务例程(ISR)来处理请求。

作为外围设备通信的第三种方式，一些嵌入式系统也使用直接存储器访问(DMA)。顾名思义，这允许外设在不涉及CPU的情况下读写物理内存。这与微控制器单元(MCU)上的固件执行代码异步工作，用于高吞吐量设备，并通过MMIO和中断进行协调。

### 2.3 基于重托管的固件模糊测试
固件重新托管描述了在原始物理设备之外的虚拟环境中执行固件映像的过程[55]。成功地重新托管固件映像需要环境模拟不同物理硬件外设的行为。更具体地说，重托管环境需要提供前面介绍的通信机制，也就是说，它需要生成从MMIO寄存器加载的值，引发中断，并用数据填充DMA输入缓冲区。

正如先前的工作所证明的那样，可以提供一个薄仿真层，并使用模糊器生成的输入来近似外围设备的行为以进行动态分析[18,47,60]。这种方法对广泛的测试很有吸引力，因为这种通用类型的重托管不需要专门的硬件或特定于目标的模拟器，因此可以很好地与通用计算资源进行扩展。

最近的重托管环境[18,47,60]允许模糊器通过以流方式消耗平面模糊输入来近似外围设备行为。每当固件与其外设通信时，例如，通过加载MMIO寄存器或从新的DMA缓冲区读取，仿真器从模糊器的二进制输入文件中绘制下一个所需的字节数。模拟器将这些下一个字节解释为外设的响应。这使得最先进的模糊器易于集成，因为仿真器可以像普通应用程序一样对模糊器起作用。与命令行程序一样，模拟器接受一个平面二进制输入文件，从中读取，并逐块地使用其内容，以顺序响应外设访问。

## 3.固件输入表示
为了说明为什么当前处理模糊器输入的方法不足，我们首先需要讨论固件如何处理来自其外围设备的输入。然后，我们分析了通过平面输入的临时集成如何转化为固件行为，以及这种平面输入表示如何影响模糊器应用有意义的突变和有效探索固件行为的能力。然后，我们确定了指导我们设计多流固件模糊测试的潜在改进领域。

### 3.1 固件输入处理
在其普通操作期间，固件在其主执行上下文中运行。主上下文可以由单个循环组成，也可以分成几个任务，每个任务处理自己类型的硬件输入。每当外设通过引发IRQ指示一个事件时，主执行将被挂起，并执行ISR来处理中断。处理完所有挂起的中断后，固件在其主上下文中恢复执行。在不同的上下文中执行期间，固件不断访问MMIO寄存器以与其周围的外设进行交互。

为了我们的分析，并作为一个运行的例子，我们描述了流行的开源3D打印机固件Marlin的简化版本[16]。在其核心，固件接受GCode形式的串行输入，其中包含打印指令。固件将这些指令转换为打印头的动作。在操作过程中，固件还必须跟踪打印头的运动。图1以简化的形式概述了Marlin源代码。特色代码包含三个执行上下文:主循环(main)以及两个中断处理程序(isr_usart和isr_timer)。主循环管理加热和处理GCode指令。isr_usart将所需的输入字符添加到GCode环缓冲区中，isr_timer通过gpio连接的磁传感器定期检查移动限制。如果达到限制，Marlin固件执行一个函数来处理这种情况。图2显示了固件如何从不同的执行上下文中访问其外设MMIO寄存器。正如我们所看到的，固件逻辑在其不同的上下文中切换，随着时间的推移交织多个外设访问。

![](images/Pasted%20image%2020230816112821.png)

![](images/Pasted%20image%2020230816113124.png)

### 3.2 处理平面输入
给定这个示例固件，它与外设访问交织在一起，我们现在讨论如何将一个平坦的、顺序的输入转换为来自这些外设的响应。然后，我们分析了平面表示如何在常见突变下使输入不稳定，即，改变输入的给定部分是怎样可能会改变其后续部分的含义。

首先，我们定义平坦输入保持稳定意味着什么。如果解释不同输入部分的上下文保持不变，我们认为输入是稳定的。例如，假设我们的3D打印机输入的字节序列被解释为GCode指令。现在，当模糊器改变输入时，相同的字节仍然应该被解释为GCode(如果是这种情况，则输入是稳定的)。然而，如果这些GCode字节中的一些现在被不同地解释(例如，作为磁传感器的GPIO输出而不是GCode)，则输入的语义含义发生变化:输入可能不再包含有效的GCode序列(我们说输入不稳定)。

因此，为了使扁平输入保持稳定，需要保持以下属性:
1. 在给定上下文中执行的访问数量需要保持不变。
2. 跨不同上下文的访问顺序需要保持不变。

如果给定的突变改变了固件执行的访问的数量或顺序，则平坦输入变得不稳定。为了了解简单的突变如何以不同的方式导致平坦输入变得不稳定，我们考虑在示例输入的两个不同位置进行单比特翻转(一种通常在模糊测试期间应用的突变)。图3显示了这两个突变。

![](images/Pasted%20image%2020230816113759.png)

首先，考虑一个模糊器改变对isr_usart状态寄存器SR的第一次访问的响应。这样的位翻转改变了寄存器值的语义，从表示有串行数据字节可用变为表示没有数据字节可用。此更改的效果如图3(b)所示:不执行对数据寄存器DR的额外访问，isr_usart将立即返回并在主循环中恢复执行，而不访问USART数据寄存器。现在，主循环(x轴上4和5之间的绿色背景)恢复并将之前的GCode字符(红色框)重新解释为温度值。接下来，之前在主上下文中解释的输入字节现在将在isr_timer(蓝色背景)中使用，依此类推。这是执行上下文中访问数量的变化导致雪崩效应中输入不稳定的一个示例。

第二个更微妙的输入不稳定性来源是时序行为的变化。由于外设访问的交错特性，计时行为的改变会影响执行上下文之间的访问顺序。考虑改变打印头高度传感器寄存器(isr_timer中的IDR)外围响应的位翻转突变。相反不是指示传感器尚未触发，而是高度信号更早一个tick达到。此更改的效果如图3(c)所示。它指示先前在该时间点未指示的终止状态条件。因此，isr_timer现在需要额外的时间来执行进一步的处理逻辑。在isr_timer执行所需的额外时间内，下一个USART中断发生，导致isr_usart在isr_timer之后直接执行，而不允许main消耗值22。结果，isr_usart在它自己的上下文中(红色背景)消耗值22，导致与前面示例中类似的雪崩效应和输入不稳定。

在这些例子中，我们已经看到了不同类型的雪崩效应使平坦输入不稳定。通用fuzzers(通常不适用于固件)的基本假设是逻辑连接输入的空间局部性。


## 5.实现
我们的实现由两个组件组成:一个模拟器和我们的固件感知模糊器HOEDUR。虽然模糊器逻辑与平台无关，但我们的原型模拟器针对ARM Cortex-M MCU，因为该平台被广泛采用，并且可以将我们的方法与最先进的工作进行比较。我们将在https://github.com/fuzzware-fuzzer/hoedur上开源我们的原型实现。
### 5.1 模拟器
仿真器主要由ISA仿真器和附加逻辑组成，以响应给定多流输入的外设访问。我们采用现有的QEMU系统仿真[4]作为HOEDUR仿真器组件的核心，QEMU是一种广泛应用于多个ISA的系统仿真器。

在我们的实现过程中，我们努力保持对QEMU本身的修改尽可能小，以便将来能够重新基于新的QEMU版本(增加205行，删除101行)。这主要是通过将QEMU构建为动态链接库并用Rust单独实现外部仿真器逻辑(例如解释多流输入)来实现的[38]。

我们将QEMU用于已设置内存区域的动态配置机器。对于配置为MMIO的内存区域，我们添加模拟器回调来处理这些外设访问。我们在每个QEMU翻译块的开始注入一个回调，以收集覆盖信息并完全控制执行。我们使用这个回调来更新覆盖位图和控制执行时间。这包括强制执行限制和确定性地注入中断。为了避免代价高昂的进程fork，我们使用模拟器状态的快照，包括它的CPU和内存，以促进快速恢复。

我们有时需要用随机数据扩展输入。当添加了新发现的数据流或由于第4.2节中描述的显式突变时，就会发生这种情况。为了扩展输入，我们对当前模拟运行中要向耗尽的数据流添加多少新的随机值设置了限制。每当生成一个随机值时，我们就递减这个限制，并在该限制达到零后结束仿真运行。

### 5.2 Fuzzer
fuzzer整体设计基于libFuzzer[37]，部分借鉴了AFL[58]和afl++[20]。libFuzzer采用的显著特征包括各种输入mutators和Böhme等人[5]引入的ENTROPIC输入能量。总的来说，我们的fuzzer是在大约13500行Rust代码中实现的。

我们还采用了AFL的突变叠加策略，在执行每个输入之前分别应用4、8、16或32个突变。如第4.3节所述，我们根据寻找新覆盖的成功程度来调整选择给定数据流进行突变的概率。这要求我们确定给定数据流上的突变是否有助于产生新的覆盖范围。我们对有趣的输入进行后处理，产生新的覆盖范围，以减少该度量范围内的噪声。在将其提交到语料库之前，我们重新运行输入多次，同时逐步修剪那些对新覆盖没有贡献的堆叠突变。
































