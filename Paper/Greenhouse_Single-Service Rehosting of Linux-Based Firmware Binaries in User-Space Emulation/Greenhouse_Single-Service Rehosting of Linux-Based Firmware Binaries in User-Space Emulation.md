2023 Usenix

# 翻译
## 摘要
随着物联网设备的日益普及，扩展当前的分析技术以匹配成为一项越来越重要的任务。这一挑战的一部分不仅涉及在模拟环境中重新托管这些嵌入式设备的固件，而且还涉及在这样做时发现真正的漏洞。当前最先进的重托管方法必须考虑到仿真设备和物理设备之间的差异，因此通常侧重于提高仿真保真度。然而，这种对保真度的追求忽略了其他潜在的解决方案。

在本文中，我们提出了一种新颖的重托管技术，用户空间单服务重托管，它模拟了用户空间中的单个固件服务。我们研究了数百个固件样本中涉及的重托管过程，以概括一组防止模拟的障碍，并创建干预措施来解决这些障碍。我们的原型Greenhouse自动重新托管了来自9个不同供应商的7,140个固件映像中的2,841个(39.7%)。我们的方法避开了以前重新托管技术遇到的许多挑战，并使我们能够将常见的漏洞发现技术应用于我们的重新托管图像，例如用户空间覆盖引导的模糊测试。使用这些技术，我们在重新托管的固件服务的一个子集上发现了717个n日漏洞和26个零日漏洞。

## 1.引言
物联网(IoT)的数量几乎是人类的2倍:截至2022年，大约有144亿个连接的物联网设备[18]存在于野外，目前估计到2025年总数将达到342亿个[21]。当然，这些设备的安全性并不完美，仅在2022年上半年，就有86家不同供应商的747个漏洞被披露[34]。物联网固件中未被发现、未报告和潜伏的漏洞的实际数量几乎肯定要高得多。

为了发现物联网设备中的潜在漏洞，研究人员希望在物联网设备固件上应用程序分析技术，包括web扫描和覆盖引导模糊测试等动态方法。然而，这种尝试往往因物联网设备的不可访问性而受到限制:购买它们无法扩展，并且可能耗时，过于昂贵，甚至不可能。即使可以物理访问物联网设备，这些设备上的硬件、操作系统和应用程序的刚性通常也会使上述动态分析技术的应用变得非常困难。

解决此问题的常见解决方案是固件重新托管，或简称重新托管，它在强大、灵活的非物联网设备(如个人计算机(pc)和服务器)上模拟物联网软件。重新托管的一个关键挑战是对每个物联网设备特定的特征和功能的高保真仿真。例如，物联网固件通常将数据存储在NVRAM(非易失性随机存取存储器)中，这在大多数x86 pc上不存在，必须由重新托管环境模拟。外围设备也可能带来困难。无线路由器上的软件服务可以使用仅存在于路由器上的天线发送和接收无线电信号，并且天线行为的完全模拟通常需要大量的手工工作。

为了寻求高重寄存保真度，研究人员提出了一些技术，要么模拟外围设备[4,14,19,22,28]，要么代理与运行在真实物联网设备上的外围设备的通信[17,27,33]。然而，大多数当前的外设感知重托管技术只允许基于小型嵌入式软件平台(如FreeRTOS[2]或Arduino[3])的固件分析，或者根本没有操作系统(“裸机”blobs)。关键是，目前的方法无法扩展到分析更复杂的基于linux的固件，而43%的物联网设备使用linux操作系统[15]。

针对基于Linux的固件的最先进的重新托管解决方案依赖于外设无关的全系统重新托管，通常通过将固件示例重新打包为标准文件系统格式，用重托管主机特定的版本替换嵌入式Linux内核以支持一些特殊的通用设备仿真，并在全系统模拟器(如QEMU)中启动固件示例[5,21]。然而，这种对重新托管保真度的隐式让步(例如，通过替换嵌入式内核)会导致重新托管失败。例如,Firmadyne[5]仅在21%的尝试固件样本上实现IP连接。即使对于表面上正确重托管的固件，保真度的缺乏也会导致固件操作错误:FirmAE [21]， Firmadyne的改进版本，测量了79%的成功重托管率，但我们在本文中表明，几乎一半的FirmAE重托管目标实际上没有保持足够的功能来测试面向外部的服务。

缓解重托管失败的一个明确的研究方向是提高保真度。但是，这种对模拟保真度的追求是重新托管的必要条件吗？我们对过去两年中关于NVD[25]的100个固件cve进行了随机抽样，发现其中只有14%与硬件相关，其余许多本质上独立于难以模拟的特定于设备的特性和功能。例如，在2022年9月，Tenda在其基于linux的AC21设备固件的httpd二进制面向网络的功能中披露了10个缓冲区溢出漏洞(CVE-2022-40067至CVE-2022-40076)，这些漏洞都不需要与外围设备交互。为了在物联网软件上进行漏洞发现和漏洞验证，如果不需要这些特征和特征就可以运行的脆弱服务，通常不需要对这些特征和特征进行高保真仿真。事实上，对保真度的追求可能会使研究人员忽视其他潜在的技术，这些技术可能能够成功地实现特定目的的重新托管。

在本文中，我们提出了一种新的重托管技术:自动化单服务重托管。与其他重新托管解决方案不同，单服务重新托管不要求对操作系统或硬件进行高保真仿真。相反，我们设计了一系列技术，在重新托管固件服务期间自动发现执行障碍，使用干预工具包(例如，修补服务二进制文件以消除某些环境检查)来克服这些障碍，并验证打补丁的服务以检查我们的补丁是否破坏了预期的功能。由于不模拟特定于操作系统或硬件的特征和特性，我们的解决方案不仅避免了全系统技术遇到的陷阱(例如插入的重托管内核与嵌入式系统本身之间的不兼容性)，而且还支持用户空间仿真，这大大降低了全系统仿真技术所显示的执行开销。此外，用户空间模拟支持常见的漏洞发现和验证技术，例如覆盖引导的模糊测试。

我们开发了一个平台Greenhouse，通过用户空间模拟来执行单个服务的自动重新托管。我们的方法完全重新托管了7,140个抓取的固件映像中的2,841个web服务器，并使用routersplit框架成功确认了717个n天漏洞[36]。我们还将重新托管的镜像与afl++[39]集成在一起，在用户空间中进行模糊测试，实现了比最先进的固件模糊测试解决方案EQUAFL[41]高200%的吞吐量。然后，我们将此集成扩展到数据集中的2,612个目标，并发现了11,395个独特的崩溃。在这些目标中，我们进一步检查了14个重新托管的目标，其中有79个崩溃，并确认了26个为零日漏洞。

最后，在为Greenhouse开发服务验证检查的过程中，我们发现之前的工作错误地将无功能的重新托管固件服务报告为成功的重新托管目标。例如，FirmAE对重新托管的web服务器执行HTTP请求以确定重新托管成功，但不检查网页的内容或错误状态码(即，只检查服务是否响应某些内容)。这些无功能性服务在发现或评估漏洞方面用处有限。因此，我们还提出了区分重新托管失败、部分重新托管服务和完全重新托管服务的新标准。使用这种技术，我们的比较评估表明，Greenhouse在固件重新托管方面比最先进的工作稍微成功一些，但重新托管的大多是不同的固件，当与全系统重新托管方法结合使用时，产生3,981个独特的重新托管样本。

总之，我们的贡献是:
- 我们提出了一种新的重新托管技术，用户空间单服务重新托管，用于重新托管固件服务，以查找和评估物联网软件上的漏洞。我们在一个名为Greenhouse的原型中实现了这项技术。
- 我们彻底研究了重新托管过程，并提供了用户模式重新托管中模拟失败的原因(称为障碍)的详细分解，以及通用和特定的干预措施。
- 我们对来自9个不同供应商的7140个独特固件样本进行了大规模评估，并完全重新托管了2841个web服务器。我们还通过与最先进的固件模糊测试解决方案EQUAFL进行比较，展示了Greenhouse在漏洞发现和评估方面的独特优势。

本着开放科学的精神，我们在https://github:com/sefcom/Greenhouse公开发布温室和研究成果的来源。

## 2.背景和动机
重新托管是在模拟环境中重新创建一个或多个固件服务的行为的过程。鉴于物联网世界安全的严峻形势，大多数固件重托管技术旨在使安全分析技术，如自动漏洞发现[14,22,27,32,40]和漏洞风险评估(即评估漏洞对固件的实际影响)[5,21,42]能够在固件目标上执行。

在本节中，我们首先讨论现有作品的不同重新托管目标(第2.1节)。接下来，我们定义重新托管保真度(第2.2节)，将现有工作的目标和重点映射到不同的保真度水平，并确定研究差距(第2.3节)。最后，我们提出了填补空白的解决方案(第2.4节)。

### 2.1 重托管目标
固件及其原始硬件的刚性严重限制了研究人员可以进行的分析类型。因此，将自动化和可扩展的安全分析应用于固件服务的需求激发了固件重托管研究[13]。由于这些固件服务通常与其软件和硬件环境紧密耦合，因此即使模拟单个服务也可能需要重新创建所有底层硬件和软件组件。由于物联网固件的不同性质，为每个固件服务创建一个完美的仿真是复杂的。

研究人员将物联网固件分为三种类型[13,24]:Type-I固件，运行适应嵌入式环境的通用操作系统(如Linux)。Type-II型固件，它具有为嵌入式环境设计的定制操作系统，但仍然在应用层和内核之间具有区别。Type-III 型固件，也称为“单片固件”，其中代码是在设备上运行的单个blob，并使用专用接口与硬件进行交互。由于Type-II型和Type-III型固件与其硬件紧密耦合，与Type-I型重托管工具相比，Type-II型和Type-III型的通用重托管工具不太常见。

重新托管技术必须提供一个能够执行固件服务的虚拟环境，并根据其分析最小化重新托管环境与原始环境(即真实设备)之间的差异。例如，希望分析外围通信协议(例如USB)安全性的工作必须模拟或集成这些组件[19,27,33]。最小化环境差异的解决方案可以模拟中间硬件层[7,14]。

### 2.2 重托管保真度
模拟环境和原始环境之间的差异可能导致重新托管的服务表现不同，甚至无法运行。抽象地说，我们将仿真固件组件的保真度定义为它与真实设备上的相同组件相似的程度。我们进一步将静态组件(如文件)的保真度称为提取保真度，将动态组件(如服务的运行时行为)的保真度称为执行保真度。一般来说，组件与原始设备上的对应组件越相似，仿真的保真度就越高。

**提取的保真度**。固件映像中的静态组件包括存储在映像或硬件(例如NVRAM)中的文件和数据。研究人员通常从下载的固件映像和物理设备中提取这些组件。提取保真度高意味着原始设备上的大部分成分被获得或提取，而当提取失败或产生不完整的结果时，提取保真度低。

**执行的保真度**。固件服务的执行保真度可能会因外设(与服务通信以执行特定任务的硬件组件，例如控制LED和读取传感器数据)的存在或不存在而受到影响。在模拟服务中低执行保真度的例子包括意外行为、通信中断(例如，无法登录到模拟的web门户)、过早退出或崩溃。实现高级别的执行保真度对于漏洞发现和评估至关重要，因为由低执行保真度引起的行为可能导致假阳误报(如果意外崩溃被视为漏洞指示器)或假阴误报(当易受攻击的代码没有在模拟中运行时)。

**执行保真度和提取保真度**。高提取保真度对于高执行保真度至关重要，因为配置项和文件内容可能会影响固件服务的行为。图1说明了重新托管需求的层次结构。较低的层次更基本，更容易实现，而较高的层次通常更难实现。Costin[9]从仿真级别的角度考虑了这个层次结构，“完美”仿真对应于重托管金字塔的顶端，其次是原始内核、通用内核、用户域仿真，最后是无仿真器(数据提取)。Jetset[20]将其分为不同的方法，每种方法的保真度都在不断提高:不进行仿真的测试、部分重新托管、完全重新托管和硬件在环仿真。

![](images/Pasted%20image%2020230810163655.png)

### 2.3 现存方法
表1对现有的重托管技术进行了分类。大多数解决方案要么倾向于实现动态分析的高执行保真度，要么通过纯静态分析[12]或基于模型的方法[17,20]完全回避这个问题。

![](images/Pasted%20image%2020230810164018.png)

在考虑仿真的执行保真度的情况下，研究人员倾向于使用操作系统级别的仿真器，如qemu系统。即便如此，真实设备和仿真环境之间的配置、软件和硬件差异往往是不可避免的。解决这些差异需要大量的手工工作。此外，操作系统级仿真带来了很高的性能开销，特别是对于模糊测试等动态分析技术。

或者，像Costin[9]这样的工作考虑使用用户空间仿真进行动态分析。尽管具有较低的开销，但在用户空间中重新托管会导致模拟服务的保真度显著降低，作者指出这是“相当不稳定的”[9]。

Frankenstein [27]， FirmAFL[40]和EQUAFL[41]使用的解决方案是使用来自真实设备或全系统模拟器的快照来增强用户空间仿真的保真度。这导致了模糊器和重托管目标之间的紧密耦合，从而阻碍了重托管技术的通用性。例如，FirmAFL需要大量的手工工作来利用每个新的固件目标(详见附录)。

### 2.4 动机
现有技术表明，固件重新托管要求高执行保真度。然而，对于固件的安全分析来说，高执行保真度通常是不必要的，特别是当目标漏洞不需要高保真度时。

我们对过去两年内关于NVD[25]的100个固件cve进行了采样，发现其中只有14%与硬件相关。剩下的许多本质上是独立于难以模拟的、特定于设备的特性和功能的。例如，腾达披露了AC21路由器的httpd可执行文件中的10个漏洞，这些漏洞都没有与外设交互[35]。

固件设计可能要求模拟服务在到达易受攻击的程序点之前加载配置项、与外设通信或调用特定于设备的功能。研究人员建议通过提供低保真替代品来克服这些障碍，而不是盲目地增加执行保真度，例如使用存根[5,21,32]或模型[14,17,42]创建有限的仿真。我们的见解是，我们可以使用类似的方法来处理用户空间重新托管的低保真部分。为了提高整个仿真环境的执行保真度，不需要对硬件组件进行粗糙的、高强度的重新实现，而只需绕过这些障碍，只关注与潜在易受攻击代码的执行直接相关的组件，就足以满足安全分析的目的。

由于大多数物联网漏洞只涉及一个固件服务，因此我们专注于单个固件服务的用户模式模拟。通过仅围绕固件服务重新创建必要的仿真，我们的目标是获得高执行保真度的好处，而无需昂贵的全系统仿真。这使我们能够显著提高执行速度和重托管服务的可移植性。

## 3.单服务重托管
Greenhouse重新托管使用基于linux的操作系统的Type-I IoT设备(如2.1节所定义)。我们选择路由器是因为它们代表了物联网设备中最大和最常研究的子集。我们将自己限制在以下32位架构的固件映像:MIPS、MIPSEL、ARM和X86，因为它们代表了大多数公开可用的固件映像。

**固件上的单个服务**。考虑一个设备上的固件，它有多个正在运行的进程，这些进程在执行期间不断地交换信息。我们可以根据这些流程之间的数据层次结构来定义服务。单个服务表示映像中自包含的一组进程，这些进程不与主进程不是父进程的任何其他进程通信。例如，web服务器可以调用几个脚本来动态地为用户生成HTML内容。web服务器是主要进程，它与脚本一起构成单个服务。

Greenhouse专注于重新托管这些类型的固件服务。为了最小化执行开销，我们使用QEMU-user在chroot文件系统中模拟服务二进制文件来重新托管服务，我们称之为单服务重新托管，而不是其他解决方案使用的全系统重新托管(通过QEMU-system)。单服务重托管在用户空间中运行目标服务二进制文件，并且不模拟任何内核模块。

## 4.Greenhouse 概述
Greenhouse是一个用于单个固件服务的单服务重新托管的自动化系统。它包括三个主要组件:运行器Runner、检查器Checker和修复器Fixer。对这些主要组件进行补充的是一个Extractor组件，它执行初始镜像提取，以及一Exporter组件，它将重新托管的结果打包以供以后使用。在Greenhouse之外，我们创建了一个爬虫模块，该模块构建了我们评估中使用的初始固件数据集。

![](images/Pasted%20image%2020230810171207.png)

由Greenhouse重新托管的固件映像从Extractor开始，在Runner, Checker和Fixer之间的迭代循环中度过大部分重新托管过程，最后通过Exporter作为独立的Docker容器退出该进程。这个过程是完全自动化的。

而其他研究如Firmadyne[5]、FirmAE[21]和Costin等[9]包含执行其中一个或多个步骤的类似组件，它们一次应用所有修复。Greenhouse监视固件服务的执行，并有选择地应用必要的修复，从而最大化修复机会，同时最大限度地减少对执行保真度的降低。据我们所知，ARI[26]是唯一一个迭代重托管的工作。

### 4.1 文件系统提取
像现有的重新托管解决方案[5,8,12,21,26,41]一样，Greenhouse使用Binwalk来提取安装了所有可选依赖项的文件。我们使用`-M` (Mashotrya)和`--preserve-symlinks`来运行Binwalk，以递归地从固件映像中提取根文件系统并保留符号链接。从理论上讲，Greenhouse支持重新托管任何类型的单一服务。在我们的评估中，我们重新托管HTTP web服务器，UPnP服务器和DNS服务器。

### 4.2 目标仿真
Runner是Greenhouse迭代重托管循环的核心，它通过QEMU-user在Docker容器中执行每个web服务器。我们使用Docker容器来简化迭代之间的拆解和设置，因为每次运行都会在文件系统和环境中留下工件，如果不清理可能会影响后续的模拟。我们使用chroot来确保对重新托管的web服务器可见的文件系统与设备上的文件系统相同。Runner支持两种跟踪模式:在部分跟踪模式下，收集父进程和所有子进程的系统调用跟踪。在完全跟踪模式下，它收集父进程和所有子进程的系统调用和指令跟踪(包括所有执行的基本块的地址)。

Runner启动web服务器，等待60秒，然后调用Checker组件来测试web服务器。如果Checker组件认为服务已成功重新托管，则模拟和重新托管循环将终止。否则，Runner将解析生成的跟踪日志并等待潜在的等待循环。如果它检测到等待循环，或者在模拟中花费的时间超过阈值，Runner将强制终止模拟。否则，它继续等待并定期(例如，每10秒)对web服务器运行检查器。这种设计是为了处理固件服务之间启动时间的显著差异——使用固定延迟是不可行的。

在模拟结束时，将收集所有跟踪日志并将其发送到Fixer。

### 4.3 保真度测试
Checker组件测试重托管服务的保真度(由Runner模拟)，并将结果传递给Fixer，Fixer随后决定应用哪些干预。

Checker将固件的品牌名称和要测试的潜在端口的初始列表作为输入。我们使用特定于服务类型(HTTP、UPnP或DNS)的Checker来检查服务的连通性和测试行为。Checker使用来自Runner的检查结果和trace日志来确定重托管服务的执行保真度级别(详见第5节)。

虽然我们只实现三种类型的Checkers进行评估，但用户可以插入其他Checkers来重新托管其他类型的服务。

### 4.4 服务修复
Greenhouse通过Fixer执行运行时干预，从而绕过在迭代重托管过程中遇到的重托管障碍。它使用来自Runner的跟踪和错误日志来诊断限制执行保真度的潜在障碍。对于每个路障，Fixer应用相应的干预，我们将在第6节中详细介绍。

在对所有确定的障碍应用干预之后，Fixer将修改后的文件系统和web服务器二进制文件传递给Runner，以启动下一次重新托管迭代。我们重复这个循环，直到模拟图像被重新托管到足够的执行保真度水平(由检查器确定)，直到我们达到无法提高保真度的点，或者我们达到迭代循环的最大次数(经验上，在我们的实验中，25)。重新托管的文件系统然后由Exporter打包。

### 4.5导出结果
Exporter创建一个tar文件，其中包含重新托管的文件系统、一组用于运行重新托管服务的脚本、登录的用户名和密码等元信息，以及指定运行重新托管服务所需的容器级信息(例如，网络设备)的Docker compose文件。

## 5.重托管指标
>重托管仿真度指标主要分为四个等级，Unpack, Execute, Connect, Interact。分别是能提取出程序文件、程序能执行、服务有响应、服务可交互。

Greenhouse的迭代方法逐渐提高了用户空间模拟的执行保真度，直到重新托管成功。本节讨论了Greenhouse用于确定它在给定服务上实现的成功程度的指标，这些指标分为几个阶段，以及Greenhouse如何定义和衡量每个阶段的成功背后的原因。在模拟目标服务期间，每个阶段都表示对执行保真度级别的切实提高，如第2.2节所述。

现有的重新托管技术根据其目标和分析重点定义了广泛的成功度量标准。这些指标包括将执行轨迹映射到预期行为[20,40]，检测功能网络行为[5,9,21]，或执行而不崩溃[41]。通过成功的分析发现新的未被发现的漏洞的能力进一步证明了重新托管是有效的[7,14,28,32,40 - 42]。

将这些阶段分开就是重新设置阻碍执行保真度进展的障碍。正如第2.4节所讨论的，这些障碍是原始设备和运行重托管服务的模拟环境之间的差异。我们通过手动检查数百个固件样本，并为其中许多开发干预措施，以经验确定了一组常见的障碍。第6节讨论了遇到的障碍类型和greenhouse的干预措施，以更详细地解决它们。

通过基于遇到的障碍迭代地应用这些干预措施，Greenhouse可以将服务的特定提取保真度和执行保真度提升到可以有效应用动态分析技术(例如，模糊测试)的水平。

**Stage 1:解包**。要开始单服务重新托管，Greenhouse必须首先解压缩固件映像并从中提取完整的文件系统。因为Greenhouse只支持Type-I固件，所以我们认为在这个阶段成功提取一个可识别的基于linux的Type-I文件系统是成功的，这是由一个受支持架构的shell(例如，/bin/busybox或/bin/sh)二进制文件的存在所指示的。无法定位这些二进制文件是低提取保真度的标志，这需要额外的解包工作。

**Stage 2:执行**。Greenhouse没有尝试模拟整个boot环境，而是使用一组通用可执行名称来定位与目标服务关联的可执行二进制文件，此列表根据目标服务的类型(HTTP、UPnP或DNS)而有所不同。Greenhouse使用QEMU-user验证所标识的二进制文件是否可以在chroot环境中执行。由于此阶段更关注于实现高提取保真度而不是执行保真度，因此即使进程在执行后立即退出或崩溃，我们也认为该阶段是成功的。

**Stage 3:连接**。此阶段的目标是实现与仿真固件服务的最低级别通信。这通常需要模拟服务执行其环境检查并绑定到其所需地址的一个或多个端口。达到这一阶段对于任何动态漏洞分析技术都是至关重要的，因为许多固件漏洞都涉及与其面向网络的服务进行通信。

如果我们能够连接到重新托管的服务，而没有它终止、超时或过早崩溃，那么我们认为这个阶段是成功的。因为不同的服务有不同的网络协议，每个插件都有自己的逻辑来检查连接。例如，HTTP插件发送一个HTTP请求，并检查是否收到了响应(同时忽略响应的状态码)，这与FirmAE中的成功度量相同。这一阶段的成功表明重新托管已经达到了低水平的执行保真度，这可能足以在某些情况下进行动态分析(例如，在web服务器的请求解析代码中发现漏洞)。

**Stage 4:交互**。一旦达到较低的执行保真度水平，Greenhouse就会尝试将重新托管驱动到尽可能高的执行保真度水平。请注意，Greenhouse可能会执行一些干预措施，这些干预措施几乎不会改善甚至会损害模拟的其他部分，但对于我们的分析目的而言，这些干预措施确实提高了目标服务的保真度。例如，Greenhouse可以删除服务的CAPTCHA检查，以简化web服务器暴露的CGI处理程序内部崩溃的模糊检测。

当然，不同服务类型的交互检查器差别很大。为了确定web服务器是否以高执行保真度级别运行，Greenhouse执行与模拟web服务的基本交互。它检查HTTP响应的状态码，并将返回的内容与一组预先设置的错误字符串进行比较，以识别出现故障的后端。它还使用Selenium来加载动态内容并尝试一些常见的登录协议。对于DNS服务器，Greenhouse中的DNS插件发出解析localhost的请求并解析结果DNS应答(如果有的话)。通过开发特定于协议的Checkers, Greenhouse提供了通用的启发式方法来确定面向网络的服务的保真度，而不依赖于极端情况。虽然这些检查并不是对重新托管的服务的详尽测试，但我们在第7节中的评估将表明，重新托管服务到这个阶段对于许多漏洞发现和评估任务来说已经足够了。

## 6.障碍和干预
当试图提高图像的提取和执行保真度时，可能会出现限制进展的多种并发症。我们将这些障碍称为重托管障碍(rehosting roadblocks)，并将其相应的解决方案称为干预措施(interventions)。本节确定了常见的障碍，并提出了几个可自动化的干预措施，我们在Greenhouse中实现了这些干预措施。本文还讨论了这些障碍在单服务和全系统重新托管之间的区别。

### 6.1 障碍
虽然不同固件的复杂性不同，但在开发Greenhouse的过程中，我们发现它们之间有许多相似之处和重叠之处，甚至在不同品牌之间也是如此。之前的研究已经详细讨论了丢失路径(R1)、外设访问(R3)、NVRAM支持(R4)和网络接口(R5)等问题;我们包含它们是为了完整性，并强调用户空间重新托管的考虑如何影响这些障碍。

**Missing Paths(R1)**.初始提取包含损坏的符号链接、丢失的文件/文件夹或丢失/放错位置的库文件。通常，这些文件是作为启动时运行的初始化脚本的一部分生成或解压缩的，其中包含对正确执行固件二进制文件至关重要的数据。全系统重新托管解决方案将这些初始化脚本作为默认的操作系统引导行为运行，而如果重新托管服务不生成这些路径，则单服务重新托管必须推断这些路径。

**Runtime Arguments(R2)**.一些二进制文件在运行时在命令行上进行特定的配置(例如，到webroot内容的路径，绑定到的默认启动端口等)。这个问题是单服务重新托管所特有的，因为大多数全系统重新托管解决方案将问题委托给操作系统在启动时运行的初始化脚本。

**Peripheral Access(R3)**.全系统和单服务模拟的常见障碍。固件服务可能尝试以各种方式与硬件外设通信，从访问/dev下的文件到直接访问保留的内存区域。在我们有限的模拟中，这些行为通常会导致崩溃或退出。

**NVRAM Configurations(R4)**.NVRAM(非易失性随机存取存储器)是许多固件路由器常见的硬件组件。以前的工作，如FirmAE和Firmadyne已经将其确定为核心组件，通常包含启动和运行固件映像所需的默认配置数据。由于QEMU没有显式实现NVRAM，因此全系统和单服务模拟都必须解决这个问题。

**Hard-coded Network Devices(R5)**.网络服务可能有硬编码的“默认”IP地址或它们绑定的设备名称。如果具有该地址或名称的网络设备不存在，则服务将失败。在单服务重托管中，由于QEMU-user中的TCP/IP栈实现不完整(例如，它不支持IPV6_RECVORIGDSTADDR)，这将进一步复杂化。

**Multi-Binary Behavior(R6)**.除了在启动时由初始化脚本生成的配置文件外，一些web服务器可能会通过IPC(进程间通信)生成内容或加载配置，并在后台运行单独的守护进程。单服务重新托管必须显式地运行这些进程，而全系统重新托管作为操作系统引导过程的一部分运行这些进程。

**Environment Checks(R7)**.一个包揽一切的类别，涵盖固件二进制文件可能在其环境中执行的任何杂项检查。例如:检查DNS/web访问，检查我们正在执行的用户/组，检查环境变量，检查CPU资源使用情况。我们通过它们在不满足某些条件时退出的共同行为来描述这些检查。

**Environment Mangling(R8)**.许多固件二进制文件在封闭的环境中运行，这使得它们的行为完全不受其他进程的影响。这些行为可能会破坏或破坏模拟环境中不希望对模拟服务可见的部分。例如，固件二进制文件可能重定向标准输出和标准错误，然后关闭所有其他文件描述符，假设它是唯一使用文件系统I/O的进程。这破坏了QEMU-user完成的日志记录，而Greenhouse依赖于此收集关键数据以识别路障。全系统重新托管可以通过使用os级日志基础设施来避免这个问题。

### 6.2 干预
前面提到的每个障碍都有相应的干预措施。干预措施要么试图满足路障规定的标准，要么绕过它。虽然实现障碍通常会带来更好的保真度，而绕过障碍则会降低保真度，但在每个特定系统上确定每个特定障碍的标准并不是一个可扩展的解决方案。

Greenhouse实现了一种“尽力而为”的干预系统，在返回到修补程序之前，它试图完成尽可能多的障碍。

之前的研究描述了路障R1、R3、R4和R5的解决方案。一些解决方案类似于下面的解决方案，例如文件设置(I1)、文件清理(I2)、启动同步(I3)、使用nvram-faker库(I4)和创建虚拟网络接口(I6)。Greenhouse的独特之处在于，它的干预措施只能解决用户空间的障碍(I5、I7和I8)，而我们的补丁系统可以操纵服务二进制文件来绕过检查。由于环境Mangling的复杂性，我们还调整了一些现有的干预措施来适应用户空间(R8)。

**File Setup (I1)** - [R1, R3, R7]。使用strace，我们通过过滤常见的文件访问系统调用(如open()和access())来检测丢失的文件。我们解析它们以寻找期望的路径，并在重新托管的文件系统中创建相应的空文件或文件夹。如果我们可以找到文件的备份，或者如果文件在我们的环境中被放错了位置，我们将其复制到所需的位置。与以前的重新托管方法不同，Greenhouse只添加重新托管服务尝试访问的丢失文件。这将最大限度地减少与运行时动态生成的文件的冲突。

**File Sanitization (I2)** - [R3, R7]。我们观察到，外设访问有时是通过/dev/节点上的I/O操作来执行的，可以通过用空文件替换节点来绕过。这可以处理由于在不存在的设备接口、管道或套接字上阻塞读取调用而导致服务挂起的情况。因此，在解压缩完成后，我们通过用空的常规文件替换除符号链接(块、字符设备、管道和套接字)之外的所有特殊文件，立即对文件系统进行“净化”。该方法基于FirmAE和Costin等人使用的类似解决方案。

**Boot-up Synchronization(I3)** - [R1, R2, R7]。我们使用FirmAE运行映像的全系统模拟并获取其“启动数据”，即运行时进程、文件和由其启动和初始化脚本创建或启动的QEMU串行日志。示例包括在引导过程中生成的文件、传递给服务的命令行参数以及加载到NVRAM中的任何配置数据。我们使用启动数据来提高保真度，而无需在用户空间中模拟操作系统的启动过程。我们的方法不同于类似的作品[40,41]，因为Greenhouse通过FirmAE增强但不依赖于FirmAE，正如第7节中只有Greenhouse可以重新托管的固件服务集所证明的那样。我们还进行了去除研究，表明在没有这种干预的情况下，Greenhouse的表现相对较好。

**nvram-faker(I4)** - [R4]。nvram-faker是一个开源项目，它通过将键值对存储为文件来模拟常见NVRAM库函数的行为[10]。Firmadyne和FirmAE使用类似的库来解决相同的障碍。我们使用nvram-set特性对其进行扩展，并为更多的NVRAM功能提供包装器。我们交叉编译一个独立版本的库，并替换在解压后的文件系统中默认的libvram.so。我们改进的nvram-faker记录固件使用的所有密钥，包括不属于当前字典的密钥。然后，Greenhouse尝试在下一次仿真迭代中提供一个键值对，该键值来自基于启动数据中的NVRAM值或默认值对列表。正如FirmAE所观察到的，提供一个空字符串值可以显著减少崩溃。Greenhouse通过使用从在线资源和我们的数据集生成的每个品牌的通用键值对的字典进一步实现了这一点。在评估期间，我们发现提供这些非空的默认值可以将许多部分重新托管的服务转换为完全重新托管的服务。

**Runtime ArgParser(I5)** - [R2]。如果不能从启动数据中获得固件二进制文件的命令行参数，我们提供一个备用干预。一个简单的基于启发式的正则表达式解析器使用web服务器的品牌和名称来解析潜在的运行时参数，并为它们提供通用的默认值。单服务和全系统重新托管都可以进行这种干预。

**Dummy Network Devices(I6)** - [R5]。我们采用了FirmAE的这种方法。在Greenhouse中，一个修改过的QEMU bind()系统调用会记录任何在网络地址或设备名称上尝试绑定的情况。然后Greenhouse用相应的网桥在我们的模拟中配置Docker容器。如果二进制文件必须在Docker容器之外运行，Greenhouse会提供一个自动生成的脚本来创建虚拟设备。

**Background Script Plugins (I7)**  - [R6]。虽然处理多服务目标的通用解决方案超出了范围，但是Greenhouse为必须与其他后台进程通信的目标服务提供了一个特定的解决方案。Greenhouse允许可插拔的启发式方法来识别后台进程的可执行文件以及如何运行它们。Greenhouse为xmldb和config提供插件，它们分别被D-Link和Netgear固件使用来设置和检索配置数据。

**IPv6 Workaround (I8)** - [R5]。许多新的物联网设备，包括路由器，都使用IPv6进行通信。运行Greenhouse的主机并不总是支持这一点，比如我们进行评估的Kubernetes集群。IPv6在QEMU-user中的实现也是不完整的。因此，我们在QEMU中实现了一个解决方案，将所有到IPv6地址的绑定转移到IPv4地址0.0.0.0，并确保带有未实现或不支持的IPv6标志的套接字操作总是成功。

**Patching sysinfo() (I9)** - [R7]。有些路由器会根据负载自适应禁用服务，这给动态分析带来困难。当在相同的Kubernetes节点上运行多个Greenhouse模拟时，这在大规模分析中尤其明显。我们给QEMU打了补丁，所以sysinfo()总是返回0来防止这些行为。

**Logging Behavior (I10)** - [R8]。我们在用户模式下的模拟与模拟服务共享文件描述符。此问题仅适用于单服务重新托管。为了确保我们的仿真跟踪日志不被打乱，我们修改open()和close()系统调用，以及QEMU跟踪函数的行为，为我们的日志文件保留一个文件描述符范围(300 - 400)。尝试关闭此范围内的描述符将返回失败。

### 6.3修补
在我们的具体干预措施不足的情况下，Greenhouse尝试直接修补固件二进制文件，以绕过阻止它进入下一阶段的代码部分。虽然这可能会降低固件二进制文件的提取和执行保真度，但我们发现，通过将补丁类型限制在特定条件下，它在启用进一步重新托管方面非常有效。

Greenhouse处理三种类型的补丁:一个过早退出补丁，一个等待循环补丁，和一个崩溃指令补丁。为了自动识别相关补丁，我们使用angr[30]构建固件二进制文件的上下文敏感控制流图(CFG)。CFG中的每个节点通过其地址和在CFG中调用它的所有块的地址来区分。这允许我们将二进制文件的执行轨迹映射到过早退出和等待循环补丁的CFG。

**过早退出补丁**。过早退出补丁处理二进制文件测试某种检查结果的一般情况，如果检查失败，则分支到退出函数。通过识别导致退出函数的固件二进制文件所采用的分支指令，我们可以翻转分支以完全绕过检查。为此，Greenhouse将固件二进制文件的执行轨迹映射到上下文敏感的CFG，并扫描对exit()或abort()的调用。如果找不到这样的函数签名，但二进制文件干净地退出，则假定执行跟踪中的最后一条指令是退出函数。

Patcher然后递归的修建上下文敏感的CFG从退出调用到在映射trace内最近的支配者(dominator)，它是满足下面条件的孩子的父亲：(1)不支配(2)不是原始trace的一部分。因为所有在支配者之前的节点最终都通向出口，所以我们可以假设这个区块对应于通向出口的关键分支点。然后，我们在块中搜索相关跳转指令，并将其修补为指向未被占用的分支。

在实践中，这个补丁是有效的处理大多数环境检查(R7)和某些类型的外设访问(R3)。当二进制文件需要内容时，它还可以帮助补偿导致空文件读取(I1)的干预。

**等待循环补丁**。等待循环补丁处理的情况不是退出二进制，而是被困在一个恒定的循环，等待来自另一个进程的外部输入。示例包括在基本web连接检查中用于网络活动的poll()，或者在等待特定外设连接时使用sleep()循环。

等待循环补丁使用映射到执行trace的相同上下文敏感的CFG来确定程序正在循环。它试图找到不属于原始执行跟踪的分支节点，并且不会立即引导回循环。由于许多固件二进制文件本质上是大循环，我们将自己限制为不超过30个基本块的“紧密”循环。

为了确保我们不会无意中修补负责处理传入服务器请求的代码部分，此补丁仅在超时后未检测到网络连接的情况下调用。与过早退出补丁类似，等待循环补丁是一种通用干预，用于处理环境检查(R7)和外围访问(R3)路障的子集。

**崩溃指令补丁**。崩溃指令补丁通常不需要CFG。它获取执行跟踪中最后记录的指令的地址，将其映射到固件二进制文件中相应的基本块，并对将要执行的下一条指令进行修补，用nops替换它。在指令位于二进制文件的地址空间之外的情况下，例如在库调用中，Patch使用CFG来确定调用者指令的地址，并在那里放置一个nop。

这个补丁只在仿真期间检测到分段错误时调用，因为它假定下一条将被记录的指令导致了错误。虽然这可能对固件二进制文件和仿真的整体保真度具有高度破坏性，但它是处理无效直接内存访问的最干净的方法之一，例如在R3中。

## 7.评估
我们设计了一系列实验来回答以下研究问题:
- 与最先进的全系统重托管解决方案相比，Greenhouse的重托管性能如何?(7.2节)
- 影响Greenhouse重托管性能的因素有哪些?(7.3节)
- Greenhouse是否达到了允许漏洞发现和风险评估的执行保真度级别?(7.4节)
- Greenhouse重托管服务在多大程度上提高了模糊测试性能?(7.5节)

**评估环境**。我们在一个包含42个节点和超过2000个CPU内核的Kubernetes集群上进行了所有的实验。我们并行运行300个pods，并为每个pod分配至少2个CPU内核和16GB RAM。我们修改了FirmAE和EQUAFL，以便在Kubernetes集群上运行。我们的修改将在我们开放所有研究工件源代码时发布。

### 7.1 固件镜像收集
为了确保我们拥有最新固件样本的路由器型号的广泛覆盖，我们通过爬行九个知名路由器品牌(华硕，Belkin, D-Link, Linksys, Netgear, Tenda, TP-Link, TRENDnet和Zyxel)的网站建立了自己的固件映像集合，并下载所有版本的可获得的路由器和摄像头固件映像。这提供了12,943个固件映像。我们对它们进行了过滤，并删除了加密的或不完整的映像，以及任何不类似于Type-I基于linux的固件的映像。我们还删除了运行在不受支持的架构上的映像。然后，我们将剩余的图像与FirmAE的数据集合并，并删除重复的图像。与FirmAE一样，我们获得了每个设备的最新版本固件(截至2023年2月)，根据型号，版本号和地区进行识别。我们最终的固件映像集合包括跨越1,764个唯一设备的7,140个唯一映像。这个集合是FirmAE数据集(1124张图片)的6.3倍，是Costin等人数据集(1925张图片)的3.7倍。

### 7.2 固件重托管结果
我们将Greenhouse与FirmAE和EQUAFL进行比较。EQUAFL作为一种模糊测试解决方案，是Firmadyne的扩展。由于FirmAE是基于Firmadyne的，并且其表现严格优于Firmadyne，因此我们不针对Firmadyne进行评估。

我们还考虑了Costin等人，他们研究了多种仿真方法，并通过QEMU确定了全系统仿真。因为它与Firmadyne相似，所以我们不将Greenhouse与Costin进行比较。

不同类型的业务具有不同的网络协议。我们的重新托管平台目前支持三种类型的网络服务:HTTP、UPnP和DNS。与之前的研究一样，我们将评估重点放在web服务器上，同时报告UPnP和DNS服务器的重新托管结果。

**确定执行保真度的级别**。我们使用Checker组件根据第5节中描述的阶段来确定执行保真度。此外，我们解析Greenhouse、EQUAFL和FirmAE的日志，以确定每个映像的Unpack和Execute成功的程度。对于Greenhouse，如果我们找到一个web服务器可执行文件，我们认为Unpack成功;如果我们可以在QEMU-user中运行它，直到检测到bind()系统调用，我们认为Execute成功。对于EQUAFL和FirmAE，如果它们能够找到并挂载文件系统映像，我们就认为Unpack成功;如果它们能够在qemu系统中引导映像并尝试启用网络接口，我们就认为执行成功。我们为FirmAE定义了一个成功的连接，它是一个不会超时的curl请求。

![](images/Pasted%20image%2020230811112424.png)

结果。表2显示了到达每个重托管阶段的重托管固件服务(或FirmAE的映像)的数量。表3显示了针对数据集中最新固件的每个设备成功重托管的数量。总的来说，在最新(538对558)和总(2,841对2,403)固件映像上，Greenhouse重托管固件服务的数量与FirmAE相当。对于一些品牌(如华硕、贝尔金和腾达)来说，Greenhouse明显更成功，而对于其他品牌(如Netgear和TP-Link)则不太成功。EQUAFL可以执行2,417个目标，但只能重新托管442个，并且重新托管两个品牌(ASUS和Tenda)失败。

![](images/Pasted%20image%2020230811112549.png)

**重托管服务之间的重叠**。我们检查了FirmAE和Greenhouse重新托管服务之间的重叠。我们排除了EQUAFL，因为它的重托管性能很差。有趣的是，如表4所示，Greenhouse完全重新托管的固件服务集与FirmAE重新托管的固件服务集几乎没有重叠。FirmAE和Greenhouse可以重新托管7140个服务中的3981个，比任何一个解决方案单独重新托管的服务都多出近50%。这表明Greenhouse处理了全系统仿真技术无法处理的独特的重托管障碍。

![](images/Pasted%20image%2020230811112846.png)

**重新托管其他服务**。我们使用SaTC[6]首先确定通用网络服务的可执行文件的名称。我们手动管理这些名称，以生成与这些服务关联的常见HTTP、UPnP和DNS服务器二进制文件的列表。表5显示，Greenhouse重新托管了50.1%的找到的HTTP web服务器、43.9%的找到的UPnP服务器和47.2%的找到的DNS服务器。这表明Greenhouse的方法并不局限于web服务器，并且可以扩展到重新托管其他类型的固件服务。

![](images/Pasted%20image%2020230811113137.png)

每项干预措施的影响。为了演示每种干预如何有助于Greenhouse的总体重托管成功，我们多次重新运行Greenhouse以重托管HTTP web服务器二进制文件，每次禁用八个干预(I1-I8)中的一个。我们不包括干预措施I9和I10，因为它们是Greenhouse运行所必需的。我们还包含了一个禁用Patcher程序(第6.3节)的运行，以研究我们的二进制补丁组件的影响。表6显示了禁用特定干预措施后每次运行的详细情况。

![](images/Pasted%20image%2020230811113325.png)

值得注意的是，在完整运行的情况下，Greenhouse可以重新托管2,841个目标中的2,455个(86.4%)，而无需使用来自FirmAE (no_bootsync)的数据来增强其启动环境。当禁用基于启发式的运行时参数干预(no_args)时，这个数字显著下降(降至1,787或62.9%)。我们还注意到，禁用IPv6变通方法(no_ipv6)对重新托管结果的影响最小(2562或90.2%)。经过手动调查，我们发现在许多情况下，固件服务同时支持IPv4和IPv6，补丁程序强制服务仅使用IPv4执行而不终止。在没有文件清理(no_sanitize)的情况下运行会在我们的大规模管道中造成重大问题:不替换特殊文件会导致许多固件示例挂起、崩溃，甚至破坏重新托管环境。因此，表6中I2的数字(用\*标记)是基于完成的样本的推断。

### 7.3 案例研究
#### 7.3.1 ASUS 固件
我们检查了华硕固件服务，其中Greenhouse将846个中的789个重新托管到交互阶段，而FirmAE只重新托管了11个。虽然Greenhouse和FirmAE都将类似数量的服务重新托管到Execute阶段，但FirmAE几乎无法连接到其中的一半，只有11个能够进行交互。

**配置重用**。我们首先分析了FirmAE重新托管到Execute但无法连接，而Greenhouse成功地重新托管到Connect的257个华硕服务。这代表了一组服务，我们的干预可能减轻了与网络连接相关的障碍。Greenhouse使用了255个外部来源的NVRAM数据，其中最显著的是来自其他Netgear图像的NVRAM数据。NVRAM的关键值包括lan_ipaddr和env_path，它们会直接影响服务的执行。通过重用来自我们集合中的其他映像的配置信息，Greenhouse将更多服务重新托管到Connect阶段。

**迭代的干预措施**。然后，我们分析了531个华硕服务，FirmAE重新托管到Connect，但没有交互，Greenhouse重新托管到交互。对于这些服务中的大多数(531个中的461个)，FirmAE中的模拟服务返回的HTTP状态码为200，但实际的网页显示的是文件未找到错误消息。其余的服务要么超时，要么返回空HTML页面，要么遇到身份验证问题。这类服务不太适合用于分析，因为它们可能缺少影响相关服务的仿真环境部分。

在其中的517个案例中，Greenhouse通过迭代干预解决了这个问题，包括重新定位丢失的文件(例如，QIS_wizard.html或cert.pem)。由此可见，Greenhouse干预对重托管服务执行保真度的影响。

综上所述，由于干预措施及其迭代应用，Greenhouse的表现优于FirmAE。我们还跨固件迁移了关键配置数据，这是FirmAE无法做到的。

#### 7.3.2 Tenda 固件
Greenhouse使用等待循环补丁程序修补了55个仅Greenhouse重新托管的Tenda服务中的52个，并对52个Tenda服务中的26个应用了过早退出补丁程序。经过手工分析，我们确定了一些Tenda服务的一个关键障碍:ConnectCFM()函数。该函数访问cfm二进制文件，cfm二进制文件与cfm外设的接口，cfm外设在重新启动时保存配置数据[37]。当无法访问CFM时，web服务器要么无限重试，要么退出，并显示错误信息“connect cfm failed!”在启动任何网络行为之前。通过修补导致代码退出或循环的检查，Greenhouse强制执行面向网络的代码。

#### 7.3.3 TP-Link 固件
我们研究了为什么Greenhouse成功地重新托管了比FirmAE少得多的Netgear和TP-Link服务。主要原因是Netgear和TP-Link固件中的许多web服务器严重依赖于与web服务器本身没有启动的其他进程的通信。例如，TP-Link web服务器通过dbus-daemon将所有HTTP流量代理给另一个服务，并且dbus-daemon和另一个服务都必须以init.d脚本启动。严格地说，这些目标不属于单服务重新托管，但为了公平起见，我们仍然将它们报告为重新托管失败。我们把单用户、多服务重新托管留给未来的工作。

### 7.4 漏洞风险评估
为了评估重托管服务对漏洞风险评估的适用性，我们遵循了FirmAE的惯例，使用了自动利用框架routersplit。以前的研究也使用了routersplit进行评估[5,9]。我们选择了所有重新托管的web服务器，这些服务器至少达到了连接，对于Greenhouse(3,526)和FirmAE(4,058)，并对每个服务重放了125个已知的N-day漏洞。

**结果**。如表7所示，routersplit利用了3526个Greenhouse重托管固件服务中的717个已知漏洞。与此同时，routersplit在FirmAE重新托管的4058个样本中发现了844个已知漏洞。尽管没有进行完整的系统模拟或外围设备建模，但是Greenhouse重新托管的服务足以用于漏洞风险评估。

![](images/Pasted%20image%2020230814090839.png)

### 7.5 模糊测试重托管服务
重新托管的一个关键应用程序是自动漏洞发现，特别是模糊检测。为了评估Greenhouse重托管服务对模糊测试的适用性，我们使用afl++对Greenhouse重托管达到Connect的保真度的3,526个固件图像进行模糊处理。我们将我们的结果与对I型固件进行用户空间模糊测试的最接近的工作进行比较，EQUAFL。由于资源限制，我们将选择限制为2,612个随机选择的样本，确保包括来自EQUAFL数据集的70个样本，即使Greenhouse无法重新托管所有样本。因为在编写本文时完整的EQUAFL数据集不可用，所以当我们无法定位到EQUAFL使用的原始样本时，我们使用设备的最新固件映像。

此外，我们使用Greenhouse+AFL和EQUAFL对来自EQUAFL数据集的八个固件映像进行了Greenhouse用户空间仿真性能评估。由于EQUAFL将自己定位为对FirmAFL的严格改进，我们不会重新评估FirmAFL。最后，我们手动分析了8个重新托管的EQUAFL图像和6个随机选择的图像(表9)的模糊测试结果，以确认我们的重新托管模拟可以找到真实世界的漏洞。

我们选择了afl++作为模糊器，并为web服务器构建了一个通用的模糊测试工具，它模拟了AFL- qemu中的客户端连接。我们在附录中讨论了harness的实现以及为什么FirmAFL和EQUAFL不会泛化到看不见的固件目标。

#### 7.5.1 性能评估vs EQUAFL
每个模糊测试都在运行Ubuntu 22.04 LTS的裸机服务器上的Docker容器中进行，该服务器具有80核Intel Xeon Gold 5218R 2.10GHz CPU和270GB RAM。对于8个EQUAFL目标，我们分别运行我们的模糊器和EQUAFL的模糊器10次，每次24小时，并随时间测量执行速度和总语料库计数。

图3显示了在8台重新托管的httpd服务器上使用AFL在Greenhouse上对EQUAFL进行模糊测试的性能。平均而言，Greenhouse重新托管服务(本地用户空间模拟)比EQUAFL的同步文件系统方法快2倍。

![](images/Pasted%20image%2020230814092104.png)

#### 7.5.2 大规模模糊测试
EQUAFL将模糊目标定义为“应用程序过程可以由模糊器启动，而不会显式报告错误”的目标。我们对2,612个模糊样本使用相同的定义。表8显示了Greenhouse使用与EQUAFL评估类似的指标重新托管的2,612个样本的模糊性。

![](images/Pasted%20image%2020230814092328.png)

我们还发现，在EQUAFL数据集的70个镜像中，Greenhouse只能模糊测试其中的45个。然而，我们注意到Greenhouse可以模糊总共1,787个镜像(68.4%的测试集)，并在733个目标上发现总共18,599次原始崩溃。由于EQUAFL可以模糊测试的目标数量受到其耦合的全系统仿真可以重托管的限制，我们认为EQUAFL限制在不超过571个目标。这证明了Greenhouse的大规模重托管和分析方法的可扩展性。

#### 7.5.3 真实世界漏洞
由于需要对所有1,787固件映像进行手动崩溃分类，因此我们将分析局限于表9中发现的14个服务的崩溃子集。我们首先使用tmin和md5sum过滤崩溃输入，以识别唯一的崩溃。然后，一名人工分析师检查这些过滤后的崩溃，看看它们是否为误报。总的来说，我们在这14个服务中发现了79个独特的崩溃。我们确认，79个漏洞中有26个是固件服务中的合法0-day漏洞，并已将此信息披露给各自的供应商。分析的79个崩溃中没有一个是由Greenhouse中的二进制补丁引入的。在附录中可以找到将每个崩溃映射到各自漏洞的详细信息。

## 8.局限性
**加密的固件**。Greenhouse需要高提取保真度来执行其迭代重托管方法。我们的修补方法也使用嵌入函数符号，如exit()。我们将自己限制在重新托管相对完整、协作(没有隐藏的、恶意的或混淆的二进制文件)和未加密的固件映像。

**QEMU的局限性**。Greenhouse使用QEMU-user来执行用户空间仿真，并且受到仿真器的任何缺陷和限制的影响。例如，QEMU-user对MIPS下的clone()系统调用的支持有限。由于在用户模式下运行模拟器时抽象的限制，除非使用非常特定的标志调用clone()，否则QEMU将无法正确地模拟它。这导致许多使用clone()实现fork服务器的MIPSEL二进制文件失败。我们估计这影响了7140个案例中的147个，约占我们固件样本收集的2%。我们计划在QEMU-user中修复这个问题，并向上游提交补丁。

**angr的局限性**。Greenhouse使用angr创建CFG，因此受到angr的缺陷和限制。许多MIPS目标(68个，占我们收集的0.9%)在构建CFG时由于angr的断言失败而崩溃。

**缺少库函数**。一些固件使用包含自定义函数的库，通常用于与外设交互。如果在提取过程中由于提取保真度低而缺少这些库，则进一步重新托管几乎是不可能的。在某些情况下，这些函数可以在我们替换的libvram库中找到，这使问题进一步复杂化。缓解这个障碍需要在重新托管期间为每个特殊情况动态注入自定义存根函数，我们计划在未来将其作为一个工程问题来解决。

**打补丁时误报**。Greenhouse的补丁可能会在模糊测试中引入误报。尽管我们在手工检查的集合中没有遇到任何这样的假阳性，但存在这种可能性。最可能发生这种情况的方式是Greenhouse修补了负责安全检查的分支指令。为了减轻这种情况，Greenhouse在导出的仿真中保留了它修补的二进制文件的原始副本，以及所有修补过的指令地址的记录。对崩溃进行分类的人工分析人员可以将其与原始二进制文件进行比较，以确定根本原因是否与Greenhouse patch有关。

## 9.相关工作
**大规模的仿真**。Costin等人[9]是最早研究固件重托管不同仿真方法可行性的工作之一。它尝试通过chroot和用户空间模拟重新托管。然而，作者得出结论，保真度损失太大，用户空间模拟无法使用，并决定使用全系统模拟器进行重托管。最近对Type-I固件进行大规模重托管的工作[5,21,23,38]也建立在操作系统级模拟器的基础上，并使用该模拟器自动重托管固件映像。与Greenhouse一样，这些方法自动识别全系统仿真障碍并应用干预措施来解决它们。

Greenhouse与这些工作的不同之处在于，它在模仿什么方面更具选择性。因为它专注于在用户空间中重新托管单个服务，所以Greenhouse可以精确地迭代地应用干预。如果没有找到适当的干预，Greenhouse会尝试修补二进制文件。

ARI[26]采用了类似的方法:它扩展了Firmadyne，并应用干预来处理基于linux的固件上的不同故障情况。ARI使用自己的保真度标准迭代地模拟、测试和修复固件映像，在连通性和交互性方面与Greenhouse有类似的区别。但是，ARI不打补丁，仍然依赖于Firmadyne的全系统模拟来重新托管固件映像。因此，ARI技术和Greenhouse技术是具有相似之处的正交技术。

**用户空间模拟**。研究人员已经在用户空间探索模糊固件图像。FirmAFL[40]将用户空间执行与全系统仿真相结合。EQUAFL[41]通过将重新托管的固件映像的文件系统状态移植到用户空间，完全在用户空间中模糊化。正如附录中所讨论的，这些技术需要大量的手工工作来支持新的目标，并且不能扩展。它们的性能还取决于与之耦合的全系统仿真技术。Greenhouse完全在用户空间中模拟固件服务，同时可扩展到更大的固件映像集和分析工具。

其他分析方法。除了模糊测试，研究人员还通过其他技术取得了成功。Costin等[8]将关联引擎与简单的关键字搜索相结合，对固件映像进行静态分析。最近的研究通过象征性地执行程序来发现控制流错误[11,19,29]或静态分析多个二进制文件之间的交互[6,12]来检测不安全的数据流来分析程序。

**重托管II型和III型固件**。Heapster[16]识别映像用于内存分配的堆库，并使用符号执行来检测潜在漏洞。PRETENDER[17]通过跟踪实际设备上的行为来建模MMIO行为，而P2IM[14]则试图穷尽探测MMIO以生成模型。µEmu[42]使用符号执行模型图像和推断外围行为的约束。Fuzzware[28]通过实现自己的指令集架构模拟器将这些方法结合起来。它通过模糊测试迭代地探测MMIO行为，并将结果提供给符号执行引擎，以派生用于更新仿真的模型。Srinivasan等人[31]试图通过将Type-II映像重新打包为Linux应用程序而不是完整的固件映像来重新托管它们。

这些工作所采用的方法在概念上与Greenhouse相似，它们如何采用固件映像的“切片”来模拟和扩展他们的知识库。未来的工作可以着眼于从一种方法到另一种方法的技术调整。

## 10.结论
我们提出了Greenhouse，这是一个自动化系统，用于用户空间中基于linux的固件的大规模单服务重新托管。Greenhouse利用“尽最大努力”的缓解来迭代地使固件映像和模拟环境相互适应。我们还根据模拟动态分析和漏洞发现的最终目标，为重新托管定义了一组更严格的标准。我们在一组7,140个I型固件映像上评估Greenhouse，并根据我们的新标准将其中的2,841个重新托管到最低可用性水平。使用现有的分析工具，如routersplit和AFL，我们发现了717个n日漏洞和26个0日漏洞。这证明了单服务、用户空间仿真为动态分析创建可用的仿真镜像的可行性。

## 附录
### 我们对AFL++的修改来模糊Web服务器
我们修改了AFL++来拦截accept()并将返回的文件描述符重定向到stdin。当web服务器进程试图通过send()响应这个文件描述符时，我们终止它。这将有状态的web服务器转换为只处理一个网络请求并终止的程序，这是使用AFL进行模糊测试的理想选择。我们还钩住了其他常见的与网络相关的系统调用，以确保web服务器无法检测到实际网络的缺失。最后，我们的harness自动推断accept()返回的地址，并使用它作为fork地址来加速模糊。我们的harness是一个432行的补丁文件，可以应用于其他版本的QEMU。

**FirmAFL的刚性**。我们最初计划将FirmAFL的fuzzing引擎用于我们的评估。然而，FirmAFL的fuzzer与他们的工作流程紧密耦合，因此很难扩展到新的固件服务。每个FirmAFL目标都有包含密钥管理配置设置的配置文件，例如，最大执行计数和fork地址。这些设置需要对目标web服务器进行手动你先工程，无法自动获得。此外，FirmAFL与AFL-QEMU的集成包括针对特定目标id的硬编码比较，以确定模糊行为。

**EQUAFL的刚性**。与FirmAFL相比，EQUAFL具有较少的硬编码特定于示例的逻辑，但我们仍然发现类似的手动插入钩子可以修复66个模糊示例中的至少9个重托管功能。EQUAFL的状态同步也与Firmadyne紧密耦合，难以适应其他重托管解决方案。我们得出的结论是，FirmAFL和EQUAFL都不能很好地推广到新的目标，并且需要大量的人工努力来引导每个新的模糊目标。

**FirmAE报告数据的差异**。表10展示了在我们的实验中成功实现四个重托管阶段(解包、执行、连接和交互)的模拟web服务器服务的数量。我们基于FirmAE论文的数据集对Greenhouse和FirmAE进行了评估，该数据集由八个品牌(不包括Tenda)的1124个唯一固件图像组成。FirmAE的重新托管服务的数量与FirmAE论文中报告的原始数量不同。这是因为我们根据第5节中讨论的阶段，在更严格的成功标准下评估了这两个平台。例如，如果返回的HTTP请求没有错误或超时，则FirmAE认为固件目标已成功重新托管，这与Connect里程碑大致匹配。虽然这可能一开始看起来足够，但检查并没有过滤掉web服务器可能具有连接但没有任何实际功能的情况，如华硕样本所示。

![](images/Pasted%20image%2020230814094933.png)

**手动崩溃分类**。表11将我们对14个图像进行模糊分析期间发现的79个崩溃中的每一个都映射到26个合法的0-day漏洞。并非所有通过模糊测试发现的独特崩溃都能转化为现实世界的漏洞。有些崩溃可能是由相同的根本原因引起的。由于我们的模拟假设另一些可能是误报。例如:为了保持轻量级，我们的Greenhouse+AFL集成假定了一个无状态的程序目标。但是，许多嵌入式web服务保留某种形式的状态，例如经过身份验证的会话。这可能会导致无法重现的模糊测试崩溃。我们在表中将这些崩溃标记为“不可复制”。有些崩溃的根本原因过于复杂，无法在本文的时间框架内确定。我们把这些事故标记为"无法识别"

![](images/Pasted%20image%2020230814094955.png)