# Fuzztruction: Using Fault Injection-based Fuzzing to Leverage Implicit Domain Knowledge

# Translation
## 摘要
今天的数字通信依赖于复杂的协议和规范来交换结构化的消息和数据。通信自然涉及两个端点:一个生成数据，另一个消费数据。传统的模糊测试方法用模糊器代替一个端点，即生成器，快速测试被测目标程序上的许多突变输入。虽然这种完全自动化的方法适用于松散的结构化格式，但不适用于高度结构化的格式，特别是那些经过复杂转换(如压缩或加密)的格式。

在这项工作中，我们提出了一种新的视角，可以在不依赖重量级程序分析技术、粗粒度语法近似或人工领域专家的情况下，生成高度复杂格式的输入。我们不改变目标程序的输入，而是在数据生成程序中注入错误，这样数据就几乎符合预期的格式。这样的数据绕过了消费者程序中的初始解析阶段，并运用了更深层次的程序状态，在这些状态中，它触发了更有趣的程序行为。为了实现这个概念，我们提出了一组编译时和运行时分析，以一种有目标的方式改变生成器，使其保持完整，并生成满足复杂格式约束的半有效输出。我们已经在一个名为Fuzzstruction的原型中实现了这种方法，并表明它的性能优于最先进的fuzzers AFL++、SYMCC和WEIZZ。FUZZTRUCTION发现比现有方法有更大的覆盖范围，特别是在使用加密原语的目标上。在我们的评估过程中，FUZZTRUCTION发现了151个独特的崩溃(在自动重复数据删除之后)。到目前为止，我们手工进行了分类并报告了27个bug，并分配了4个CVE。

## 1.引言
我们的现代数字基础设施基于定义良好的消息和数据格式，包括数据交换的标准和规范。这些系统至少有两个端点，它们都对处理通信所需的领域知识进行编码：一个应用程序生成数据(以下称为生成器generator)，而另一个应用程序消费数据(称为消费者consumer)。例如，各种程序生成PDF文档作为输出，相应的PDF查看器显示结果。另一个例子是加密库，它生成加密消息，对应的库可以处理这些消息。从安全的角度来看，消费者扮演着关键的角色，因为它处理潜在的不可信数据，因此暴露于攻击之下。模糊测试(简称fuzzing)是随机测试的一种形式，事实证明它有助于在消费者程序的输入处理中有效地发现软件错误。过去模糊方法的进展主要集中在吞吐量[1-3]、有效性[4-6]和对新目标领域的适用性[7-12]。即使经过多年的研究，一个尚未解决的挑战是如何有效地生成复杂格式的有效输入，包括密码原语、压缩和其他类型的复杂转换。

先前的工作和行业最佳实践尝试了两种方法来应对这一挑战。 首先，重量级程序分析技术，如符号执行和污点分析，或手动变通方法，已被建议来解决障碍（例如，校验和或散列）[5,6,13-20]。 不幸的是，这些方法不能扩展到复杂的程序。 其次，基于语法的模糊化[21-29]被用来生成特定句法结构的输入。 然而，语法的使用并不能解决使用复杂类型转换的应用程序的复杂性，尤其是加密原语和压缩。 

我们提出了一种新的通用方法，以自动的方式生成高度结构化和复杂的模糊输入，而不是使用繁重的技术、语法或手动绕过这些模糊障碍。 更具体地说，我们建议利用在生成数据的应用程序中已经编码的领域知识：在传统的模糊化方法中，生成器被直接将输入传递给消费者（表示测试中的系统）的模糊器所取代。 相反，我们设计了一种机制来变异生成器，然后将其输出传递给消费者。 其核心思想是，这种变异生成器产生的输入大多符合所需的数据格式，但引入了细微的偏差，这可能会引发消费者处理逻辑中的错误。 例如，对加密证书进行签名的应用程序知道如何生成有效的签名，该签名可以由任何旨在验证此类签名的应用程序（例如，浏览器或加密库）进行解析和验证。 为了实现签名验证逻辑的模糊化，我们利用了生成器隐式知道如何计算有效签名的事实。 我们通过稍微改变生成器的代码来利用这些知识，这样产生的输出可能违反规范，但在技术上是有效的（即，有效的签名或加密）。 

随机翻转生成器中的指令位可能不会影响其输出，更糟糕的是，在大多数情况下，它会导致生成器崩溃。 为了避免这种不希望的情况，我们设计了一个编译时分析来识别对数据的操作，并过滤掉当它们发生突变时会使生成器崩溃的操作。 我们还分析数据流依赖关系以避免冗余突变。 然后，我们确定生成器的哪些部分实际上影响了剩余候选突变的输出，并将我们的突变集中在最有希望的候选突变上。 基于这些见解，我们将生成器和实时(JIT)编译跟踪和变异机制纳入其中，促进有效的模糊化。 

为了证明所提方法的实际可行性，我们实现了一个称为FuzzTruction的工具。 我们的方法可以作为一个独立的工具或增强现有的模糊器。 在一个全面的评估中，我们表明，我们的方法不仅避免了传统方法对于消耗复杂输入格式的目标的缺点，而且优于symcc[6]、weizz[30]和afl++[1]:平均而言，我们发现对于大量使用密码原语的目标（高达70%的覆盖率）和对于经过广泛测试的目标（高达23%的Objdump覆盖率）的覆盖率都增加了21%。 除了覆盖范围，我们发现与这些模糊器相比，（重复数据删除）崩溃输入的数量是五倍多。 在我们的评估中，我们发现了151个独特的崩溃（在自动重复数据删除之后）。 我们手动分类并以协调的方式向开发人员报告了27个bug。 到目前为止，共分配了4个CVE。 

概括而言，我们作出以下主要贡献： 

- 我们提出了一种新的模糊化方法，它自动地利用生成器应用程序中的领域知识来改善模糊化，而不依赖于先进的昂贵的程序分析技术。 
- 我们通过对甚至复杂的加密过程(如对加密的RSA密钥的解析和验证)进行模糊处理，演示了该方法的通用功能，这些过程无需定制的种子即可自动完成。
- 我们针对最先进的模糊器AFL++、SYMCC和Weizz来实现和评估我们的原型FuzzTrucion。 我们的结果表明，我们的方法在覆盖和发现的软件错误数量方面取得了显著的进步。 

为了促进对这个主题的进一步研究，我们在https://github.com/fuzztruction/fuzztruction发布了FuzzTruction的源代码和评估构件。 

## 2.对复杂输入格式模糊测试
一般来说，Fuzzing是指我们执行一个目标程序，其中包含大量变异的输入，以触发意想不到的行为，从而揭示故障。 为了深入到被测程序的状态空间，模糊器通常需要生成结构良好的输入。 除了结构良好之外，这些输入还需要考虑校验和、压缩算法或保护更深入处理的加密原语。 在实践中，有效地识别输入格式中的逻辑单元以及随后有效地解决这些单元中的障碍都是一个主要的挑战。 模糊者目前试图通过不同的方法来解决这些挑战，我们将在下面概述这些方法。 

**执行反馈**。 对于给定的输入，收集目标程序执行的反馈是现代Fuzzers的一项成熟技术[1,31,32]。 这种反馈提供了输入质量的度量，并允许模糊器识别探索新程序行为的输入。 通过保持并进一步改变这些结构越来越好的输入，模糊器得到的输入随着时间的推移在更大程度上与预期格式匹配。 收集执行反馈（最突出的是覆盖率反馈）很有吸引力，因为它普遍适用，并引入了低运行时开销。 事实上，在AFL[31]中引入这种覆盖引导技术后，Fuzzers已经能够探索常见的、结构更松散的二进制文件格式，并因此识别出大量的bug[33]。 即使模糊器不能直接使用它，执行反馈也为被测程序中编码的领域知识提供了一个侧通道。 

**语法**。与试图从目标程序中提取领域知识不同，人类专家可以向模糊器提供预先存在的领域知识。在这些方法中，要么为模糊器提供有关目标程序的输入结构的信息(例如，语法)，要么在模糊器中集成用于输入生成的结构感知逻辑[21-29]。这种关于目标格式的精确知识允许模糊器生成满足目标对输入结构的要求的输入。这些方法的主要缺点在于，尽管它们允许生成高质量的输入，但它们需要预先了解被测程序。

**自动语法近似**。不需要先验的语法形式的领域知识，有一些技术可以自动生成嵌入到目标中的语法的近似。针对基于文本的[34]或二进制格式存在不同的方法[30,35]。两者的共同之处在于，它们试图通过识别数据格式中的逻辑单元来推断所提供的输入的结构，例如，块、标记或字段。这支持结构感知的突变，允许模糊器修改、插入、删除或替换这些逻辑单元。尽管这些技术回避了手工加工语法和成功定位逻辑单元的需求，但近似过程本身就是粗粒度的。

**重量级反馈和分析**。除了上述改进模糊器生成高度结构化输入的能力的努力之外，一项正交的研究还集中在解决典型的模糊障碍，如校验和或密码原语，而不需要语法。作为提取目标程序中编码的领域知识的一种更直接的方法，最近的方法采用了复杂的程序分析和更重量级的反馈类型。这些方法通过帮助模糊器解决数据结构中的约束来解决(轻量级)反馈驱动的模糊器的缺陷，例如，通过污点跟踪[17-19]或concolic/符号执行[5,6,13 - 15]。利用污染跟踪，模糊器可以回溯跟踪输入的哪些部分影响特定的分支条件。有了这种语义洞察力，模糊者就可以把精力集中在改变与克服特定约束相关的输入部分上。使用符号执行或冲突执行，模糊器可以计算出解决条件或完整性检查所需的值，或者更一般地说，在给定的程序中执行所有路径。虽然重量级的反馈驱动模糊器已被证明能够有效地生成结构良好的输入，但它们面临着新的挑战和限制。主要的限制是它们相对较慢，不能扩展到大型目标程序，并且需要运行时环境来指定，例如，库函数[4]的副作用。此外，由于计算复杂性，由hash函数或签名等加密原语施加的复杂约束无法解决。

综上所述，我们发现当前生成复杂、高度结构化输入的方法要么依赖于人类专家提供的语法(这种方法有效但代价高昂)，要么依赖于近似语法(成本较低但效率较低)。注意，它们都不能处理复杂数据的突变。其他方法使用重量级技术，它们不需要语法，但效率很低，而且不能伸缩。没有一种最先进的方法能够以自动化和有效的方式利用现有的领域知识。

## 3.设计
在这项工作中，我们通过改变模糊化的视角来采用正交方法：我们建议把重点放在为被测目标程序产生输入的生成器应用程序上。我们的方法使用了一个简单而强大的理念：我们不是直接改变输入来创建新的测试用例，而是改变发生器应用程序并使用其输出作为测试目标的模糊测试用例。这样，我们可以（隐式地）利用领域知识并克服复杂的约束，而不会受到重量级技术或手动方法的缺点的影响。

我们的观察是，生成器程序通常产生格式良好的输出，这对于确保互操作性是不可或缺的。 通过有选择地向这些生成器程序中注入错误，它们产生几乎格式良好的输出，即他们可能会以微妙的方式违反规范， 这允许我们为各自的消费者程序生成高质量的测试用例。 例如，假设我们将错误注入到操作（即，读或写）部分处理的数据的指令中，这些数据随后将被加密签名。 在这种情况下，我们可以产生关于包络签名的变异但有效的输入。 至关重要的是，这些输入不会在签名验证期间早期丢弃，而是到达消费者中更深层次的程序逻辑。 

图1给出了我们方法的高层级概述，并显示了我们设计的各个组件是如何交互的。 在高层，我们希望生成器应用程序产生不同的测试用例，我们可以提供给我们实际的模糊目标消费者。 为此，1模糊调度程序为生成器应用程序选择一个或多个变异（例如，改变MOV指令存储的值），如果需要，还选择生成器处理的种子文件。 接下来，2选择的变异被应用到生成器。 变异的生成器现在3处理输入4并产生略微变异的输出。 最后，5调度器将生成的输出传递给使用者，6并收集复盖反馈。 如果测试用例触发了有趣的行为（新的复盖范围），则在随后的轮中，对变异的生成器程序和输入文件进行排队以进行进一步的变异。 

![](images/Pasted%20image%2020230312103636.png)

### 3.1 生成器
本质上，生成器可以被认为是一个种子生成器，用于产生针对模糊目标消费者的量身定制的输入。 当常见的模糊化方法通过位级突变来动态突变输入时，我们通过向生成器程序中注入错误来间接突变输入。 更准确地说，我们识别和变异生成器用来产生输出的数据操作。 

**生成器需求**。 为了方便我们的方法，我们需要一个程序来生成与模糊目标期望的输入格式匹配的输出。 大多数生成器应用程序（如图像转换器）要求可以被转换为目标格式的文件。 因此，与传统的模糊化方法不同，初始种子文件是生成器的而不是消费器的输入。 根据生成器的类型，可能不需要种子输入。 例如，这适用于加密密钥的生成器。

**数据操作**。 变异生成器的一个核心挑战是识别和变异数据操作。 我们把从内存中读取或写入任何指令都看作是一种数据操作。 潜在的洞察力是，在几乎所有情况下，程序生成的输出都在某个点存储在内存中，尤其是对于我们在本文中针对的复杂数据格式类型。 对于程序的特定输入，我们说它在执行相应操作时涵盖了数据操作（这是变异产生任何效果的基本要求）。 此外，我们说当底层数据相对于原始程序被修改时，数据操作就会发生变异。 

为了可靠地识别程序中的所有数据操作，我们设计了一个编译器通道，允许我们检测所有加载和存储操作。 这些操作在程序中普遍存在，从而产生许多潜在的有趣操作。 因此，我们不能对每一个实例进行分析。 相反，我们必须确定一个数据操作子集，使我们能够最大限度地控制已处理的数据，同时最小化运行时的不利影响，如崩溃。 除了它们的数量之外，还有几个因素决定指令的相关性：

- 影响：此特定指令是否修改相关数据。 即对产出有明显影响的数据？ 修改与生成的数据无关的指令对为模糊目标生成有趣的输入文件的目标没有好处。 
- 类型：修改后的数据是否表示一个值，如果该值发生突变，则可能导致生成器崩溃。 例如因为它是函数指针？ 修改指针而不是实际值容易使应用程序崩溃，而不是产生有趣的值。 
- 数据流依赖性：数据是否依赖于已被早期指令修改的值？ 直观地说，不希望多次修改相同的数据，因为最初的修改已经可以产生任何可能的值； 在最坏的情况下，第二个更改可能取消第一个的更改。 这不适用于部分依赖项。 

为了解决这些问题，我们设计编译器通道只插桩加载或存储值类型的指令，并且避免指针类型。 此外，我们使用编译器可用的数据流信息只插桩被修改的数据值的第一个实例。 不幸的是，编译时的静态分析无法确定特定指令是否会对应用程序的输出产生重大影响（如果有的话）。 因此，在开始实际的模糊化过程之前，我们的设计预算用于运行时的轻量级识别和剪枝阶段，我们将在下面描述这一过程。 

**插桩点修剪及影响分析**。我们观察到，允许模糊器在所有可能的插桩位置注入故障会导致许多无效突变。例如，给定的输入文件只执行(可能发生变化的)生成器代码中的特定路径，这通常只包含所有插桩点的一部分。我们称这些站点为死w.r.t.，即生成器的特定输入和(突变)版本。即使是活的(即，不是死的)插桩站点也可能没有实际的影响。这意味着，对于给定的输入和生成器版本组合，向该插桩点注入错误不会导致使用者中的任何覆盖率变化。

直观地说，为了最大限度地增加有效错误注入的数量，我们希望避免变异死的插桩点和没有明显影响的插桩点。 因此，我们的修剪和影响分析阶段的目标是双重的：对于种子输入和（潜在的）突变生成器的每个组合，我们首先旨在识别和移除死的插桩位置，然后分析剩余的插桩位置的影响。 为此，我们跟踪执行并只保留活动的插桩站点。 此外，为了分析活动的插桩站点的影响，我们观察向底层数据操作注入错误是否会在使用者中产生不同的代码覆盖率。 这个阶段导致每个种子文件和（潜在的）变异生成器应用程序都有一个活的和有影响的插桩点列表。 此外，我们还会记录额外的信息，如插桩点的执行次数，以供以后使用。如当生成突变时。 

**变异**。 为了生成稍微损坏的输入，我们对生成器进行变异：我们为生成器随机选择一个输入和一个或多个插桩点。 然后，我们将位级别变异应用于在各个插桩点处理的数据值。 由于这些站点在程序执行期间可以被多次访问，例如，在循环中，我们可以总是应用相同的突变，也可以选择更细粒度的控制，其形式是独立的突变，每次访问都不同。 对于后者，我们需要一个特定输入访问插桩点的频率的先验知识。 这些信息可以从我们的修剪和影响分析通道中方便地获得。 这允许我们为每个插桩点指定一个突变列表。 每一次对突变位点的访问都会消耗一个突变，直到一个给定的插桩点的所有突变都消耗掉为止。 在极少数情况下，变异会修改控制流，以至于在影响分析期间访问插桩点的次数多于观察到的次数，我们不能应用任何进一步的变异，而是返回未修改的数据值。 

### 3.2 消费器
生成器的对应方是消费者：作为我们模糊测试活动的目标，它使用生成器生成的输入。与典型的模糊测试目标类似，我们不对消费者施加任何具体限制。由于我们使用覆盖率反馈来指导生成器中的突变，因此消费者必须提供一个接口来检索覆盖率信息（通过源代码插桩或从仿真中获取）。

### 3.3 调度器
最后一个组件是调度程序，它协调生成器和消费者的交互。它管理模糊测试活动，其主要任务是组织模糊测试循环。调度器包含以下组件：

**队列**。调度程序维护一个包含队列条目的队列。 每个条目由传递到生成器（如果有）的种子输入和应用到生成器的所有突变组成。每个这样的队列条目表示单个测试用例。在传统的Fuzzing中，这样的测试用例将被表示为单个文件。

**阶段**。主要的模糊循环被分成多个阶段，见算法1。 根据阶段类型的不同，一个阶段内的步骤对于每个新队列条目（校准阶段）执行一次，或者在模糊过程中执行几次。 在启动Fuzzing活动时，所有种子文件都被添加到队列中，并因此进行校准。 

![](images/Pasted%20image%2020230313160617.png)

1. **校准阶段**：我们将输入传递给（潜在的突变）生成器，并记录执行过程中访问的插桩点（插桩点修剪）。对于目标的每个插桩点，我们进一步评估其对消费者覆盖范围的影响（影响分析）。 这些信息与输入和突变一起存储在队列条目中。 重要的是，这个阶段是常规模糊迭代的一部分。

在主模糊循环期间，我们然后重复地选择一个队列条目，并选择以下阶段之一： 

2. **添加阶段**：我们选择多个插桩点并应用突变。 我们更喜欢以前在消费者中成功产生新代码覆盖率的点。 此阶段向队列条目添加新的突变，扩展突变数据操作的实例。 
3. **变异阶段**：我们对所选队列条目的所有变异数据操作应用固定数量的变异。 与添加阶段不同，此阶段不添加任何新的数据操作，而是修改现有的数据操作。 
4. **组合阶段**：对于每个变异的数据操作，我们检查其他队列条目是否也变异了它。 如果是这样，我们尝试他们的突变。这类似于剪接，从传统的模糊认识，并允许受益于已经证明影响覆盖率的突变。

如果我们在主模糊循环期间观察到新的代码覆盖率，那么我们需要为新的队列条目执行校准阶段，创建该条目是为了表示产生新覆盖率的输入和突变的组合。

我们的队列实体选择算法类似于AFL所使用的算法。 两者都使用了新颖搜索的概念，即我们根据输入是否产生新的代码覆盖率来保留输入。 此外，我们应用了一个类似的偏好方案，该方案优先考虑消费者中覆盖最多代码的最小输入集。与AFL的主要区别在于，我们更喜欢包含很少观察到的数据操作的队列条目； AFL没有类似的概念，因为该方法根本不观察数据操作。 

### 3.4 联合的模糊测试
与传统的模糊设计相比，我们的输入生成方法要慢一些:不是翻转一个字节，而是对生成器程序进行变异并执行以产生输入。此外，基于afl的模糊器能够拼接或分割输入操作——生成器通常不会暴露这些操作。为了弥补这些缺失的操作和性能影响，我们的方法可以与传统的模糊器(如AFL++)串联使用。这种方法类似于QSYM[5]、SYMCC[6]或DRILLER[14]等fuzzers，这些fuzzers使用AFL进行常规fuzzing，并通过提供解决普通变异无法解决的fuzzing障碍的新输入来增强fuzzing。同样，我们提出了一种方法，专注于生成器应用程序，以产生有趣的输入，为传统的模糊器解锁新的、更深的状态空间。

## 4.实现
我们在一个名为FUZZTRUCTION的原型中实现了我们的设计，这个原型包含了大约14000行Rust代码。接下来我们讨论实现方面。

**生成器**。为了测试生成器，我们为LLVM开发了一个编译器通道，它标识所有的数据操作，并为它们的突变做准备。我们使用一个称为堆栈映射的实验性LLVM特性来为每个数据操作创建一个插桩点。本质上，这意味着编译器在运行时记录指令参数的位置，例如，在寄存器中，一个参数被传递给一个存储指令(堆栈映射记录)。与LLVM的另一个特性patch point(它将填充(以nop指令的形式)放置在堆栈映射记录的位置)一起，这允许我们注入任意代码来改变每个数据操作的操作数。我们即时(JIT)将动态生成的JIT存根编译到补丁点提供的填充中。为了保持所需的填充大小小且可预测，我们选择调用我们分配在单独的可执行部分中的代码的trampolines。

由于堆栈映射和patch point是LLVM的实验特征，它们不能正确处理所有点的情况(如向量操作)。我们为LLVM 11.0.1和LLVM 12.0.1开发了补丁，以引入缺失的支持1。除了实现插装传递，我们还插入了一个运行时组件，该组件实现了一个forkserver来快速执行多个输入，并开发JIT编译器来应用、删除和生成JIT存根。我们使用这些存根来实现两种类型的功能: (1)插桩站点剪枝和影响分析阶段所需的跟踪，以及(2)数据操作本身的变异。

**插桩点修剪和影响分析**。使用 JIT 编译器，我们通过将对自定义日志记录函数的回调注入每个插桩站点来促进分析阶段。基于这些回调，我们确定哪些插桩点处于活动状态。作为附加的元数据，我们还计算了特定输入访问（即执行）它们的频率。这些执行计数允许调度程序的模糊循环确定在每个插桩点可以改变多少数据操作。

**突变**。 第二种类型的JIT存根实现了对数据操作的突变应用。 在FuzzTrucion中，我们通过在数据操作数中引入位掩码来实现对数据操作的变异。 对于加载操作，插桩点放置在操作之后，而对于存储，插桩点放置在数据操作之前。 图2显示了存储操作如何基于提供的位掩码列表（变异掩码）进行变异。 除了XORing之外，我们还可以实现其他操作来改变数据，例如将其设置为特定值或递增/递减。 这类似于传统模糊中使用的突变。 然而，根据经验，这些变异器通常只产生很少的覆盖率，因此我们没有实现它们。 

![](images/Pasted%20image%2020230313165224.png)

我们使用在跟踪过程中收集的每个插桩点的观察到的执行次数作为每个检测站点可以插入多少突变（即位掩码）的提示。 我们还跟踪突变在消费者中产生新代码覆盖率的插桩点，在随后选择插桩点突变时优先考虑他们。 

**生成器的稳定性**。假设我们对生成器应用程序进行了变异，尽管在第3节中描述了分析过程，但我们仍有可能以这样一种方式修改生成器，即输入导致它崩溃而不是产生输出。 如果我们检测到这样的情况，我们从被选择进行突变的位置集合中删除违规的插桩点。 虽然这可能看起来很保守（因为可能存在其他不会崩溃的突变），但我们根据经验发现崩溃的插桩点恢复的可能性很小。 类似地，我们通过设置几毫秒的超时来检测生成器中的停顿，并以与生成器崩溃相同的方式处理它们。 此外，为了防止生成器对宿主文件系统产生负面影响，我们将它们监禁，这样它们就不能修改超出其输出的文件。 

**消费器**。 为了从消费者那里收集代码覆盖率，我们使用与AFL兼容的Fork Server接口。 如果源代码可用，我们将应用AFL的编译时覆盖率插桩。 否则，我们可以回到只使用二进制程序的QEMU用户模式检测。 

为了避免不必要的消费者执行，我们对输入进行哈希。生成器产生的数据，并且只执行那些以前没有测试过的数据。 

**调度器**。 除了编译器通道对生成器和消费器进程插桩之外，我们还实现了一个调度器，该调度器协调整个模糊化过程以及生成器和消费者之间的通信。 此外，我们集成了对使用AFL++对FuzzTruction发现的输入采用简单位级突变的支持。 因此，我们可以花更多的时间来解锁新的程序分区，而把发现这些的任务留给适合实现高测试用例吞吐量的模糊器。 

## 5.评估
在本节中，我们将评估我们的原型FuzzTrucion以更深入地了解我们的方法在哪里应用，以及与最先进的Fuzzer相比，我们的原型表现如何。 

### 5.1 开始
我们首先描述了我们的评估实验设置，包括硬件环境，我们评估的模糊器，以及目标程序。 

**硬件环境**。 我们在所有实验中使用相同的硬件配置：Intel Xeon Gold5320 CPU@2.20GHz(52个物理核心），256 GB RAM和SSD内存作为支持存储。 

**模糊器**。 我们评价以下五种模糊方法。 作为基准，我们使用FuzzTrucion-NOAFL和AFL++，这两个组件被我们的方法使用。 我们对FuzzTrucion的原型实现与另外两种方法进行了评估，SYMCC[6]和Weizz[30]，它们代表了重量级程序分析和输入结构近似方面的最新技术。 没有一个模糊器需要任何预先计算。 

**1）FUZZTRUCTION-NOAFL**。 这个独立的FuzzTrucion变体不与AFL++配对，而是完全依赖于生成器应用程序产生的输入。 因此，它无法获得传统的突变，尤其是自由的剪接和分裂输入。 

**2)AFL++**。 第二个基线是AFL++[1]（版本4.00C):一种表示传统的字节级面向突变的模糊器的方法。 AFL++是不断发展和改进的，它代表了最先进的Greybox模糊化器，并被许多专门的模糊化器所使用，如Symcc。 

**3）FUZZTRUCTION**。 该方法代表了我们在本文中提出的方法。 我们用变异生成器程序的思想来增强AFL++，基本上结合了上面提到的两种技术。 

**4) SYMCC**。 我们选择Symcc[6] (commit 07c8895)作为基于重量级程序分析的代表性方法，这里是符号执行。 SYMCC使用基于编译器的插桩来利用LLVM优化通道使约束提取更加可行。 与FuzzTrucion类似，它与AFL结合（在我们使用AFL++的实验中），并用于解决AFL无法解决的约束。 据我们所知，symcc是唯一一个不需要任何形式的热身（如收集约束条件）的最先进的混合Fuzzer，因此可以与我们的方法具有可比性。 由于symcc需要对库函数的描述，这样约束就可以在库调用中传递，如Libc，Poeplau和Francillon已经注释了几个函数。 不幸的是，其他如Open64或Pread64都没有。 如果没有描述，symcc将不能用于调用这些描述的目标。 我们手动添加缺少的注释，这样symcc就可以用于我们评估中的目标。 

**5）WEIZZ**。 Weizz[30]是一个模糊器，它在运行时近似于基于输入到状态对应的输入结构。 它共享了FuzzTrucion创建复杂结构化输入的思想，并使用类似Redqueen的方法从输入到状态的对应中获利，该方法已成功地用于克服校验和等障碍[4]。 我们使用Weizz(commit c9cbeef)作为我们的评估：与SymCC和FuzzTrucion相反，Weizz与AFL紧密耦合，并且是一种使用AFL的QEMU模式而不是源码插桩的二进制方法。 这使得它与其他Fuzzer相比略有不足，后者可以访问更快的编译时插装。 然而，我们仍然将它包含着我们的评估中，因为据我们所知，它是语法推断领域最强大的方法，也是克服路径障碍的技术。

**目标应用程序**。 我们根据几个因素选择了十个不同的应用程序来确定我们方法的有效性和效率。 我们使用密码原语标记应用程序，并使用锁符号。 锁符号表示程序只可选地使用这些原语。 总的来说，我们的目标是选择处理三种不同类型输入格式的不同应用程序组： 

- **松散结构格式**（objdump, readelf）：这些格式不使用复杂的约束，并且是基于块的。 这一组的目标已经被传统的模糊器很好地测试过，这些模糊器使用比特级突变(AFL++)或基于块的推断格式(WEIZZ)。 
- **复杂格式**(pngtopng, unzip, 7zip(锁), and pdftotext(锁))：这样的程序通常表现出对模糊具有挑战性的输入结构，例如，由于转换，如压缩或校验和。因此，需要比传统的面向字节级的突变更复杂的方法，例如，符号执行或结构推理与输入到状态对应(WEIZZ)配对，以实现高覆盖率。我们可以选择使用密码学来包含目标，因为模糊器可以在不使用密码学的情况下创建执行深层程序状态的输入，例如，因为只有部分输入块是加密的。
- **密码格式**(OpenSSL的dsa(锁)和rsa(锁), 和Mozilla NSS的vfychain(锁))：这些应用程序避开了最先进的模糊分析器，主要是因为使用了加密原语。

在我们的评估中使用的所有应用程序都在表5中有更详细的描述。在fuzzer评估中，我们通常使用代码覆盖率作为fuzzer执行情况的代理。为了讨论这是否反映了fuzzers发现bug的能力，我们推荐感兴趣的读者访问Böhme等人文献[36]。我们不使用消毒器，因为它们不显示新的代码覆盖率(为了分类错误，我们使用Valgrind，如5.3节所述)。值得注意的是，SYMCC在7zip中遇到了分段错误，并且无法构建vfychainμ，因为它不支持一些向量化指令(即在编译期间触发断言)。因此，我们将其排除在这些目标之外。
![](images/Pasted%20image%2020230313203855.png)

**目标准备**。所有被测目标均根据各自的模糊器的需要准备。由于afl++， fuzzstruction和SYMCC依赖于afl++的编译器通道插桩，所有的目标(对于fuzzstruction，只有消费者)都是通过版本4.00c中的afl-clang-fast编译的。除了默认设置，我们还设置了以下标志\[1,37]:
- AFL_LLVM_LAF_SPLIT_SWITCHES=1
- AFL_LLVM_LAF_SPLIT_COMPARES=1 
- AFL_LLVM_LAF_SPLIT_COMPARES=1 

此外，由于SYMCC与afl++使用的默认无碰撞插装模式不兼容，我们将SYMCC的AFL_LLVM_INSTRUMENT设置为CLASSIC，这样注入的插装仍然向后兼容普通AFL。我们使用SYMCC编译器包装器注入约束记录逻辑。对于WEIZZ，我们使用与覆盖计算相同的未插桩二进制文件。最后，因为我们需要FUZZTRUCTION的生成器应用程序进行变异，所以我们为每个目标(消费者)应用程序编译一个生成器应用程序，使用我们自定义的LLVM编译器通道。

**种子**。为了为每个目标创建种子，我们为每个消费者的生成器使用现有的种子集，或者从头创建基本的种子集。每个种子输入的描述可以在附录C中找到。在某些情况下，例如genrsa，我们不向生成器提供任何种子语料库，因为应用程序不消耗任何输入。为了确保公平，通过在所有生成器种子文件上执行生成器，并使用结果文件作为afl++、SYMCC和WEIZZ的种子文件集来生成消费者的种子文件集。此外，如果生成器和消费者处理相同类型的格式，我们还将未处理的生成器输入提供给其他fuzzer。

![](images/Pasted%20image%2020230314160257.png)







## 6.讨论
## 7.相关工作
## 8.结论
本文提出了一种新的基于软件故障注入的模糊化方法FuzzTruction。 基于使用输入的程序有一个（或多个）对应程序生成该输入的观点，我们建议对该生成器进行插桩和变异。 通过注入轻微的软件错误，我们可以利用应用程序中编码的隐式领域知识，并生成几乎与规范匹配的输入。 使用这些输入进行模糊化，FuzzTrucion产生高质量的输入，从而产生高代码覆盖率并运行深入的程序状态。 我们的方法是轻量级的，不需要昂贵的分析或手动准备的执行环境。 在评估中，我们发现我们的方法显示了它的力量，通常优于最先进的模糊方法，特别是在具有复杂约束的目标上，通常是以密码学原语或压缩的形式应用于输入。 

## 9.致谢
## 分配的CVE
## 目标描述
## 种子描述