IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems，2020；CCF A

ACM会议 EMSOFT

未开源

# 翻译
## 摘要
在新兴的应用场景中，嵌入式系统的互联性越来越强。这些应用程序中的许多都是安全关键型的，因此确保系统不受恶意攻击是重中之重。这项工作旨在检测漏洞，这些漏洞可能被攻击者利用来破坏嵌入式固件中的功能正确性，特别是由于缺乏源代码，这是具有挑战性的。

我们特别提出了EM-Fuzz，这是一种固件漏洞检测技术，它将模糊检测与实时内存检查紧密结合在一起。基于内存插桩的固件模糊测试，既可以通过传统的分支覆盖引导生成高质量的种子来探索难以到达的区域，也可以通过记录的内存敏感操作来持续尝试容易被攻击的敏感区域。更重要的是，该工具集成了实时内存检查器，以暴露内存漏洞，现有的没有源代码的fuzzers不支持这一点。在OpenSSL等实际嵌入式固件上的实验表明，EM-Fuzz显著提高了AFL和AFLFast等最先进的模糊测试工具的性能，覆盖率分别提高了93.98%和46.89%。此外，EM-Fuzz总共暴露了23个漏洞，平均每个漏洞约7小时。AFL和AFLFast总共发现了10个漏洞，平均每个漏洞花费的时间分别为13小时和10小时。在这23个漏洞中，有16个以前是未知的，并已报告给上游产品供应商，其中7个已在美国国家漏洞数据库中分配了唯一的CVE标识符。

索引术语-嵌入式固件，引导模糊测试，内存检查，漏洞。

## 1.引言
随着5G及以后技术的发展，嵌入式系统的连通性将在高度自动化车辆、家用机器人和工业4.0等新兴应用场景中变得越来越强。这些应用程序通常是安全关键型的，严格要求功能正确。因此，需要确保系统不受恶意代码注入、拒绝服务(DoS)等恶意攻击。然而现实是残酷的。Cui等[1]扫描了网络上约400万台嵌入式设备，发现其漏洞率为13.81%。这项工作的目标是嵌入式固件，漏洞检测是具有挑战性的，特别是由于缺乏源代码。

为了增强漏洞暴露能力，模糊测试成为近年来固件测试的研究热点[2]，[3]，[4]。Peach[2]是一个半自动的跨平台模糊测试框架，它根据人工构建的输入规范生成测试输入。SRFuzzer[3]是一个全自动模糊测试框架，用于对物理SOHO(小型办公室/家庭办公室)路由器的web服务器进行模糊测试。IoTFuzzer[4]使用移动应用程序的程序逻辑来生成探测目标固件的有意义的测试用例。尽管这些方法确保了报告漏洞的真实性，但它们属于不考虑执行反馈的黑盒模糊测试技术。因此，漏洞发现的效率并不令人满意。

灰盒模糊测试技术在带有源代码的程序上显示了有效的漏洞发现能力，因此首先想到的是使用QEMU进程仿真在嵌入式固件上执行类似的灰盒模糊测试。在没有嵌入式设备的情况下，QEMU仿真器确实成为模糊测试固件的首选，因为它具有相对完整的跨架构仿真能力，并且支持插桩来反馈分支覆盖信息。工具的二进制版本，如AFL[5]和AFLFast[6]，就是这种实现的代表，使用分支覆盖来连续地指导测试输入的生成。然而，我们在实践中发现，它们处理嵌入式固件的能力受到了极大的损害。有两个主要原因阻碍了这些工具在嵌入式场景中的使用。

一个原因是，与使用源代码模糊目标相比，使用QEMU仿真器模糊固件的时间成本更高，并且在单位时间内可以执行的测试用例数量(也称为吞吐量)要低3 - 5倍。虽然现有的fuzzers[5]，[6]可以应用于嵌入式固件，但它们面对低吞吐量的能力受到不适当的突变频率的限制。例如，AFL的盲突变策略难以使有意义的种子突变以有效到达难以到达的区域，从而导致被测目标的崩溃。

另一个原因是，当固件源代码不可用时，现有的fuzzers无法实现可以与各种杀毒程序(例如，AddressSanitizer, ThreadSanitizer)结合使用的源代码插桩来检查内存损坏。根据NVD近三年的统计，至少9.82%的被纳入漏洞与内存漏洞有关，如use-after-free、buffer overflow等。这使得固件中隐藏的内存漏洞不太可能被无助的fuzzer检测到。虽然MemCheck[7]、Dr. memory[8]等成熟的内存检查器通过二进制检测在二进制内存漏洞检查领域占据主导地位，但它们在固件上有较大的局限性。它们是可行的，前提是它们可以安装在与被测二进制文件相同的运行环境中(例如，相同的CPU架构)。在已经发布的固件中安装这些内存检查器是不切实际的，因此它们基本上不能与固件一起工作。此外，即使它们包含在固件中，在没有指导模糊测试的情况下执行任意测试用例可能会很耗时，并且根本不会报告漏洞。

> 原因：1.QEMU仿真模糊测试执行速度慢；2.源代码不可以无内存破坏检查辅助

在嵌入式场景中，虽然现有的灰盒模糊器和内存检查器可以发挥一定的功能，但它们是孤立的。将模糊测试和内存检查相结合，发挥各自的优势，我们面临以下挑战:

1)有效的内存插桩。增强型fuzzer需要必要的动态固件插桩，包括集成常见类型的内存检测器和以统一的方式记录内存敏感操作。

2)多架构支持。由于嵌入式设备应用场景的不同，固件CPU架构呈现出多样性。使用统一的运行环境来处理多种架构的固件模糊测试是非常受欢迎的。

3)覆盖指导和内存指导的协作。传统的分支引导信息不足以充分发挥组合能力。发现更深更广的程序路径并触发尽可能多的内存漏洞敏感操作是我们的理想目标。

为了解决上述挑战，我们提出了EM-Fuzz——一种增强的固件漏洞检测技术，通过将模糊测试与实时内存检查紧密集成。内存检查模块通过内存hook和库包装完成固件插桩任务，解决了挑战1.除了集成内存检测器以彻底识别内存漏洞外，它还监视并记录详细的内存敏感操作。EM-Fuzz中的模糊测试和内存检查都是基于QEMU仿真器实现的。因此，使用这个统一的运行环境来解决挑战2中的多体系结构支持，并在挑战1中提供内存检查工具的功能是合理的。增强的QEMU仿真器在仿真固件时，收集支路覆盖信息和内存敏感操作，共同指导模糊的突变方向，解决了挑战3。前者引导模糊器根据传统的分支频率选择种子，并采用随机和受限的突变策略对种子进行突变，保证了模糊的深度和广度;后者引导模糊器为执行记忆敏感操作的种子分配更多的突变时间，这增加了更频繁地覆盖脆弱区域的机会。

为了进行评估，我们考虑了现实世界的嵌入式固件程序，例如从变电站自动化系统(SAS)固件中提取的IEC61850协议，并将EM-Fuzz与两种最先进的fuzzers: AFL[5]和AFLFast[6]进行了比较。实验结果表明，EM-Fuzz显著提高了性能。特别是EM-Fuzz总共暴露了23个漏洞，而AFL和AFLFast分别暴露了7个和10个漏洞。结合AFL和AFLFast的结果，只发现了10个漏洞。EM-Fuzz发现的23个漏洞中，有16个是以前未知的，已经报告给上游产品供应商，其中7个已经分配了唯一的CVE标识符。在时间成本方面，EM-Fuzz发现一个漏洞平均需要7个小时，分别是AFL和AFLFast所需时间的54%和70%。

综上所述，本文做出了以下贡献:
- 据我们所知，EM-Fuzz是第一个集成了高效灰盒模糊和内存检查的工具，以增强嵌入式固件上的漏洞发现能力。虽然模糊测试在桌面应用程序上显示了令人印象深刻的性能，但对于没有源代码的嵌入式固件来说，这项工作是一个迈步。
- 我们通过动态运行时插桩将10种常见类型的内存检测器集成到EM-Fuzz中，这能够增强模糊测试，以发现现实世界固件中更多以前未知的漏洞。
- 我们提出了一种优化的嵌入式固件模糊测试策略。传统的分支和附加的内存敏感操作信息引导模糊探测难以到达的路径，并为脆弱的代码区域提供更多的内存耗尽检查机会。
- 我们将EM-Fuzz应用于真实的嵌入式固件，并发现了许多以前未知的漏洞。

论文组织:第二节给出了一个鼓舞人心的例子。第三部分详细介绍了EM-Fuzz的设计。第四节实现EM-Fuzz并报告实验结果。第五节指出今后的研究工作。第六部分为相关工作，第七部分对全文进行总结。

## 2.动机案例
为了展示EM-Fuzz如何通过内存检查工具提高模糊测试性能并暴露更多漏洞，我们浏览了清单1中所示的源自IEC61850嵌入式固件的修剪过的代码片段。块D中隐藏着两个漏洞。

![](images/Pasted%20image%2020230806114044.png)

### A.内存插桩的必要性
假设传统的fuzzer有机会探索难以到达的D区域，它仍然可能不会暴露任何内存漏洞。在没有任何内存检查器帮助的嵌入式场景中，fuzzers将认为块D运行正常，因为溢出和内存泄漏没有严重到使目标固件崩溃。如前所述，现有的内存检查器(如MemCheck [7]， Dr. memory[8])需要安装在与被测固件相同的环境中，并运行现有的测试输入来检测内存漏洞。现有的杀毒程序(例如AddressSanitizer, ThreadSanitizer)需要原始源代码来完成插桩，这在黑盒嵌入式固件的测试中是不切实际的。

详细地说，清单1的第14行和第15行分别为other和data变量请求8字节的堆内存。在32位操作系统环境中，每个变量实际上分配了16字节的内存，data的内存空间紧随other后。当data内存在第17行中首先被小于8字节的字符串填充，然后在第19行中other被大于16字节的字符串填充时，data内存的内容被other内存污染，因为data内存在other内存的后面。显然，应该报告导致数据完整性的缓冲区溢出问题。此外，第23行忘记释放第14行和第15行分配的内存。
如果不断调用函数parse_packet，则内存泄漏问题将使嵌入式设备耗尽资源。

在对跨架构固件进行模糊测试时，在统一的测试环境中对内存漏洞(如use-after-free、buffer overflow、memory leak)进行实时内存检查，可以显著提高漏洞检测性能。如果没有固件源代码，现有的模糊测试技术就不能很好地支持这个目标。

### B.有效模糊测试的必要性
在支持内存检查插桩后，检测第19行所示的缓冲区溢出漏洞需要测试输入满足两个条件:1)触发D块;2)为变量data和other包含适当的值。考虑到固件模糊测试的低测试输入吞吐量，理想的目标应该是对D块进行更深入的探索。

代码片段首先根据第4-5行中4-5和8-9的固定偏移量从数据包中获取魔术值和功能码。第8行确定2字节的魔术值是否等于0xB888，如果不等于，则意味着数据包无效，并在第26行中被过滤掉。由代表性的fuzzers，如AFL[5]， AFLFast[6]和FairFuzz[10]，生成的绝大多数测试用例都试图最大化传统的分支覆盖率。例如，AFL选择一个种子作为执行突变的首选项，如果它是任何观察到的分支中最快和最小的输入。FairFuzz对选择的种子执行限制突变策略，以增加到达相同的难以到达的分支的概率。然而，它的突变策略更倾向于探索更深的分支而不是更宽的分支，这导致了局部收敛问题。只考虑分支发生而忽略记录的内存敏感操作的权重可能会导致两个问题: 1)分支BD到达太晚;2)块C和块D的执行次数可能严重不平衡，其中D的触发频率较低。

EM-Fuzz的目标是通过记录的内存敏感操作指导的协作，尽早到达分支BD，并且执行D块的次数比执行C块的次数多。前者可以通过优化现有模糊器的选种策略和突变策略来实现。种子队列中的每个种子可以首先以与分支出现频率相反的概率进行选择。这个优化增加了种子命中分支BE的几率，而不是早期被丢弃，这有助于早期覆盖新的稀有分支BD。在突变阶段，如果选择的种子遇到了稀有分支和记忆敏感操作较多的分支，EM-Fuzz对种子采用限制性突变策略，以保持路径探索的深度。后者可以通过在突变阶段自适应更新种子突变能量来实现。如果种子碰到一个包含内存敏感操作的代码块(例如，malloc, free)，它会给种子更多的突变能量来增加这样的代码块被更多测试用例覆盖的次数。

## 3.EM-Fuzz设计
如图1所示，EM-Fuzz包含两个主要模块:内存检查插桩和引导模糊测试。通过紧密集成高效模糊检测和实时内存检查，分析人员能够快速定位固件中的严重安全威胁。内存检查插桩模块通过内存hook和库包装完成固件插桩任务，从而获得记录内存敏感操作的能力，以指导模糊测试和集成通用内存检测器来暴露内存损坏漏洞。模糊测试模块基于具有插桩功能的固件仿真器，以分支覆盖信息指导生成高质量的测试用例，探索难以到达的区域，以内存敏感操作指导触发易受攻击的脆弱区域。因此，增强固件模糊检测既保证了路径探索的深度和广度，又提高了漏洞暴露的能力。在整个模糊测试过程中，两个组件共享两个测试用例队列，包括输入队列I和缺陷队列D。

![](images/Pasted%20image%2020230806161748.png)

### A.内存检查插桩
内存检查插桩不仅负责反馈内存敏感操作以指导模糊测试，而且还负责集成内存检测器以彻底检查内存漏洞。它包含内存挂钩、库包装和内存检测器。

1)内存挂钩:EM-Fuzz中有两种主要类型的内存挂钩:指令挂钩和函数挂钩。指令挂钩将内存读和内存写指令拦截到堆地址。这用于确定是否存在内存漏洞。函数挂钩拦截与内存相关的库函数(例如，malloc, free)。其目的是在执行跟踪中记录对内存敏感的操作，并添加开场白和尾声动作。

对于指令挂钩，EM-Fuzz只挂钩涉及堆内存访问的指令。它的目的是获取堆内存地址的标记状态，以便内存检测器工作。因此，我们必须准确地将堆内存空间与整个虚拟内存空间区分开来。当EM-Fuzz将固件加载到模拟器中时，它将堆底部地址初始化为brk变量，表示为heapBottom = brk。每当分配新的堆内存空间时，brk变量的值就会增长，从而成为新的堆顶地址。EM-Fuzz只挂钩内存地址访问在heapBottom和brk范围内的指令。

对于函数挂钩，EM-Fuzz直接计算与内存操作相关的库函数的绝对虚拟内存地址。当模拟器执行main函数时，库函数__libc_start_main已经运行，并且它的起始地址存储在进程.got.plt节中。我们可以从libc.so库文件中获得__libc_start_main函数的偏移值。间接地，可以根据已知库函数的起始地址和偏移值计算出与内存相关的库函数的起始地址。没有直接从.got.plt中获得这些函数的起始地址的原因是其他库函数(例如，printf)也可以通过相同库文件中的偏移量调用这些函数，此时由于延迟绑定机制与内存相关的函数可能尚未加载到.got.PLT表。

2)库包装:EM-Fuzz的主要功能之一是支持固件的堆内存漏洞检测。通过修改原始的与内存相关的库函数，我们可以实现需要监视整个堆内存状态的内存检测器。EM-Fuzz通过库包装技术[8]实现了这一目标，该技术保留了原始堆布局。

![](images/Pasted%20image%2020230807153954.png)

我们实现库包装，为每个与内存相关的库函数添加序言和尾声。插入的序言优先于执行与内存相关的库函数，后者修改函数参数并为不同的内存区域分配适当的内存阴影状态(详见第III-A3节)。epilogue在标准库函数返回之前执行，修改相应的返回值。对于大小为P的堆内存，根据图2(a)中的用户代码的请求，序段将虚拟内存重新布局为图2(b)所示的新内存大小Q。用户代码(如malloc)请求的内存大小P和实际分配的内存大小Q满足以下等式:

![](images/Pasted%20image%2020230807154632.png)

举个例子，如果用户使用malloc(5)请求5个字节的堆内存，序言的存在会导致实际分配40个字节，其中16个字节是两个红区(默认m = 8)， 16个字节是辅助填充，3个字节是系统填充，5个字节可供用户使用。假设分配的40字节的起始地址是0x804b008, epilogue在malloc返回之前将返回地址设置为0x804b010。

3)内存检测器:内存检测器必须跟踪内存使用状态以检测内存漏洞。EM-Fuzz使用内存阴影来标记每个堆内存字节的状态。在一定时间内，每个字节的内存阴影只能是以下四项中的一项:
- unaddressable::固件内的程序不允许访问的非法堆内存。
- uninitialized::已分配但尚未写入的可寻址堆内存。
- defined:已分配并已写入的可寻址堆内存。
- readable:可寻址堆内存，仅在字符串处理库函数中可读。

图2(b)和图2(c)说明了不同堆内存区域与内存阴影之间的对应关系。不可寻址内存区域不仅包括红区和系统填充，还包括其他未分配的内存地址。满足用户代码请求大小的内存区域可以是未初始化的，也可以是已定义的，这取决于用户代码是否给它们赋值。辅助填充区域被标记为可读，仅在字符串处理库函数中可用。

![](images/Pasted%20image%2020230807155436.png)

表1列出了EM-Fuzz支持的10种常见的堆内存漏洞类型，以供检查。每种类型的漏洞对应于EM-Fuzz中的一个内存检测器，如第1列所示。第2栏解释了EM-Fuzz的简单实现原则。例如，缓冲区溢出意味着将数据写入超出缓冲区边界的相邻内存位置。EM-Fuzz通过确定指令是否将数据写入系统填充、辅助填充和标记为不可寻址或可读状态的右红色区域来检测此行为。内存泄漏检测器有点特殊，它挂钩退出系统调用，并计算不在不可寻址状态的内存字节。如果没有可读状态，在字符串处理函数中从堆内存中读取数据通常伴随着缓冲区过读误报。以strlen函数为例，为了提高效率，它可能不会逐个字节地从堆内存中读取字符，并确定是否存在终止符' \0 '。strlen函数的不同实现版本可以一次读取一个字、双字甚至16字节(使用SSE指令集)，从前到后查找终止符并返回字符串长度。为了消除这种类型的误报，我们使用标记为“可读”的辅助填充来过滤掉字符串处理库函数中发生的缓冲区过读。
### B.引导模糊测试
算法1给出了附加内存敏感操作引导模糊的总体过程。第1-17行是主要的伪代码实现，它将持续执行，直到达到超时或故意终止模糊测试，其中对现有模糊测试的改进用灰框特别标记。优化的目的是更容易地探索难以到达的深度路径，而不会失去路径探索的广度，并为脆弱的代码区域提供更多的机会进行耗尽内存检查。下面描述了每个步骤的细节。

![](images/Pasted%20image%2020230807160254.png)

1)模糊控制器(Fuzzing Controller):作为整个模糊过程的基础，模糊控制器在执行突变阶段衍生的每个测试用例后接收反馈，包括分支覆盖和内存敏感操作。它跟踪已发现的每个分支，并记录哪些测试用例覆盖了该分支。同时，它负责更新用于动态分离公共分支和稀有分支的全局阈值。它还记录了哪些内存敏感操作(例如，malloc, free)包含在每个测试用例的执行跟踪中。这些信息为后续的种子选择、能量分配和种子突变提供了充分的支持。

2)种子选择器:为了更快、更早地覆盖难以覆盖的分支，EM-Fuzz利用基于分支频率的种子跳过原理选择突变种子，有效解决了现有的模糊器[5]、[6]、[10]可能导致一些难以覆盖的分支较晚或未被发现的问题。

我们使用hit count这个术语来表示分支被执行的次数。EM-Fuzz最初对输入队列I的每个种子执行一轮突变，以获得记录每个分支命中次数的映射M，并获得所有观察到的分支集合B。每次执行新生成的种子时，M和B的值都会更新。设n为种子s2 I中的分支数，bj为第j个分支，mb表示命中次数最少的分支。我们使用公式(2)表示基于每个分支执行频率的种子S被跳过的概率，其中γ为平衡常数。

![](images/Pasted%20image%2020230807161707.png)

根据上述公式，我们知道执行稀有分支的种子被跳过的概率较低。它确保已观察到的难以到达的区域仍然可以更容易地覆盖。然而，它也给了在其他模糊器中不受欢迎的种子一定的被选中的可能性，这增加了覆盖其他以前从未见过的难以到达的区域的机会。以类似的方式，我们可以增加覆盖较少内存敏感操作的种子的跳过概率。

3)种子变异器:该步骤包括计算突变能量和应用突变策略两个阶段。它们直接决定了EM-Fuzz何时可以实现最大的分支覆盖，以及可以检测到多少漏洞。

突变的能量。EM-Fuzz在AFLFast的基础上，考虑分支命中数和内存敏感操作次数，给予不同种子适当的突变能量[6]。在EM-Fuzz中实现了具有内存检测插桩功能的固件仿真器。在处理每个测试用例的过程中，它记录了几类内存敏感的操作，包括分配函数(如malloc、calloc)、移动函数(如memmove、strcpy)、比较函数(如strcmp、memcmp)、释放函数(如free)等，这些都是容易造成漏洞的库函数。

设c(S)表示种子S从输入队列I中被选择的次数，f(S)表示种子S执行轨迹中脆弱库函数的个数，mb为种子S覆盖的分支中命中次数最少的分支，M(mb)为其命中次数。新的突变能量E的计算公式为(3):

![](images/Pasted%20image%2020230807162142.png)

其中α > 1是平衡原AFL能量E0与新EM-Fuzz能量E之间关系的常数，U是突变数的上界。它通过额外考虑内存敏感操作来改进AFLFast的指数能量分配策略，从而增加了测试脆弱代码区域的频率。

变异策略。EM-Fuzz借鉴FairFuzz的部分思想，结合我们提出的种子选择策略，对不同的种子采用不同的突变策略，其中限制突变策略和随机突变策略。算法1中的第7行首先判断所选种子S是否覆盖稀有分支。如果是这样，它将执行限制性突变，继续覆盖难以到达或内存敏感的分支。否则，它会执行随机突变，覆盖更大范围的新分支。设min_hit表示B中所有分支的最小命中数，随着新的测试用例的执行，每个分支的命中数也在不断增加，只有命中数为M(b)且满足式(4)的分支属于稀有分支rb。

![](images/Pasted%20image%2020230807162455.png)

其中rarity_cutoff是分隔普通分支和稀有分支的阈值，其实时值为$2^{log_2min\_hint}$。

如果选择的种子遇到稀有分支或记忆敏感分支，EM-Fuzz应用受限突变策略。它首先确定所选种子的哪些固定偏移值应保持不变。因此，EM-Fuzz通过尝试三种类型的操作(插入、删除和替换)对种子S的每个字节执行一轮突变。如果对固定偏移量的任何突变操作使新获得的测试用例不再击中与原始种子S相同的稀有分支，则这些固定偏移量属于不可变键字节，反之亦然。这些不可变的字节将在受限突变策略期间保持不变，EM-Fuzz根据分配的突变能量对种子的其他偏移量执行随机突变策略。对于未命中稀有分支或记忆敏感分支的选择种子，EM-Fuzz遵循AFL原有的随机突变策略，以增加发现新分支的概率。

4)流程执行:当执行每个测试用例时，EM-Fuzz确定它是否会导致固件崩溃或损坏。如果是这样，EM-Fuzz将这样的测试用例添加到缺陷队列D中，否则，它将度量是否命中了一个感兴趣的分支ib。以下两个条件之一使种子变得有趣:1)执行一个在之前的分支集B中未观察到的新分支。2)测试用例T执行分支ib的次数与输入队列I中之前任何测试用例t0的执行次数显著不同，表示为

![](images/Pasted%20image%2020230807163203.png)

其中HS(T',ib)表示分支ib被测试输入T执行的次数，|blog2(·)|是对数以2为底的floor函数。

## 4.实现与评估
EM-Fuzz的固件仿真器基于QEMU仿真平台增加了内存检查插桩[11]。它主要分三部分对原来的QEMU进行了增强，以实现动态运行时插桩。首先，当QEMU开始运行固件二进制文件时，它装载共享内存以记录分支覆盖信息和内存敏感操作的数量。然后，在执行每个翻译块之前，它会设置一个值来唯一标识每个翻译块，类似于AFL[5]。因此，在处理测试用例时，可以将两个相邻翻译块之间的转换关系和内存敏感操作信息更新到相应的共享内存中。最后，当在翻译块执行过程中遇到与内存相关的库函数调用时，它会包装原始库函数并设置相应的内存阴影，如第III-A2节所述。如果遇到到堆地址的内存写/读指令，它会回调嵌入在增强型QEMU中的十种内存检测器，以检测堆内存缺陷。

增强的QEMU仿真器与引导模糊测试模块一起工作。两者都由建立在AFL之上的同步控制器控制[5]。为了减少低吞吐量对固件模糊测试的影响，我们依靠内存检查插桩的重要反馈来获得闭源固件的内存敏感操作，并加强了原始AFL的三个功能:允许队列I中的每个种子按照跳种原则参与突变，根据分支命中数和内存敏感操作分配突变能量，并对选择的不同种子采用合适的突变策略。

我们评估EM-Fuzz是否能够解决测试真实世界嵌入式固件中的瓶颈，并有效地发现多种类型的漏洞。我们想回答以下三个研究问题:
- RQ1:分支发现的效率。EM-Fuzz在提高分支覆盖固件方面是否有效?
- RQ2:漏洞暴露的有效性。EM-Fuzz在暴露多种类型的漏洞方面是否有效?
- RQ3:内存检测器的性能。EM-Fuzz检测器对跨架构固件的性能如何?

### A.实验设置
我们评估了EM-Fuzz在六个嵌入式程序上的性能，包括其他工作[6]，[12]中也研究过的程序。它们来自表二所列的两种嵌入式设备固件。第一类是协议程序(ICCP[13]、IEC104[14]和IEC61850[15])，它们是从电力工业中负责控制中心与远程终端单元(rtu)之间进行时间关键信息交换的变电站自动化设备中提取的。第二类包含从OpenWRT路由器固件中提取的三个广泛使用的程序(安全通信工具包OpenSSL、数据处理库HTSlib和MXML)。我们将EM-Fuzz与两种最先进的fuzzers进行比较，以回答RQ1和RQ2，包括AFL[5]和AFLFast[6]。RQ3通过与广泛使用的二进制记忆检测器Dr.Memory进行比较来响应[8]。

![](images/Pasted%20image%2020230807164447.png)

我们在36核(Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz)、128GB主存、Ubuntu 16.04.6 LTS作为主机操作系统的64位机器上进行实验。对于每个工具，我们在24小时内运行每个固件程序10次。我们用相同的种子文件重复每个程序十次，以减少模糊的随机性。在随后的实验中报告的结果是在对每个测试目标进行10次独立运行后总结的。

### B.分支发现的效率
在这里，我们回答关于EM-Fuzz在有限时间内可以实现的覆盖范围的RQ1。我们选择24小时模糊测试所覆盖的分支数量作为评估效率的指导方针。图3描绘了分支发现的趋势，显示了每个工具在10个24小时运行的每个时间点平均发现的分支元组总数。在所有模糊化的程序中，EM-Fuzz最终获得了更高的分支覆盖数，EM-Fuzz曲线高于图3中的其他曲线。EM-Fuzz在所有六个固件程序上平均覆盖3386个分支，分别比AFL和AFLFast多93.98%和46.89%。

![](images/Pasted%20image%2020230807164611.png)

对于特定的OpenSSL程序，EM-Fuzz涵盖了多达7862个分支，比AFL多1.78倍，比AFLFast多0.49倍。我们还可以看到，四个程序上的AFL和AFLFast曲线最终趋于稳定，不再增加，称为“饱和”。除了OpenSSL和MXML程序，AFL在对其他4个程序进行大约5小时的模糊测试后达到饱和。不包括IEC104, OpenSSL和https程序，AFLFast在大约16小时内达到饱和。然而，EM-Fuzz仍然呈现出在24小时模糊测试中覆盖所有程序的分支数量增加的趋势。原因是EM-Fuzz的突变策略倾向于更早地覆盖稀有分支，从而更容易在短时间内探索更深入的程序路径。对于IEC61850协议程序，其有效输入可能包含几个特定的字段，其中不同的字段匹配不同的应用程序功能，EM-Fuzz生成更有趣的测试输入，以涵盖与这些功能相对应的一系列分支。实验结果表明，EM-Fuzz不仅在分支发现数量上具有优势，而且在速度提升方面也具有优势。

与其他4个方案相比，ICCP和IEC104协议方案在分支覆盖方面的改善幅度较小。造成这种情况的原因有两个。首先，我们对这六个程序的二进制进行了反向分析，发现这两个程序的规模较小，分支数明显少于其他四个程序。因此，即使是分支覆盖率的小幅增加也不是微不足道的。并且先前的研究[16]表明，在达到一定的覆盖率之后，即使分支覆盖率很小的增加也可以获得更多的缺陷发现能力。其次，随着时间的推移，稀有分支逐渐成为常见分支，其他稀有分支被重新发现的数量不足。因此，EM-Fuzz的突变策略不能充分发挥其价值。

### C.漏洞暴露的有效性
在这里，我们回答RQ2，并关注EM-Fuzz是否可以有效地暴露固件中的多种类型的漏洞。我们选择数字和时间来说明。

1)漏洞总数:暴露漏洞的能力是fuzzers的一个重要指标。因此，我们统计了官方确认的漏洞数量，包括再现现有的已知漏洞和发现以前未知的漏洞。在使用每个工具运行每个程序10次之后，我们将每个工具发现的官方确认的漏洞总数填充到表III中。第1列为固件名称。第2列为每个漏洞的标识符信息，其中“CVE- xxx”表示该漏洞已在美国国家漏洞数据库中被正式确认并分配了唯一的CVE标识符[17]，“Bug-XXX”表示该漏洞已报告给相应的产品厂商并被正式确认，之前未知的漏洞标记为*。第3、5和7列表示比较中的三个工具是否暴露了每个漏洞，如果是，则用复选标记(X)填充相应的单元格;否则为空。

![](images/Pasted%20image%2020230807164955.png)

从表III可以看出，EM-Fuzz一共发现了23个漏洞，比AFL和AFLFast分别多出16个和13个。EM-Fuzz发现的23个漏洞中的16个以前是未知的。这两个工具一起比较了16个以前未知的漏洞，只发现了其中的6个。在ICCP协议程序的四个漏洞中，AFL和AFLFast只发现了一个分段故障漏洞(简称为SIGSEGV)。IEC104协议程序也存在类似的情况。这主要得益于实时内存检查器和额外内存检测获取的内存敏感操作信息。它不仅可以暴露那些不会导致崩溃的漏洞，而且还有助于了解测试输入的能量，并生成更频繁地探索更深层次和更脆弱的程序区域的测试输入。例如，AFL和AFLFast都不会暴露IEC104协议程序中Bug-2019-0921识别的SIGSEGV漏洞。同样，他们在HTSlib库中也没有发现在10次运行中访问高通量测序数据的漏洞。这表明EM-Fuzz具有更好的检测嵌入式固件漏洞的能力。

2)发现的漏洞类型:我们分析每个工具暴露每种漏洞类型的能力。表4列出了统计结果，其中每个漏洞只属于一个特定的类型，不与其他类型共享。从表4中，我们可以看到EM-Fuzz在报告每个类别中的漏洞数量方面表现得更好。EM-Fuzz发现的前6类漏洞占了23个漏洞中的12个，占比为52.17%。AFL和AFLFast都不能报告与堆越界访问相关的任何漏洞。通过对这12个漏洞的分析，我们发现其中7个漏洞只略微越过了相应的堆边界。它不足以导致固件崩溃，所以AFL和AFLFast不能暴露它们。通过实现堆内存检测器，EM-Fuzz可以准确地报告固件程序中的堆内存问题。

![](images/Pasted%20image%2020230807165255.png)

除了堆内存漏洞，我们关注表4中的最后三种类型的漏洞。因为它们很容易导致崩溃，所以比较中的每个工具都表现良好。AFL和AFLFast分别暴露了7个和10个漏洞，分别仅占EM-Fuzz发现的这三类漏洞的63.64%和90.91%。原因类似于前面的说明，EM-Fuzz对固件应用优化的模糊测试策略。传统的分支和额外的内存敏感操作信息引导模糊测试更容易探索难以到达的深度路径，并为脆弱的代码区域提供了更多的穷举模糊测试机会。这些统计数据表明，传统的模糊方法在检测导致目标崩溃的漏洞方面表现良好。相比之下，EM-Fuzz的实时内存检查，我们可以发现更多的嵌入式固件漏洞。

3)漏洞发现时间:虽然EM-Fuzz可以更快地覆盖更多分支并发现更多漏洞，但我们想知道暴露漏洞需要多长时间。表III中的“时间”列列出了三个工具在10次运行中暴露每个漏洞的最小时间。空单元格表示对应的工具在10个24小时的实验中没有发现漏洞。我们可以看到EM-Fuzz花了13个小时暴露了全部23个漏洞，其中17个漏洞可以在10小时内暴露。总体而言，AFL和AFFLFast比EM-Fuzz平均多花费1.71倍和1.54倍的时间暴露漏洞。例如，AFL需要22小时才能暴露CVE-2018-19121漏洞，AFLFast需要21小时才能暴露CVE-201819122漏洞。相比之下，IEC61850协议程序中的CVE-2018-19185漏洞可以在2小时内被EM-Fuzz报告。

4)EM-Fuzz的时间开销:在相同的运行环境下，我们选择了四个开源项目(coretils [18]， libpng [19]， zlib [20]， yaml-cpp[21])，这些项目也在其他作品[6]，[12]中进行了研究，以评估EM-Fuzz引入的时间开销。使用不带内存检查工具的QEMU模拟器运行这些项目的成本比直接在本机处理器上运行它们的成本高3 - 5倍。当启用内存检查工具时，时间成本将再次平均增加1.5倍，达到4.5 - 6.5倍。
### D.内存检测器的性能
我们回答了关于EM-Fuzz是否可以在统一的测试环境中准确地检测针对不同架构固件的堆内存漏洞的RQ3问题。为了说明准确性和多功能性，我们将EM-Fuzz的内存检查器模块与最先进的内存检查器Dr.Memory[8]，它们都运行在第IV-A节中描述的X64架构的服务器上。由于Dr. memory没有自动生成测试用例的能力，我们保存了所有从EM-Fuzz的模糊阶段派生的测试用例。当使用Dr. memory测试固件时，依次输入这些测试用例。因为Dr.Memory的主要能力是用来检测堆内存漏洞的，因此，为了与Dr. Memory进行更好更公平的比较，这里只统计堆内存漏洞。对所有检测到的堆内存漏洞进行汇总和重复数据删除，结果如表5所示。

![](images/Pasted%20image%2020230807165834.png)

EM-Fuzz可以在所有六个固件程序中检测到12个堆内存漏洞，而Dr. memory只能在基于x86的程序中检测到4个堆内存漏洞。EM-Fuzz和著名的内存检查器Dr. memory一样，分别在ICCP和IEC104程序中准确检测到3个和1个堆内存漏洞。这意味着EM-Fuzz可以准确地识别固件中的堆内存漏洞。Dr. Memory无法在其他四个程序上工作的原因是，其插桩框架DynamoRIO[22]也需要在基于ARM的机器上运行以检测ARM架构固件。与之不同的是，EM-Fuzz可以使用统一的测试环境，例如在X86机器上，通过使用内存检查工具实现的模拟器来检测多架构固件的内存漏洞。这个特性使EM-Fuzz更加高效和实用，它可以使用资源丰富的服务器模糊跨架构固件，并额外暴露隐藏在其中的内存漏洞。

### E.真正的脆弱性案例研究
在实验过程中，EM-Fuzz暴露了两个很容易导致拒绝服务(DoS)的严重漏洞，OpenSSL上的CVE-2016-2108和IEC104上的Bug-2019-0921。以CVE-2016-2108漏洞为例，该漏洞的CVSS (Common vulnerability Scoring System)评分[23]最高，为10.0，属于易造成灾难性后果的漏洞。考虑图4所示的测试输入，它是遵循抽象语法符号1标准(ASN.1)的数据对象描述结构。为了实现网络通信，ASN.1解析器asn1parse根据特定的编码规则，如DER、PEM等，将图4左边的数据结构编码为序列化的二进制流。如图4的代码片段所示，现有的fuzzers很难生成测试输入来触发包含漏洞实现的第422行分支条件。当解析器对二进制流进行反序列化时，如果INTEGER类型的值为'0x-0'，解析器将在i2c_ASN1_INTEGER函数中生成一个缓冲区underflow，并进行越界写入。缓冲区下溢的直接后果是，分配的堆的块字段无意中被修改，这会导致解析器在释放损坏的堆内存时崩溃。反序列化和序列化过程允许远程攻击者破坏内存，间接导致拒绝服务漏洞。

![](images/Pasted%20image%2020230807170255.png)

只有EM-Fuzz在实验中重现了高风险漏洞。使用EM-Fuzz的模糊化策略，更容易生成格式良好的测试输入，并为这些测试输入分配更多的突变能量，这增加了除“0x-0”之外的其他内容正确的概率。它将保持“sequence”和“INTEGER”不可变;否则，解析逻辑将进入错误处理分支。****

## 5.讨论
在本节中，我们将讨论EM-Fuzz的局限性，并指出未来的研究工作。第一个可能的威胁是EM-Fuzz可以发现的漏洞类型。EM-Fuzz虽然集成了高效灰盒模糊测试和内存检查来增强嵌入式固件的漏洞发现能力，但它主要侧重于发现固件中的以下漏洞类别，包括程序崩溃、执行超时、静默内存损坏和一些逻辑错误(例如，无限循环)。然而，EM-Fuzz并没有表现出足够的优势来对抗固件中与web安全相关的漏洞，比如XSS和命令注入。主要原因是当前的实现没有包含合适的监视器来识别通常不会导致崩溃的漏洞。一种可行的解决方案是在本地网络中建立一个基于代理的服务器，以确定监控服务器是否被固件访问，从而识别XSS和命令注入漏洞[3]。

另一个威胁是，模糊测试可能会陷入分支覆盖饱和的状态，尽管我们已经为嵌入式固件提出了几种优化的模糊检测策略，以更好地平衡分支发现的深度和广度。然而，随着模糊测试时间的推移，固件代码中可能存在一些特殊的过滤机制(例如CRC校验和和哈希映射)导致模糊测试卡住。这意味着它需要付出大量的努力来发现新的分支。当超过阈值后没有发现新的分支时，一种可行的解决方案是使用符号执行来生成测试用例，以绕过难以覆盖的某些分支[24]。

## 6.相关工作
### A.二进制模糊测试技术
当源代码不可用时，黑盒[2]、[25]、[26]和灰盒[5]、[6]、[10]、[12]、[27]、[28]、[29]技术在二进制模糊测试领域占据主导地位。基于突变的黑盒模糊器[25]、[26]根据指定的模糊器比例对测试输入内相应的比特比例进行突变。SymFuzz[26]通过确定执行跟踪和测试输入的位位置之间的依赖关系，自适应地设置模糊比。基于生成的黑盒模糊器[2]根据规范从零开始生成输入。Peach[2]依靠描述输入数据格式的预定义数据模型和描述具体测试输入生成策略的状态模型来指导模糊测试。黑盒模糊测试技术的局限性在于，测试输入生成过程缺乏来自程序执行跟踪的反馈，并导致低代码覆盖率。

灰盒模糊技术收集代码覆盖率信息，这些信息直接影响突变过程中涉及的种子集。AFL[5]是许多此类技术的代表，这些技术通过确定性和随机突变不断生成测试输入。AFLFast[6]优化了AFL选择下一个突变种子的策略，优先突变覆盖低频路径的种子。FairFuzz[10]修改了AFL的突变算法。它在确定性和随机突变阶段都有目的地突变选定种子的特定字节。PAFL[30]利用高效的引导信息同步和任务划分，将现有的单一模式的模糊优化[6]、[10]扩展到工业并行模式。将模糊测试技术与符号执行或程序分析相结合[24]，[31]，[32]是灰盒二进制测试领域的另一个改进。例如，Driller[24]在大多数情况下使用模糊测试来探索被测程序路径。然而，当模糊控制陷入困境时，它使用混合执行来生成新的输入，以满足模糊器无法满足的条件。然而，这些灰盒模糊测试技术适用于具有特定硬件架构的桌面二进制文件，如果没有支持内存检查器的工具，它们在嵌入式固件中的可用性和效率将大大降低，因为内存检查器不会导致崩溃。

### B.二进制内存检查
内存漏洞检测是保证二进制安全的重要手段。常见的二进制内存检查工具依赖于不同的阶段(例如，编译时、链接时和运行时)插入检测逻辑。Purify[33]是最早的商业内存检查工具之一，依靠链接时间检测来检测自由使用和内存泄漏漏洞。MemCheck[7]是目前使用最广泛的内存漏洞检测工具。它首先将二进制指令转换为VEX[34]中间表示(VEX- ir)，然后在VEX- ir上插入检测算法，最后将其转换回二进制指令，从而在Valgrind[34]动态检测平台上实现内存检查。Dr. memory[8]基于DynamoRIO[22]插装框架，使用代码缓存机制支持对运行在多个操作系统上的二进制文件进行基于堆的内存检查。Parallel Inspector[35]是一个内存和线程错误调试器，建立在Pin[36]动态检测框架上，适用于IA-32、x86-64和MIC指令集架构。上述工具是可行的，前提是它们可以安装在与被测二进制文件相同的运行环境中(例如，相同的CPU体系结构)。此外，这些工具依赖于额外的测试用例来触发执行和分析过程。

## 7.结论
在本文中，我们提出了EM-Fuzz，一种通过内存检查来增强嵌入式固件漏洞发现能力的增强模糊测试技术。在动态检测的基础上，我们可以插入多个漏洞检查器来检测那些不会导致系统崩溃的漏洞，并收集敏感的内存操作来保护模糊器，从而生成更多高质量的测试用例，并对那些脆弱的代码区域进行详尽的内存检查。在实际嵌入式固件上的实验结果表明，EM-Fuzz不仅在漏洞发现数量上具有优势，而且在速度上也有提升。它已经暴露了23个安全漏洞，其中16个是新发现的以前未知的漏洞。在未来，我们计划通过支持更多架构和集成更多内存安全威胁检查器来扩展EM-Fuzz。