IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems，2020；CCF A

ACM会议 EMSOFT

未开源

# 翻译
## 摘要
在新兴的应用场景中，嵌入式系统的互联性越来越强。这些应用程序中的许多都是安全关键型的，因此确保系统不受恶意攻击是重中之重。这项工作旨在检测漏洞，这些漏洞可能被攻击者利用来破坏嵌入式固件中的功能正确性，特别是由于缺乏源代码，这是具有挑战性的。

我们特别提出了EM-Fuzz，这是一种固件漏洞检测技术，它将模糊检测与实时内存检查紧密结合在一起。基于内存插桩的固件模糊测试，既可以通过传统的分支覆盖引导生成高质量的种子来探索难以到达的区域，也可以通过记录的内存敏感操作来持续尝试容易被攻击的敏感区域。更重要的是，该工具集成了实时内存检查器，以暴露内存漏洞，现有的没有源代码的fuzzers不支持这一点。在OpenSSL等实际嵌入式固件上的实验表明，EM-Fuzz显著提高了AFL和AFLFast等最先进的模糊测试工具的性能，覆盖率分别提高了93.98%和46.89%。此外，EM-Fuzz总共暴露了23个漏洞，平均每个漏洞约7小时。AFL和AFLFast总共发现了10个漏洞，平均每个漏洞花费的时间分别为13小时和10小时。在这23个漏洞中，有16个以前是未知的，并已报告给上游产品供应商，其中7个已在美国国家漏洞数据库中分配了唯一的CVE标识符。

索引术语-嵌入式固件，引导模糊测试，内存检查，漏洞。

## 1.引言
随着5G及以后技术的发展，嵌入式系统的连通性将在高度自动化车辆、家用机器人和工业4.0等新兴应用场景中变得越来越强。这些应用程序通常是安全关键型的，严格要求功能正确。因此，需要确保系统不受恶意代码注入、拒绝服务(DoS)等恶意攻击。然而现实是残酷的。Cui等[1]扫描了网络上约400万台嵌入式设备，发现其漏洞率为13.81%。这项工作的目标是嵌入式固件，漏洞检测是具有挑战性的，特别是由于缺乏源代码。

为了增强漏洞暴露能力，模糊测试成为近年来固件测试的研究热点[2]，[3]，[4]。Peach[2]是一个半自动的跨平台模糊测试框架，它根据人工构建的输入规范生成测试输入。SRFuzzer[3]是一个全自动模糊测试框架，用于对物理SOHO(小型办公室/家庭办公室)路由器的web服务器进行模糊测试。IoTFuzzer[4]使用移动应用程序的程序逻辑来生成探测目标固件的有意义的测试用例。尽管这些方法确保了报告漏洞的真实性，但它们属于不考虑执行反馈的黑盒模糊测试技术。因此，漏洞发现的效率并不令人满意。

灰盒模糊测试技术在带有源代码的程序上显示了有效的漏洞发现能力，因此首先想到的是使用QEMU进程仿真在嵌入式固件上执行类似的灰盒模糊测试。在没有嵌入式设备的情况下，QEMU仿真器确实成为模糊测试固件的首选，因为它具有相对完整的跨架构仿真能力，并且支持插桩来反馈分支覆盖信息。工具的二进制版本，如AFL[5]和AFLFast[6]，就是这种实现的代表，使用分支覆盖来连续地指导测试输入的生成。然而，我们在实践中发现，它们处理嵌入式固件的能力受到了极大的损害。有两个主要原因阻碍了这些工具在嵌入式场景中的使用。

一个原因是，与使用源代码模糊目标相比，使用QEMU仿真器模糊固件的时间成本更高，并且在单位时间内可以执行的测试用例数量(也称为吞吐量)要低3 - 5倍。虽然现有的fuzzers[5]，[6]可以应用于嵌入式固件，但它们面对低吞吐量的能力受到不适当的突变频率的限制。例如，AFL的盲突变策略难以使有意义的种子突变以有效到达难以到达的区域，从而导致被测目标的崩溃。

另一个原因是，当固件源代码不可用时，现有的fuzzers无法实现可以与各种杀毒程序(例如，AddressSanitizer, ThreadSanitizer)结合使用的源代码插桩来检查内存损坏。根据NVD近三年的统计，至少9.82%的被纳入漏洞与内存漏洞有关，如use-after-free、buffer overflow等。这使得固件中隐藏的内存漏洞不太可能被无助的fuzzer检测到。虽然MemCheck[7]、Dr. memory[8]等成熟的内存检查器通过二进制检测在二进制内存漏洞检查领域占据主导地位，但它们在固件上有较大的局限性。它们是可行的，前提是它们可以安装在与被测二进制文件相同的运行环境中(例如，相同的CPU架构)。在已经发布的固件中安装这些内存检查器是不切实际的，因此它们基本上不能与固件一起工作。此外，即使它们包含在固件中，在没有指导模糊测试的情况下执行任意测试用例可能会很耗时，并且根本不会报告漏洞。

> 原因：1.QEMU仿真模糊测试执行速度慢；2.源代码不可以无内存破坏检查辅助

在嵌入式场景中，虽然现有的灰盒模糊器和内存检查器可以发挥一定的功能，但它们是孤立的。将模糊测试和内存检查相结合，发挥各自的优势，我们面临以下挑战:

1)有效的内存插桩。增强型fuzzer需要必要的动态固件插桩，包括集成常见类型的内存检测器和以统一的方式记录内存敏感操作。

2)多架构支持。由于嵌入式设备应用场景的不同，固件CPU架构呈现出多样性。使用统一的运行环境来处理多种架构的固件模糊测试是非常受欢迎的。

3)覆盖指导和内存指导的协作。传统的分支引导信息不足以充分发挥组合能力。发现更深更广的程序路径并触发尽可能多的内存漏洞敏感操作是我们的理想目标。

为了解决上述挑战，我们提出了EM-Fuzz——一种增强的固件漏洞检测技术，通过将模糊测试与实时内存检查紧密集成。内存检查模块通过内存hook和库包装完成固件插桩任务，解决了挑战1.除了集成内存检测器以彻底识别内存漏洞外，它还监视并记录详细的内存敏感操作。EM-Fuzz中的模糊测试和内存检查都是基于QEMU仿真器实现的。因此，使用这个统一的运行环境来解决挑战2中的多体系结构支持，并在挑战1中提供内存检查工具的功能是合理的。增强的QEMU仿真器在仿真固件时，收集支路覆盖信息和内存敏感操作，共同指导模糊的突变方向，解决了挑战3。前者引导模糊器根据传统的分支频率选择种子，并采用随机和受限的突变策略对种子进行突变，保证了模糊的深度和广度;后者引导模糊器为执行记忆敏感操作的种子分配更多的突变时间，这增加了更频繁地覆盖脆弱区域的机会。

为了进行评估，我们考虑了现实世界的嵌入式固件程序，例如从变电站自动化系统(SAS)固件中提取的IEC61850协议，并将EM-Fuzz与两种最先进的fuzzers: AFL[5]和AFLFast[6]进行了比较。实验结果表明，EM-Fuzz显著提高了性能。特别是EM-Fuzz总共暴露了23个漏洞，而AFL和AFLFast分别暴露了7个和10个漏洞。结合AFL和AFLFast的结果，只发现了10个漏洞。EM-Fuzz发现的23个漏洞中，有16个是以前未知的，已经报告给上游产品供应商，其中7个已经分配了唯一的CVE标识符。在时间成本方面，EM-Fuzz发现一个漏洞平均需要7个小时，分别是AFL和AFLFast所需时间的54%和70%。

综上所述，本文做出了以下贡献:
- 据我们所知，EM-Fuzz是第一个集成了高效灰盒模糊和内存检查的工具，以增强嵌入式固件上的漏洞发现能力。虽然模糊测试在桌面应用程序上显示了令人印象深刻的性能，但对于没有源代码的嵌入式固件来说，这项工作是一个迈步。
- 我们通过动态运行时插桩将10种常见类型的内存检测器集成到EM-Fuzz中，这能够增强模糊测试，以发现现实世界固件中更多以前未知的漏洞。
- 我们提出了一种优化的嵌入式固件模糊测试策略。传统的分支和附加的内存敏感操作信息引导模糊探测难以到达的路径，并为脆弱的代码区域提供更多的内存耗尽检查机会。
- 我们将EM-Fuzz应用于真实的嵌入式固件，并发现了许多以前未知的漏洞。

论文组织:第二节给出了一个鼓舞人心的例子。第三部分详细介绍了EM-Fuzz的设计。第四节实现EM-Fuzz并报告实验结果。第五节指出今后的研究工作。第六部分为相关工作，第七部分对全文进行总结。

## 2.动机案例
为了展示EM-Fuzz如何通过内存检查工具提高模糊测试性能并暴露更多漏洞，我们浏览了清单1中所示的源自IEC61850嵌入式固件的修剪过的代码片段。块D中隐藏着两个漏洞。

![](images/Pasted%20image%2020230806114044.png)

### A.内存插桩的必要性
假设传统的fuzzer有机会探索难以到达的D区域，它仍然可能不会暴露任何内存漏洞。在没有任何内存检查器帮助的嵌入式场景中，fuzzers将认为块D运行正常，因为溢出和内存泄漏没有严重到使目标固件崩溃。如前所述，现有的内存检查器(如MemCheck [7]， Dr. memory[8])需要安装在与被测固件相同的环境中，并运行现有的测试输入来检测内存漏洞。现有的杀毒程序(例如AddressSanitizer, ThreadSanitizer)需要原始源代码来完成插桩，这在黑盒嵌入式固件的测试中是不切实际的。

详细地说，清单1的第14行和第15行分别为other和data变量请求8字节的堆内存。在32位操作系统环境中，每个变量实际上分配了16字节的内存，data的内存空间紧随other后。当data内存在第17行中首先被小于8字节的字符串填充，然后在第19行中other被大于16字节的字符串填充时，data内存的内容被other内存污染，因为data内存在other内存的后面。显然，应该报告导致数据完整性的缓冲区溢出问题。此外，第23行忘记释放第14行和第15行分配的内存。
如果不断调用函数parse_packet，则内存泄漏问题将使嵌入式设备耗尽资源。

在对跨架构固件进行模糊测试时，在统一的测试环境中对内存漏洞(如use-after-free、buffer overflow、memory leak)进行实时内存检查，可以显著提高漏洞检测性能。如果没有固件源代码，现有的模糊测试技术就不能很好地支持这个目标。

### B.有效模糊测试的必要性
在支持内存检查插桩后，检测第19行所示的缓冲区溢出漏洞需要测试输入满足两个条件:1)触发D块;2)为变量data和other包含适当的值。考虑到固件模糊测试的低测试输入吞吐量，理想的目标应该是对D块进行更深入的探索。

代码片段首先根据第4-5行中4-5和8-9的固定偏移量从数据包中获取魔术值和功能码。第8行确定2字节的魔术值是否等于0xB888，如果不等于，则意味着数据包无效，并在第26行中被过滤掉。由代表性的fuzzers，如AFL[5]， AFLFast[6]和FairFuzz[10]，生成的绝大多数测试用例都试图最大化传统的分支覆盖率。例如，AFL选择一个种子作为执行突变的首选项，如果它是任何观察到的分支中最快和最小的输入。FairFuzz对选择的种子执行限制突变策略，以增加到达相同的难以到达的分支的概率。然而，它的突变策略更倾向于探索更深的分支而不是更宽的分支，这导致了局部收敛问题。只考虑分支发生而忽略记录的内存敏感操作的权重可能会导致两个问题: 1)分支BD到达太晚;2)块C和块D的执行次数可能严重不平衡，其中D的触发频率较低。

EM-Fuzz的目标是通过记录的内存敏感操作指导的协作，尽早到达分支BD，并且执行D块的次数比执行C块的次数多。前者可以通过优化现有模糊器的选种策略和突变策略来实现。种子队列中的每个种子可以首先以与分支出现频率相反的概率进行选择。这个优化增加了种子命中分支BE的几率，而不是早期被丢弃，这有助于早期覆盖新的稀有分支BD。在突变阶段，如果选择的种子遇到了稀有分支和记忆敏感操作较多的分支，EM-Fuzz对种子采用限制性突变策略，以保持路径探索的深度。后者可以通过在突变阶段自适应更新种子突变能量来实现。如果种子碰到一个包含内存敏感操作的代码块(例如，malloc, free)，它会给种子更多的突变能量来增加这样的代码块被更多测试用例覆盖的次数。

## 3.EM-Fuzz设计
如图1所示，EM-Fuzz包含两个主要模块:内存检查插桩和引导模糊测试。通过紧密集成高效模糊检测和实时内存检查，分析人员能够快速定位固件中的严重安全威胁。内存检查插桩模块通过内存hook和库包装完成固件插桩任务，从而获得记录内存敏感操作的能力，以指导模糊测试和集成通用内存检测器来暴露内存损坏漏洞。模糊测试模块基于具有插桩功能的固件仿真器，以分支覆盖信息指导生成高质量的测试用例，探索难以到达的区域，以内存敏感操作指导触发易受攻击的脆弱区域。因此，增强固件模糊检测既保证了路径探索的深度和广度，又提高了漏洞暴露的能力。在整个模糊测试过程中，两个组件共享两个测试用例队列，包括输入队列I和缺陷队列D。

![](images/Pasted%20image%2020230806161748.png)

### A.内存检查插桩
内存检查插桩不仅负责反馈内存敏感操作以指导模糊测试，而且还负责集成内存检测器以彻底检查内存漏洞。它包含内存挂钩、库包装和内存检测器。

1)内存挂钩:EM-Fuzz中有两种主要类型的内存挂钩:指令挂钩和函数挂钩。指令挂钩将内存读和内存写指令拦截到堆地址。这用于确定是否存在内存漏洞。函数挂钩拦截与内存相关的库函数(例如，malloc, free)。其目的是在执行跟踪中记录对内存敏感的操作，并添加开场白和尾声动作。

对于指令挂钩，EM-Fuzz只挂钩涉及堆内存访问的指令。它的目的是获取堆内存地址的标记状态，以便内存检测器工作。因此，我们必须准确地将堆内存空间与整个虚拟内存空间区分开来。当EM-Fuzz将固件加载到模拟器中时，它将堆底部地址初始化为brk变量，表示为heapBottom = brk。每当分配新的堆内存空间时，brk变量的值就会增长，从而成为新的堆顶地址。EM-Fuzz只挂钩内存地址访问在heapBottom和brk范围内的指令。

对于函数挂钩，EM-Fuzz直接计算与内存操作相关的库函数的绝对虚拟内存地址。当模拟器执行main函数时，库函数__libc_start_main已经运行，并且它的起始地址存储在进程.got.plt节中。我们可以从libc.so库文件中获得__libc_start_main函数的偏移值。间接地，可以根据已知库函数的起始地址和偏移值计算出与内存相关的库函数的起始地址。没有直接从.got.plt中获得这些函数的起始地址的原因是其他库函数(例如，printf)也可以通过相同库文件中的偏移量调用这些函数，此时由于延迟绑定机制与内存相关的函数可能尚未加载到.got.PLT表。

2)库包装:EM-Fuzz的主要功能之一是支持固件的堆内存漏洞检测。通过修改原始的与内存相关的库函数，我们可以实现需要监视整个堆内存状态的内存检测器。EM-Fuzz通过库包装技术[8]实现了这一目标，该技术保留了原始堆布局。

![](images/Pasted%20image%2020230807153954.png)

我们实现库包装，为每个与内存相关的库函数添加序言和尾声。插入的序言优先于执行与内存相关的库函数，后者修改函数参数并为不同的内存区域分配适当的内存阴影状态(详见第III-A3节)。epilogue在标准库函数返回之前执行，修改相应的返回值。对于大小为P的堆内存，根据图2(a)中的用户代码的请求，序段将虚拟内存重新布局为图2(b)所示的新内存大小Q。用户代码(如malloc)请求的内存大小P和实际分配的内存大小Q满足以下等式:

![](images/Pasted%20image%2020230807154632.png)

举个例子，如果用户使用malloc(5)请求5个字节的堆内存，序言的存在会导致实际分配40个字节，其中16个字节是两个红区(默认m = 8)， 16个字节是辅助填充，3个字节是系统填充，5个字节可供用户使用。假设分配的40字节的起始地址是0x804b008, epilogue在malloc返回之前将返回地址设置为0x804b010。

3)内存检测器:内存检测器必须跟踪内存使用状态以检测内存漏洞。EM-Fuzz使用内存阴影来标记每个堆内存字节的状态。在一定时间内，每个字节的内存阴影只能是以下四项中的一项:
- unaddressable::固件内的程序不允许访问的非法堆内存。
- uninitialized::已分配但尚未写入的可寻址堆内存。
- defined:已分配并已写入的可寻址堆内存。
- readable:可寻址堆内存，仅在字符串处理库函数中可读。

图2(b)和图2(c)说明了不同堆内存区域与内存阴影之间的对应关系。不可寻址内存区域不仅包括红区和系统填充，还包括其他未分配的内存地址。满足用户代码请求大小的内存区域可以是未初始化的，也可以是已定义的，这取决于用户代码是否给它们赋值。辅助填充区域被标记为可读，仅在字符串处理库函数中可用。

![](images/Pasted%20image%2020230807155436.png)

表1列出了EM-Fuzz支持的10种常见的堆内存漏洞类型，以供检查。每种类型的漏洞对应于EM-Fuzz中的一个内存检测器，如第1列所示。第2栏解释了EM-Fuzz的简单实现原则。例如，缓冲区溢出意味着将数据写入超出缓冲区边界的相邻内存位置。EM-Fuzz通过确定指令是否将数据写入系统填充、辅助填充和标记为不可寻址或可读状态的右红色区域来检测此行为。内存泄漏检测器有点特殊，它挂钩退出系统调用，并计算不在不可寻址状态的内存字节。如果没有可读状态，在字符串处理函数中从堆内存中读取数据通常伴随着缓冲区过读误报。以strlen函数为例，为了提高效率，它可能不会逐个字节地从堆内存中读取字符，并确定是否存在终止符' \0 '。strlen函数的不同实现版本可以一次读取一个字、双字甚至16字节(使用SSE指令集)，从前到后查找终止符并返回字符串长度。为了消除这种类型的误报，我们使用标记为“可读”的辅助填充来过滤掉字符串处理库函数中发生的缓冲区过读。
### B.引导模糊测试
算法1给出了附加内存敏感操作引导模糊的总体过程。第1-17行是主要的伪代码实现，它将持续执行，直到达到超时或故意终止模糊测试，其中对现有模糊测试的改进用灰框特别标记。优化的目的是更容易地探索难以到达的深度路径，而不会失去路径探索的广度，并为脆弱的代码区域提供更多的机会进行耗尽内存检查。下面描述了每个步骤的细节。

![](images/Pasted%20image%2020230807160254.png)

1)模糊控制器(Fuzzing Controller):作为整个模糊过程的基础，模糊控制器在执行突变阶段衍生的每个测试用例后接收反馈，包括分支覆盖和内存敏感操作。它跟踪已发现的每个分支，并记录哪些测试用例覆盖了该分支。同时，它负责更新用于动态分离公共分支和稀有分支的全局阈值。它还记录了哪些内存敏感操作(例如，malloc, free)包含在每个测试用例的执行跟踪中。这些信息为后续的种子选择、能量分配和种子突变提供了充分的支持。

2)种子选择器:为了更快、更早地覆盖难以覆盖的分支，EM-Fuzz利用基于分支频率的种子跳过原理选择突变种子，有效解决了现有的模糊器[5]、[6]、[10]可能导致一些难以覆盖的分支较晚或未被发现的问题。

我们使用hit count这个术语来表示分支被执行的次数。EM-Fuzz最初对输入队列I的每个种子执行一轮突变，以获得记录每个分支命中次数的映射M，并获得所有观察到的分支集合B。每次执行新生成的种子时，M和B的值都会更新。设n为种子s2 I中的分支数，bj为第j个分支，mb表示命中次数最少的分支。我们使用公式(2)表示基于每个分支执行频率的种子S被跳过的概率，其中γ为平衡常数。

![](images/Pasted%20image%2020230807161707.png)

根据上述公式，我们知道执行稀有分支的种子被跳过的概率较低。它确保已观察到的难以到达的区域仍然可以更容易地覆盖。然而，它也给了在其他模糊器中不受欢迎的种子一定的被选中的可能性，这增加了覆盖其他以前从未见过的难以到达的区域的机会。以类似的方式，我们可以增加覆盖较少内存敏感操作的种子的跳过概率。

3)种子变异器:该步骤包括计算突变能量和应用突变策略两个阶段。它们直接决定了EM-Fuzz何时可以实现最大的分支覆盖，以及可以检测到多少漏洞。

突变的能量。EM-Fuzz在AFLFast的基础上，考虑分支命中数和内存敏感操作次数，给予不同种子适当的突变能量[6]。在EM-Fuzz中实现了具有内存检测插桩功能的固件仿真器。在处理每个测试用例的过程中，它记录了几类内存敏感的操作，包括分配函数(如malloc、calloc)、移动函数(如memmove、strcpy)、比较函数(如strcmp、memcmp)、释放函数(如free)等，这些都是容易造成漏洞的库函数。

设c(S)表示种子S从输入队列I中被选择的次数，f(S)表示种子S执行轨迹中脆弱库函数的个数，mb为种子S覆盖的分支中命中次数最少的分支，M(mb)为其命中次数。新的突变能量E的计算公式为(3):

![](images/Pasted%20image%2020230807162142.png)

其中α > 1是平衡原AFL能量E0与新EM-Fuzz能量E之间关系的常数，U是突变数的上界。它通过额外考虑内存敏感操作来改进AFLFast的指数能量分配策略，从而增加了测试脆弱代码区域的频率。

变异策略。EM-Fuzz借鉴FairFuzz的部分思想，结合我们提出的种子选择策略，对不同的种子采用不同的突变策略，其中限制突变策略和随机突变策略。算法1中的第7行首先判断所选种子S是否覆盖稀有分支。如果是这样，它将执行限制性突变，继续覆盖难以到达或内存敏感的分支。否则，它会执行随机突变，覆盖更大范围的新分支。设min_hit表示B中所有分支的最小命中数，随着新的测试用例的执行，每个分支的命中数也在不断增加，只有命中数为M(b)且满足式(4)的分支属于稀有分支rb。

![](images/Pasted%20image%2020230807162455.png)

其中rarity_cutoff是分隔普通分支和稀有分支的阈值，其实时值为$2^{log_2min\_hint}$。

如果选择的种子遇到稀有分支或记忆敏感分支，EM-Fuzz应用受限突变策略。它首先确定所选种子的哪些固定偏移值应保持不变。因此，EM-Fuzz通过尝试三种类型的操作(插入、删除和替换)对种子S的每个字节执行一轮突变。如果对固定偏移量的任何突变操作使新获得的测试用例不再击中与原始种子S相同的稀有分支，则这些固定偏移量属于不可变键字节，反之亦然。这些不可变的字节将在受限突变策略期间保持不变，EM-Fuzz根据分配的突变能量对种子的其他偏移量执行随机突变策略。对于未命中稀有分支或记忆敏感分支的选择种子，EM-Fuzz遵循AFL原有的随机突变策略，以增加发现新分支的概率。

4)流程执行:当执行每个测试用例时，EM-Fuzz确定它是否会导致固件崩溃或损坏。如果是这样，EM-Fuzz将这样的测试用例添加到缺陷队列D中，否则，它将度量是否命中了一个感兴趣的分支ib。以下两个条件之一使种子变得有趣:1)执行一个在之前的分支集B中未观察到的新分支。2)测试用例T执行分支ib的次数与输入队列I中之前任何测试用例t0的执行次数显著不同，表示为

![](images/Pasted%20image%2020230807163203.png)

其中HS(T',ib)表示分支ib被测试输入T执行的次数，|blog2(·)|是对数以2为底的floor函数。

## 4.实现与评估
EM-Fuzz的固件仿真器基于QEMU仿真平台增加了内存检查插桩[11]。它主要分三部分对原来的QEMU进行了增强，以实现动态运行时插桩。首先，当QEMU开始运行固件二进制文件时，它装载共享内存以记录分支覆盖信息和内存敏感操作的数量。然后，在执行每个翻译块之前，它会设置一个值来唯一标识每个翻译块，类似于AFL[5]。因此，在处理测试用例时，可以将两个相邻翻译块之间的转换关系和内存敏感操作信息更新到相应的共享内存中。最后，当在翻译块执行过程中遇到与内存相关的库函数调用时，它会包装原始库函数并设置相应的内存阴影，如第III-A2节所述。如果遇到到堆地址的内存写/读指令，它会回调嵌入在增强型QEMU中的十种内存检测器，以检测堆内存缺陷。

增强的QEMU仿真器与引导模糊测试模块一起工作。两者都由建立在AFL之上的同步控制器控制[5]。为了减少低吞吐量对固件模糊测试的影响，我们依靠内存检查插桩的重要反馈来获得闭源固件的内存敏感操作，并加强了原始AFL的三个功能:允许队列I中的每个种子按照跳种原则参与突变，根据分支命中数和内存敏感操作分配突变能量，并对选择的不同种子采用合适的突变策略。

我们评估EM-Fuzz是否能够解决测试真实世界嵌入式固件中的瓶颈，并有效地发现多种类型的漏洞。我们想回答以下三个研究问题:
- RQ1:分支发现的效率。EM-Fuzz在提高分支覆盖固件方面是否有效?
- RQ2:漏洞暴露的有效性。EM-Fuzz在暴露多种类型的漏洞方面是否有效?
- RQ3:内存检测器的性能。EM-Fuzz检测器对跨架构固件的性能如何?

### A.实验设置




## 7.结论
在本文中，我们提出了EM-Fuzz，一种通过内存检查来增强嵌入式固件漏洞发现能力的增强模糊测试技术。在动态检测的基础上，我们可以插入多个漏洞检查器来检测那些不会导致系统崩溃的漏洞，并收集敏感的内存操作来保护模糊器，从而生成更多高质量的测试用例，并对那些脆弱的代码区域进行详尽的内存检查。在实际嵌入式固件上的实验结果表明，EM-Fuzz不仅在漏洞发现数量上具有优势，而且在速度上也有提升。它已经暴露了23个安全漏洞，其中16个是新发现的以前未知的漏洞。在未来，我们计划通过支持更多架构和集成更多内存安全威胁检查器来扩展EM-Fuzz。