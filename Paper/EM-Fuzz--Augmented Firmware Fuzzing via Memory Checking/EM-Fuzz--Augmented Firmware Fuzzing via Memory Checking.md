IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems，2020；CCF A

ACM会议 EMSOFT

未开源

# 翻译
## 摘要
在新兴的应用场景中，嵌入式系统的互联性越来越强。这些应用程序中的许多都是安全关键型的，因此确保系统不受恶意攻击是重中之重。这项工作旨在检测漏洞，这些漏洞可能被攻击者利用来破坏嵌入式固件中的功能正确性，特别是由于缺乏源代码，这是具有挑战性的。

我们特别提出了EM-Fuzz，这是一种固件漏洞检测技术，它将模糊检测与实时内存检查紧密结合在一起。基于内存插桩的固件模糊测试，既可以通过传统的分支覆盖引导生成高质量的种子来探索难以到达的区域，也可以通过记录的内存敏感操作来持续尝试容易被攻击的敏感区域。更重要的是，该工具集成了实时内存检查器，以暴露内存漏洞，现有的没有源代码的fuzzers不支持这一点。在OpenSSL等实际嵌入式固件上的实验表明，EM-Fuzz显著提高了AFL和AFLFast等最先进的模糊测试工具的性能，覆盖率分别提高了93.98%和46.89%。此外，EM-Fuzz总共暴露了23个漏洞，平均每个漏洞约7小时。AFL和AFLFast总共发现了10个漏洞，平均每个漏洞花费的时间分别为13小时和10小时。在这23个漏洞中，有16个以前是未知的，并已报告给上游产品供应商，其中7个已在美国国家漏洞数据库中分配了唯一的CVE标识符。

索引术语-嵌入式固件，引导模糊测试，内存检查，漏洞。

## 1.引言
随着5G及以后技术的发展，嵌入式系统的连通性将在高度自动化车辆、家用机器人和工业4.0等新兴应用场景中变得越来越强。这些应用程序通常是安全关键型的，严格要求功能正确。因此，需要确保系统不受恶意代码注入、拒绝服务(DoS)等恶意攻击。然而现实是残酷的。Cui等[1]扫描了网络上约400万台嵌入式设备，发现其漏洞率为13.81%。这项工作的目标是嵌入式固件，漏洞检测是具有挑战性的，特别是由于缺乏源代码。

为了增强漏洞暴露能力，模糊测试成为近年来固件测试的研究热点[2]，[3]，[4]。Peach[2]是一个半自动的跨平台模糊测试框架，它根据人工构建的输入规范生成测试输入。SRFuzzer[3]是一个全自动模糊测试框架，用于对物理SOHO(小型办公室/家庭办公室)路由器的web服务器进行模糊测试。IoTFuzzer[4]使用移动应用程序的程序逻辑来生成探测目标固件的有意义的测试用例。尽管这些方法确保了报告漏洞的真实性，但它们属于不考虑执行反馈的黑盒模糊测试技术。因此，漏洞发现的效率并不令人满意。

灰盒模糊测试技术在带有源代码的程序上显示了有效的漏洞发现能力，因此首先想到的是使用QEMU进程仿真在嵌入式固件上执行类似的灰盒模糊测试。在没有嵌入式设备的情况下，QEMU仿真器确实成为模糊测试固件的首选，因为它具有相对完整的跨架构仿真能力，并且支持插桩来反馈分支覆盖信息。工具的二进制版本，如AFL[5]和AFLFast[6]，就是这种实现的代表，使用分支覆盖来连续地指导测试输入的生成。然而，我们在实践中发现，它们处理嵌入式固件的能力受到了极大的损害。有两个主要原因阻碍了这些工具在嵌入式场景中的使用。

一个原因是，与使用源代码模糊目标相比，使用QEMU仿真器模糊固件的时间成本更高，并且在单位时间内可以执行的测试用例数量(也称为吞吐量)要低3 - 5倍。虽然现有的fuzzers[5]，[6]可以应用于嵌入式固件，但它们面对低吞吐量的能力受到不适当的突变频率的限制。例如，AFL的盲突变策略难以使有意义的种子突变以有效到达难以到达的区域，从而导致被测目标的崩溃。

另一个原因是，当固件源代码不可用时，现有的fuzzers无法实现可以与各种杀毒程序(例如，AddressSanitizer, ThreadSanitizer)结合使用的源代码插桩来检查内存损坏。根据NVD近三年的统计，至少9.82%的被纳入漏洞与内存漏洞有关，如use-after-free、buffer overflow等。这使得固件中隐藏的内存漏洞不太可能被无助的fuzzer检测到。虽然MemCheck[7]、Dr. memory[8]等成熟的内存检查器通过二进制检测在二进制内存漏洞检查领域占据主导地位，但它们在固件上有较大的局限性。它们是可行的，前提是它们可以安装在与被测二进制文件相同的运行环境中(例如，相同的CPU架构)。在已经发布的固件中安装这些内存检查器是不切实际的，因此它们基本上不能与固件一起工作。此外，即使它们包含在固件中，在没有指导模糊测试的情况下执行任意测试用例可能会很耗时，并且根本不会报告漏洞。

> 原因：1.QEMU仿真模糊测试执行速度慢；2.源代码不可以无内存破坏检查辅助

在嵌入式场景中，虽然现有的灰盒模糊器和内存检查器可以发挥一定的功能，但它们是孤立的。将模糊测试和内存检查相结合，发挥各自的优势，我们面临以下挑战:

1)有效的内存插桩。增强型fuzzer需要必要的动态固件插桩，包括集成常见类型的内存检测器和以统一的方式记录内存敏感操作。

2)多架构支持。由于嵌入式设备应用场景的不同，固件CPU架构呈现出多样性。使用统一的运行环境来处理多种架构的固件模糊测试是非常受欢迎的。

3)覆盖指导和内存指导的协作。传统的分支引导信息不足以充分发挥组合能力。发现更深更广的程序路径并触发尽可能多的内存漏洞敏感操作是我们的理想目标。

为了解决上述挑战，我们提出了EM-Fuzz——一种增强的固件漏洞检测技术，通过将模糊测试与实时内存检查紧密集成。内存检查模块通过内存hook和库包装完成固件插桩任务，解决了挑战1.除了集成内存检测器以彻底识别内存漏洞外，它还监视并记录详细的内存敏感操作。EM-Fuzz中的模糊测试和内存检查都是基于QEMU仿真器实现的。因此，使用这个统一的运行环境来解决挑战2中的多体系结构支持，并在挑战1中提供内存检查工具的功能是合理的。增强的QEMU仿真器在仿真固件时，收集支路覆盖信息和内存敏感操作，共同指导模糊的突变方向，解决了挑战3。前者引导模糊器根据传统的分支频率选择种子，并采用随机和受限的突变策略对种子进行突变，保证了模糊的深度和广度;后者引导模糊器为执行记忆敏感操作的种子分配更多的突变时间，这增加了更频繁地覆盖脆弱区域的机会。

为了进行评估，我们考虑了现实世界的嵌入式固件程序，例如从变电站自动化系统(SAS)固件中提取的IEC61850协议，并将EM-Fuzz与两种最先进的fuzzers: AFL[5]和AFLFast[6]进行了比较。实验结果表明，EM-Fuzz显著提高了性能。特别是EM-Fuzz总共暴露了23个漏洞，而AFL和AFLFast分别暴露了7个和10个漏洞。结合AFL和AFLFast的结果，只发现了10个漏洞。EM-Fuzz发现的23个漏洞中，有16个是以前未知的，已经报告给上游产品供应商，其中7个已经分配了唯一的CVE标识符。在时间成本方面，EM-Fuzz发现一个漏洞平均需要7个小时，分别是AFL和AFLFast所需时间的54%和70%。

综上所述，本文做出了以下贡献:
- 据我们所知，EM-Fuzz是第一个集成了高效灰盒模糊和内存检查的工具，以增强嵌入式固件上的漏洞发现能力。虽然模糊测试在桌面应用程序上显示了令人印象深刻的性能，但对于没有源代码的嵌入式固件来说，这项工作是一个迈步。
- 我们通过动态运行时插桩将10种常见类型的内存检测器集成到EM-Fuzz中，这能够增强模糊测试，以发现现实世界固件中更多以前未知的漏洞。
- 我们提出了一种优化的嵌入式固件模糊测试策略。传统的分支和附加的内存敏感操作信息引导模糊探测难以到达的路径，并为脆弱的代码区域提供更多的内存耗尽检查机会。
- 我们将EM-Fuzz应用于真实的嵌入式固件，并发现了许多以前未知的漏洞。

论文组织:第二节给出了一个鼓舞人心的例子。第三部分详细介绍了EM-Fuzz的设计。第四节实现EM-Fuzz并报告实验结果。第五节指出今后的研究工作。第六部分为相关工作，第七部分对全文进行总结。

## 2.动机案例
为了展示EM-Fuzz如何通过内存检查工具提高模糊测试性能并暴露更多漏洞，我们浏览了清单1中所示的源自IEC61850嵌入式固件的修剪过的代码片段。块D中隐藏着两个漏洞。

![](images/Pasted%20image%2020230806114044.png)

### A.内存插桩的必要性
假设传统的fuzzer有机会探索难以到达的D区域，它仍然可能不会暴露任何内存漏洞。在没有任何内存检查器帮助的嵌入式场景中，fuzzers将认为块D运行正常，因为溢出和内存泄漏没有严重到使目标固件崩溃。如前所述，现有的内存检查器(如MemCheck [7]， Dr. memory[8])需要安装在与被测固件相同的环境中，并运行现有的测试输入来检测内存漏洞。现有的杀毒程序(例如AddressSanitizer, ThreadSanitizer)需要原始源代码来完成插桩，这在黑盒嵌入式固件的测试中是不切实际的。

详细地说，清单1的第14行和第15行分别为other和data变量请求8字节的堆内存。在32位操作系统环境中，每个变量实际上分配了16字节的内存，data的内存空间紧随other后。当data内存在第17行中首先被小于8字节的字符串填充，然后在第19行中other被大于16字节的字符串填充时，data内存的内容被other内存污染，因为data内存在other内存的后面。显然，应该报告导致数据完整性的缓冲区溢出问题。此外，第23行忘记释放第14行和第15行分配的内存。
如果不断调用函数parse_packet，则内存泄漏问题将使嵌入式设备耗尽资源。

在对跨架构固件进行模糊测试时，在统一的测试环境中对内存漏洞(如use-after-free、buffer overflow、memory leak)进行实时内存检查，可以显著提高漏洞检测性能。如果没有固件源代码，现有的模糊测试技术就不能很好地支持这个目标。

### B.有效模糊测试的必要性
在支持内存检查插桩后，检测第19行所示的缓冲区溢出漏洞需要测试输入满足两个条件:1)触发D块;2)为变量data和other包含适当的值。考虑到固件模糊测试的低测试输入吞吐量，理想的目标应该是对D块进行更深入的探索。

代码片段首先根据第4-5行中4-5和8-9的固定偏移量从数据包中获取魔术值和功能码。第8行确定2字节的魔术值是否等于0xB888，如果不等于，则意味着数据包无效，并在第26行中被过滤掉。由代表性的fuzzers，如AFL[5]， AFLFast[6]和FairFuzz[10]，生成的绝大多数测试用例都试图最大化传统的分支覆盖率。例如，AFL选择一个种子作为执行突变的首选项，如果它是任何观察到的分支中最快和最小的输入。FairFuzz对选择的种子执行限制突变策略，以增加到达相同的难以到达的分支的概率。然而，它的突变策略更倾向于探索更深的分支而不是更宽的分支，这导致了局部收敛问题。只考虑分支发生而忽略记录的内存敏感操作的权重可能会导致两个问题: 1)分支BD到达太晚;2)块C和块D的执行次数可能严重不平衡，其中D的触发频率较低。

EM-Fuzz的目标是通过记录的内存敏感操作指导的协作，尽早到达分支BD，并且执行D块的次数比执行C块的次数多。前者可以通过优化现有模糊器的选种策略和突变策略来实现。种子队列中的每个种子可以首先以与分支出现频率相反的概率进行选择。这个优化增加了种子命中分支BE的几率，而不是早期被丢弃，这有助于早期覆盖新的稀有分支BD。在突变阶段，如果选择的种子遇到了稀有分支和记忆敏感操作较多的分支，EM-Fuzz对种子采用限制性突变策略，以保持路径探索的深度。后者可以通过在突变阶段自适应更新种子突变能量来实现。如果种子碰到一个包含内存敏感操作的代码块(例如，malloc, free)，它会给种子更多的突变能量来增加这样的代码块被更多测试用例覆盖的次数。

## 3.EM-Fuzz设计
如图1所示，EM-Fuzz包含两个主要模块:内存检查插桩和引导模糊测试。通过紧密集成高效模糊检测和实时内存检查，分析人员能够快速定位固件中的严重安全威胁。内存检查插桩模块通过内存hook和库包装完成固件插桩任务，从而获得记录内存敏感操作的能力，以指导模糊测试和集成通用内存检测器来暴露内存损坏漏洞。模糊测试模块基于具有插桩功能的固件仿真器，以分支覆盖信息指导生成高质量的测试用例，探索难以到达的区域，以内存敏感操作指导触发易受攻击的脆弱区域。因此，增强固件模糊检测既保证了路径探索的深度和广度，又提高了漏洞暴露的能力。在整个模糊测试过程中，两个组件共享两个测试用例队列，包括输入队列I和缺陷队列D。

![](images/Pasted%20image%2020230806161748.png)

### A.内存检查插桩
内存检查插桩不仅负责反馈内存敏感操作以指导模糊测试，而且还负责集成内存检测器以彻底检查内存漏洞。它包含内存挂钩、库包装和内存检测器。

1)内存挂钩:EM-Fuzz中有两种主要类型的内存挂钩:指令挂钩和函数挂钩。指令挂钩将内存读和内存写指令拦截到堆地址。这用于确定是否存在内存漏洞。函数挂钩拦截与内存相关的库函数(例如，malloc, free)。其目的是在执行跟踪中记录对内存敏感的操作，并添加开场白和尾声动作。

对于指令挂钩，EM-Fuzz只挂钩涉及堆内存访问的指令。它的目的是获取堆内存地址的标记状态，以便内存检测器工作。因此，我们必须准确地将堆内存空间与整个虚拟内存空间区分开来。当EM-Fuzz将固件加载到模拟器中时，它将堆底部地址初始化为brk变量，表示为heapBottom = brk。每当分配新的堆内存空间时，brk变量的值就会增长，从而成为新的堆顶地址。EM-Fuzz只挂钩内存地址访问在heapBottom和brk范围内的指令。

对于函数挂钩，EM-Fuzz直接计算与内存操作相关的库函数的绝对虚拟内存地址。当模拟器执行main函数时，库函数__libc_start_main已经运行，并且它的起始地址存储在进程.got.plt节中。我们可以从libc.so库文件中获得__libc_start_main函数的偏移值。间接地，可以根据已知库函数的起始地址和偏移值计算出与内存相关的库函数的起始地址。没有直接从.got.plt中获得这些函数的起始地址的原因是其他库函数(例如，printf)也可以通过相同库文件中的偏移量调用这些函数，此时由于延迟绑定机制与内存相关的函数可能尚未加载到.got.PLT表。

2)库包装:EM-Fuzz的主要功能之一是支持固件的堆内存漏洞检测。通过修改原始的与内存相关的库函数，我们可以实现需要监视整个堆内存状态的内存检测器。EM-Fuzz通过库包装技术[8]实现了这一目标，该技术保留了原始堆布局。

![](images/Pasted%20image%2020230807153954.png)

我们实现库包装，为每个与内存相关的库函数添加序言和尾声。插入的序言优先于执行与内存相关的库函数，后者修改函数参数并为不同的内存区域分配适当的内存阴影状态(详见第III-A3节)。epilogue在标准库函数返回之前执行，修改相应的返回值。对于大小为P的堆内存，根据图2(a)中的用户代码的请求，序段将虚拟内存重新布局为图2(b)所示的新内存大小Q。用户代码(如malloc)请求的内存大小P和实际分配的内存大小Q满足以下等式:

![](images/Pasted%20image%2020230807154632.png)

举个例子，如果用户使用malloc(5)请求5个字节的堆内存，序言的存在会导致实际分配40个字节，其中16个字节是两个红区(默认m = 8)， 16个字节是辅助填充，3个字节是系统填充，5个字节可供用户使用。假设分配的40字节的起始地址是0x804b008, epilogue在malloc返回之前将返回地址设置为0x804b010。

3)内存检测器:内存检测器必须跟踪内存使用状态以检测内存漏洞。EM-Fuzz使用内存阴影来标记每个堆内存字节的状态。在一定时间内，每个字节的内存阴影只能是以下四项中的一项:
- unaddressable::固件内的程序不允许访问的非法堆内存。
- uninitialized::已分配但尚未写入的可寻址堆内存。
- defined:已分配并已写入的可寻址堆内存。
- readable:可寻址堆内存，仅在字符串处理库函数中可读。

图2(b)和图2(c)说明了不同堆内存区域与内存阴影之间的对应关系。不可寻址内存区域不仅包括红区和系统填充，还包括其他未分配的内存地址。满足用户代码请求大小的内存区域可以是未初始化的，也可以是已定义的，这取决于用户代码是否给它们赋值。辅助填充区域被标记为可读，仅在字符串处理库函数中可用。

![](images/Pasted%20image%2020230807155436.png)

表1列出了EM-Fuzz支持的10种常见的堆内存漏洞类型，以供检查。每种类型的漏洞对应于EM-Fuzz中的一个内存检测器，如第1列所示。第2栏解释了EM-Fuzz的简单实现原则。例如，缓冲区溢出意味着将数据写入超出缓冲区边界的相邻内存位置。EM-Fuzz通过确定指令是否将数据写入系统填充、辅助填充和标记为不可寻址或可读状态的右红色区域来检测此行为。内存泄漏检测器有点特殊，它挂钩退出系统调用，并计算不在不可寻址状态的内存字节。如果没有可读状态，在字符串处理函数中从堆内存中读取数据通常伴随着缓冲区过读误报。以strlen函数为例，为了提高效率，它可能不会逐个字节地从堆内存中读取字符，并确定是否存在终止符' \0 '。strlen函数的不同实现版本可以一次读取一个字、双字甚至16字节(使用SSE指令集)，从前到后查找终止符并返回字符串长度。为了消除这种类型的误报，我们使用标记为“可读”的辅助填充来过滤掉字符串处理库函数中发生的缓冲区过读。
### B.引导模糊测试
算法1给出了附加内存敏感操作引导模糊的总体过程。第1-17行是主要的伪代码实现，它将持续执行，直到达到超时或故意终止模糊测试，其中对现有模糊测试的改进用灰框特别标记。优化的目的是更容易地探索难以到达的深度路径，而不会失去路径探索的广度，并为脆弱的代码区域提供更多的机会进行耗尽内存检查。下面描述了每个步骤的细节。

![](images/Pasted%20image%2020230807160254.png)

1)模糊控制器(Fuzzing Controller):作为整个模糊过程的基础，模糊控制器在执行突变阶段衍生的每个测试用例后接收反馈，包括分支覆盖和内存敏感操作。它跟踪已发现的每个分支，并记录哪些测试用例覆盖了该分支。同时，它负责更新用于动态分离公共分支和稀有分支的全局阈值。它还记录了哪些内存敏感操作(例如，malloc, free)包含在每个测试用例的执行跟踪中。这些信息为后续的种子选择、能量分配和种子突变提供了充分的支持。







## 7.结论
在本文中，我们提出了EM-Fuzz，一种通过内存检查来增强嵌入式固件漏洞发现能力的增强模糊测试技术。在动态检测的基础上，我们可以插入多个漏洞检查器来检测那些不会导致系统崩溃的漏洞，并收集敏感的内存操作来保护模糊器，从而生成更多高质量的测试用例，并对那些脆弱的代码区域进行详尽的内存检查。在实际嵌入式固件上的实验结果表明，EM-Fuzz不仅在漏洞发现数量上具有优势，而且在速度上也有提升。它已经暴露了23个安全漏洞，其中16个是新发现的以前未知的漏洞。在未来，我们计划通过支持更多架构和集成更多内存安全威胁检查器来扩展EM-Fuzz。