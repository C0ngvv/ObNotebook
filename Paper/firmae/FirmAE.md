# FirmAE论文
论文题目：FirmAE: Towards Large-Scale Emulation of IoT Firmware for Dynamic Analysis
作者：Mingeun Kim, Dongkwan Kim, Eunsoo Kim, Suryeon Kim, Yeongjin Jang, and Yongdae Kim
时间：2020

## 摘要
评估嵌入式物联网设备安全性的一种方法是对其固件大规模应用动态分析，如模糊测试。为此，现有的方法旨在提供模拟真实硬件/外设行为的仿真环境。但在实践中，这种方法只能模拟固件映像的一小部分。例如，最先进的工具Firmadyne只能运行我们从排名前八的制造商收集的1,124张无线路由器/ ip摄像头图像中的183张(16.28%)。如此低的模拟成功率是由真实的和模拟的固件执行环境不一致造成的。
在本研究中，我们分析了大规模数据集中的仿真失败案例，以找出低仿真率的原因。我们发现，尽管存在不同的根本原因，但简单的启发式往往可以避免广泛的失败情况，从而显著提高仿真成功率。基于这些发现，我们提出了一种技术——仲裁模拟，并将几个启发式技术系统化作为仲裁技术来解决这些故障。我们的自动化原型FirmAE成功运行了1124个固件映像中的892个(79.36%)，包括web服务器，这比Firmadyne运行的映像要多得多(约4.8倍)。最后，通过对模拟镜像应用动态测试技术，FirmAE可以检查320个已知漏洞(比Firmadyne多306个)，并在23个设备中发现12个新的0 day漏洞。
关键字：固件，嵌入式设备，模拟，动态分析

## 1.引言
到2025年，活跃的物联网(IoT)设备的数量预计将达到342亿。由于大量物联网设备连接到互联网，它们面临着网络威胁。例如，无线路由器、IP摄像头等基于linux的物联网设备经常成为大规模攻击的目标。这些设备中发现了多个后门，恶意软件，如Mirai和Satori，感染了数百万个这样的设备。

为了解决如此众多物联网设备的安全问题，研究人员一直专注于大规模分析这些设备的固件。具体地说，一系列的研究采用了一种方法，即在具有虚拟硬件的模拟环境中运行设备固件，然后对固件应用动态分析。使用这种方法，不仅可以在不获取硬件的情况下动态分析固件，还可以利用云基础设施来扩展安全分析。其中，Firmadyne是目前最先进的固件仿真框架，旨在通过提供全系统仿真环境，为一般物联网设备实现大规模仿真。

**问题：真实环境和虚拟环境的差异。**
这种方法在实践中并不是灵丹妙药，因为在全系统仿真环境中运行固件通常会失败，原因是真实环境和虚拟仿真环境之间存在不一致。仿真环境中的任何差异都可能导致固件执行到意想不到的状态，从而导致仿真和动态安全分析失败。解决这种仿真差异具有挑战性，因为这种不一致源于物联网设备硬件和配置的广泛多样性。特别是，每一个物联网设备都配备了来自大量制造商的特定硬件设备。此外，固件通常依赖于配置向量，例如NVRAM中的数据，而模拟环境可能会丢失此类数据，因为这些数据只在硬件中可用。这种复杂的情况与Firmadyne的仿真环境不匹配，它的仿真器QEMU只支持少数通用设备和配置，如果不对每个设备和配置进行大量的仿真，问题将永远不会消失。

为了在实践中看到这个问题的影响，我们从排名前八的供应商获得了1124个无线路由器和IP摄像头固件图像，并使用Firmadyne运行它们。结果是令人担忧的，因为它只能模拟其中的183个，大部分固件映像(83.72%)没有进行分析。如此低的模拟成功率意味着，尽管Firmadyne通过提供固件的全系统模拟环境而被设计为通用的，但这种方法在实践中不起作用，需要许多手工工作来解决模拟环境中的不一致。

**激励的例子。** 接下来，我们将展示如何手动处理不一致，作为激励示例。首先，我们运行D-Link DIR-505L的固件，使用Firmadyne对CVE-2014-3936进行测试。由于该漏洞是在固件上运行的web服务中基于堆栈的缓冲区溢出，因此利用该漏洞需要通过模拟环境的网络接口发送HTTP请求。然而，当我们在Firmadyne上运行固件时，尽管web服务器正常运行，但我们无法连接到web服务。从我们的分析中，我们发现固件中的网络配置与模拟环境不匹配，在我们强制配置网络之后，我们能够触发漏洞。其次，我们运行NETGEAR R6250的固件，使用Firmadyne对CVE-2017-5521进行测试。在本例中，模拟失败，引导过程中出现kernel panic。在我们稍微修改了引导和内核相关配置以匹配虚拟环境之后，我们就能够运行固件并触发漏洞了。

**观察和目标。** 从这两个示例中，我们观察到配置或设备设置中的轻微更改(这很容易应用)可能会让固件模拟运行，而不会遇到模拟差异问题(这很难处理)。在这方面，我们认为Firmadyne失去了很多模拟和分析IoT固件镜像的机会，不是因为模拟中的基本问题，而是因为设备设置失败，尽管这些问题可以很容易处理。为了解决这个问题，我们的目标是通过分析许多模拟失败的案例来系统化这种启发，最终，与Firmadyne相比，我们的目标是增加固件模拟成功的机会。

**我们的方法。** 我们通过调查许多模拟失败案例作为我们的第一步来实现这个目标。为了进行调查，我们从排名前八的供应商那里收集了1124个固件映像：1079台无线路由器和45台IP摄像机。对于模拟，我们特别关注模拟无线路由器和IP摄像机的web服务，这是因为web界面是远程攻击者可以与之交互的部分，在这些服务中已经发现了许多关键的漏洞。通过使用Firmadyne，我们调查了437个模拟失败案例(在AnalysisSet中的527个固件映像中)，发现大多数案例都属于以下五类问题:
1)与引导相关的问题，例如引导顺序不正确或缺少文件
2)网络相关问题，如网络接口不匹配或配置不当
3)与非易失性RAM (NVRAM)相关的问题，如缺少库函数或定制的格式
4)与内核相关的问题，例如不支持的硬件或功能
5)小问题，如不支持的命令或计时问题

我们的调查结果表明，每个类别中的失败案例都可以通过应用简单的启发式来解决，尽管它们源自不同的根本原因。例如，227个镜像未能设置它们的网络接口，即使它们的web服务器正常运行。虽然导致失败的根本原因可能各不相同，例如可用网口数量的差异，网络设备的名称等。强制设置在模拟环境中工作的网络配置的启发式方法可以解决这个问题并支持动态分析。

基于这一观察，我们将这些启发式作为一种技术系统化，称为仲裁模拟，并开发了几种仲裁技术来绕过失败案例。仲裁模拟不是严格遵循固件的执行行为，而是在遵循原始行为或注入适当的干预(即有意操作)之间进行仲裁。因此，它可能会轻微地改变固件的原始行为。然而，我们的目标不是构建一个与物理设备相同的环境，而是创建一个有利于动态分析的环境。事实上，我们的方法可以模拟许多以前的方法无法模拟的固件映像，并有效地帮助找到真正的漏洞。

在设计了几个仲裁之后，我们将自动化和并行化整个固件模拟过程。在测试1124个固件镜像的4小时内，我们的原型FirmAE成功模拟了892个(79.36%)镜像，这是Firmadyne的4倍多。然后，我们在仿真镜像上运行先前已知的漏洞，以验证仲裁仿真对动态分析是否有用。结果，在FirmAE上成功模拟了320个已知漏洞，比Firmadyne多306个成功案例。我们还在FirmAE上建立了一个简单的模糊器，在95个最新的设备中发现了23个独特的漏洞，并负责任地向供应商报告了它们。

综上所述，本研究的贡献如下:
- 我们对437个固件仿真失败案例进行了实证研究，并将失败处理启发式方法系统化。
- 我们提出了仲裁仿真来将这些启发式应用到仿真环境中。我们的原型FirmAE的模拟成功率(892比183)远远高于最先进的框架Firmadyne。
- 通过重新发现比Firmadyne多306个已知漏洞，我们确认仲裁仿真是有效的。此外，通过一个简单的模糊器，FirmAE可以在95个最新设备上发现23个新的漏洞，其中12个是0天。
- 我们发布源代码以鼓励未来的研究。

## 2.背景
在本节中，我们将通过引用以前的研究来解释如何分析嵌入式设备，并介绍作为我们方法基础的最先进的工具。

### 2.1 嵌入式设备分析过程
要分析嵌入式设备，可以在有/没有物理设备的情况下获取和分析目标固件。

**固件收集和解包。** 通常，固件可以从供应商的网站、ftp服务器或第三方档案中获取。这可以手动完成，也可以使用像Spider这样的网络爬虫。固件也可以直接从设备的闪存转储，尽管这需要一个物理设备。

然后将固件映像解压缩以供稍后分析。一个镜像可以包含多个内容，例如，基于linux的固件可能具有引导加载程序、内核和文件系统。该映像通常以各种方式进行压缩，例如LZMA、ZIP或Gzip，以节省存储空间。为了解压映像，通常使用Binwalk、Firmware-Mod-Kit或FRAK等工具。在给定的图像中，这些工具扫描各种文件头的预定义签名。当签名匹配时，他们从图像中提取文件，并继续扫描到最后。加密或自定义图像也存在，这时就无法使用签名匹配，分析它们超出了本研究的范围。

**使用物理设备进行分析。** 解包后的固件可以用真实设备进行分析。Zaddach等人和Marius等人将进程执行和外围设备访问中继到真实设备，并使用JTAG接口部分模拟目标代码。类似地，Kammerstetter等人使用真实设备开发了一个代理环境，并将字符设备访问转发给它们。Cui等和Kumar等对连接到公共互联网的嵌入式设备进行了定量研究。

**分析w/o设备。** 另一组研究集中在分析没有物理设备的固件以扩大分析。研究人员在固件上采用静态方法，然而，由于缺乏运行时信息，它们经常产生大量的误报。尽管如此，Costin等人显示了具有容易破解的密码或后门字符串的脆弱设备的统计数据。Shoshitaishvili等人使用符号执行发现了身份验证绕过漏洞。

相比之下，动态分析可以识别漏洞而不会出现误报，因为它直接运行目标程序。然而，执行动态分析并不是一项简单的任务，因为必须模拟设备固件。最近的研究侧重于固件仿真，以克服获取真实硬件的困难，我们将在下一小节进一步详细描述这些研究。

### 2.2 基于模拟的分析
固件仿真引起了人们的注意，因为它不需要真实的设备，并且为动态分析提供了有用的接口。进行模拟的系统被表示为主机系统，被模拟的系统被称为客户系统。通常，模拟有两个级别:用户级和系统级。

**用户级仿真。** 用户级模拟只模拟固件内部的目标程序，并充分利用主机系统。一个例子是模拟web界面。web界面是嵌入式设备中用于设备管理或维护的一种代表性服务。它提供多种静态内容，如HTML，或CGI程序生成的动态内容。尽管静态内容可以用宿主环境一起提供，但动态内容可能不能。这是因为它们可能与主机系统发生冲突，或者依赖于主机系统中不存在的自定义库和设备驱动程序。

**系统级仿真。** 系统级模拟完全模拟来宾系统，包括内核。因为它提供了单独的执行环境，所以还可以模拟内核和设备驱动程序中的各种特性。然而，固件模拟是极其困难的，因为需要考虑供应商特定的硬件问题或者内存映射外设。如果不处理它们，模拟固件中的程序经常会崩溃。

因此，最近的研究一直在努力通过创建与真实设备尽可能相似的仿真环境解决这些问题。流行的仿真器，如QEMU，一直支持更多的硬件类型，包括它们的外围设备。Costin等人提出了一个可扩展的动态分析框架，以及对各种嵌入式web界面的几个案例研究。Chen等人仿真了非易失性RAM (NVRAM)，它在仿真固件中存储了程序的各种配置值。Gustafson等人对外围通信中的内存映射I/O (MMIO)操作进行了建模。Feng等试图用机器学习解决同样的问题。最近，Clements等人提出了硬件与固件的解耦。

**分析。** 在模拟之后，可以使用之前已知的PoC代码或模糊器来检查漏洞。TriforceAFL是一个针对QEMU图像的流行模糊器，利用American fuzzy lop (AFL)。它也被Hu等人采用，在他们的后续研究中，Zheng等人提出了一种用于动态分析的优化仿真方法，该方法在系统级和用户级仿真之间切换上下文。

### 2.3 固件仿真中的挑战
基于仿真的分析具有优势，然而，在模拟来自不同供应商的固件映像时存在许多挑战，这源于非标准化的开发过程以及模拟环境与物理环境之间的差异。例如，库、设备驱动程序，甚至设备中的内核都因供应商而不同，除非对这些进行了适当的模拟，否则无法执行内部程序。

正如先前研究所指出的，访问硬件接口的设备，如LED传感器或摄像头，具有更多的多样性。主设备和它的外围设备之间的通信通常使用内存映射IO (MMIO)操作，使用预定义的内存地址。然而，这些地址的范围在不同的设备上有很大的不同。因此，很难将这种方法扩展到各种设备上。Chen等试图大规模模拟一种这样的硬件，NVRAM。Muench等强调了在进行动态分析以识别内存损坏漏洞时特定于设备的挑战。

解决这些挑战可能是不可行的，除非功能像在物理设备中那样完美地实现。然而，通过调查仿真失败案例并解决发现的问题，有助于逐步提高仿真率，并通过动态分析提高物联网生态系统的安全性。因此，我们采用最新的仿真框架Firmadyne，并研究失败案例。

### 2.4 Firmadyne框架
Firmadyne是一个最先进的固件仿真框架，最初设计用于大规模分析。大量的研究将其用于动态分析。我们还利用Firmadyne进行故障调查。

在解包一个固件映像之后，Firmadyne用一个定制的Linux内核和库来模拟它，这些都是预先构建的来支持各种硬件特性，如NVRAM。对于模拟，Firmadyne模拟目标镜像两次:第一次模拟记录有用的信息，而第二次利用记录的信息。因此，定制的内核包含一个驱动程序，它连接主要的系统调用来记录有用的信息。例如，它们钩子inet_ioctl()和inet_bind()来获取模拟固件中使用的网络接口的名称和IP地址。Firmadyne的自定义库还解决了硬件问题。例如，库libnvram根据硬编码的默认值存储并返回NVRAM值。

尽管Firmadyne很有前途，但其网络可达性和web服务可用性的模拟率相当低，分别为29.4%和16.3%。为此，我们仔细研究了故障案例，并提出了解决它们的技术。

## 3.设计
### 3.1 目标和范围
**目标。** 我们的目标是成功模拟嵌入式设备的固件映像，特别是运行它们的web服务，因为这类设备的web界面是远程攻击者的关键目标。我们的目标不是解决仿真环境中的所有差异，相反，我们的目标是动态测试的简洁模拟，我们的模拟目标可以用以下内容来说明:
1）引导而没有任何kernel panic
2）主机的网络可达性
3）用于动态分析的Web服务可用性
我们的目标是保持这些内容，因为它们是运行web服务的最低要求，而不会在固件模拟中出现问题。因此，我们通过检查目标固件的网络可达性和web服务可用性来检查模拟成功率。

**范围。** 在各种嵌入式设备中，我们选择无线路由器和IP摄像头作为我们的分析目标，因为它们在我们的日常生活中存在，并且经常成为攻击的目标。事实上，许多僵尸网络针对他们发起大规模的DDoS攻击。请注意，其他具有相似特征的嵌入式设备也可以用我们的方法解决。

### 3.2仲裁模拟
为了实现这个目标，我们提出了一种技术，称为仲裁仿真。尽管以前的方法都努力确保目标固件与物理设备操作相同，这是一个困难的目标，但仲裁仿真并不完全遵循目标固件的原始执行过程。仲裁模拟背后的关键思想是确保高级行为足以对内部程序执行动态分析，这是相对容易做到的，而不是查找和修复模拟失败的确切根源。熟练的分析人员可以根据他们的目标和仿真目标对这里提到的高级行为进行建模。在本研究中，我们使用§3.1中定义的模型。

仲裁仿真的一个关键特性是它使用干预。干预表示有意添加的操作，它可能不同于物理设备的行为。这个操作使得绕过未处理的问题成为可能，假设这些问题不会强烈影响仿真固件中目标程序的行为。在遵循固件原样和应用干预之间仲裁的程序称为仲裁。可以根据需要以各种方式实现干预，并且可以将干预注入到模拟过程的适当步骤中，即仲裁点。通过分析给定高级行为模型的违规案例，可以找到合适的仲裁点，然后，在这些仲裁点中注入干预。由于干预关注于高级行为，因此从一小组固件映像中获得的内容可以广泛应用于遭受类似故障情况的其他固件映像，尽管它们的根本原因不同。

我们的干预利用了基于linux的固件的抽象设计。我们对数据集进行了初步研究，发现适当的干预可以帮助模拟器绕过许多未解决的问题。例如，当网络设置过程由于未知的外设访问或NVRAM支持不足而停止时，强制配置固定网络设置的干预可以解决问题，而不管根本原因是什么。尽管仲裁模拟可能违反了全系统模拟的主要概念，我们假设由干预引入的小差异只对目标程序的行为有轻微的影响。事实上，通过从1124个映像中成功地在892个固件映像中运行模拟web服务，我们支持了这一假设，并且通过进行动态安全分析，我们发现了12个0 day漏洞。

### 3.3 FIRMAE
我们基于Firmadyne实现了仲裁仿真的原型FirmAE。FirmAE在预构建的定制Linux内核和库上模拟类似于Firmadyne的固件映像。它还对目标映像进行两次仿真，以收集各种系统日志并利用这些信息进行进一步的仿真。我们将前一个模拟步骤称为预模拟，将后一个步骤称为最终模拟。在FirmAE中应用的仲裁可以分为五种，这是由我们在AnalysisSet上的失败案例调查得出的。我们在§4中描述了每个仲裁的细节，并将仿真结果与§5.1中Firmadyne的结果进行了比较。我们在FirmAE上构建了额外的动态分析接口(§5.3)，并在§5.4中描述了分析结果。

**自动化。** 对于大规模的分析，FirmAE需要完全自动化。当然，Firmadyne的许多步骤都是自动化的，然而，它仍然需要一些用户交互。例如，用户必须首先用特定的选项提取目标固件的文件系统，然后，他们评估文件系统是否成功提取并检索体系结构信息。随后，他们为QEMU制作一个固件映像并在预模拟中收集信息。最后，他们运行一个脚本进行最终模拟并执行动态分析。我们自动化了所有这些交互，并为网络可达性和web服务可用性添加了一个自动化的评估过程。为此，我们在FirmAE中构建了一个模块，它定期运行ping和curl命令。

**并行化。** 我们还利用Docker的容器化，通过并行仿真有效地评估大量固件映像。每个固件映像在每个容器中独立模拟，每个容器配备了所有所需的包和依赖项，这样就可以快速可靠地模拟目标映像。FirmAE通过运行多个容器实例来并行模拟固件。

通过容器化，我们可以利用抽象主机和客户系统之间的网络连接的优势。FirmAE使用QEMU进行模拟，它在主机系统中创建一个额外的网络接口TAP，此接口链接到其中一个客户网络接口。因此，每个仿真固件都应该有一个独立的TAP接口，在主机系统中具有唯一的IP地址，否则将发生网络冲突。集装箱化隔离了每个容器的网络环境。因此，即使在并行模拟中，也可以将来自主机系统的信息包正确地路由到客户机。我们还将检查器和分析引擎放在每个容器中。

### 3.4 实验装置
**数据集。** 我们的数据集包括在无线家庭路由器市场上排名前八的供应商，我们从供应商的网站上收集了1306个固件映像，并通过使用Binwalk解压这些映像来提取文件系统，如§2.1所述。然后，我们通过验证每个图像的操作系统是否具有ARM小端(ARMel)、MIPS小端(MIPSel)和MIPS大端(mipsb)三种体系结构中的一种来进行过滤。这些架构占据了我们初始收藏的97%以上。我们用同样的方式处理了IP摄像头固件。

我们最后的数据集总共包括1124个固件图像，其中1079个是无线路由器，45个是IP摄像头。我们将它们分为三个数据集:AnalysisSet、LatestSet和CamSet。AnalysisSet由来自3个供应商的526个过期映像组成，而LatestSet和CamSet只包含截至2018年12月的最新固件映像。LatestSet有来自8个供应商的553张最新图片，包括AnalysisSet覆盖的供应商，CamSet包括来自3个供应商的45张最新图片。因此，AnalysisSet可能在每个设备中包含多个固件版本，而LatestSet和CamSet在每个设备中只有一个映像。数据集之间没有交集，也就是说，它们不共享任何相同的图像。我们使用AnalysisSet来分析仿真失败案例。通过分析它们，我们发现了几个仲裁点，可以帮助提高仿真率。我们在FirmAE中应用了这些仲裁，并用LatestSet和CamSet对其进行了评估。

**环境。** 我们所有的实验都是在一台配有4个Inter Xeon E7-8867v4 2.40 GHz CPUs，896 GB
DDR4 RAM, and 4 TB SSD的服务器上进行的。我们在服务器上安装了带有PostgreSQL v9.5.14和Docker v18.09.4的Ubuntu 16.04。

## 4.失败案例的仲裁
仲裁仿真的关键是描述能够帮助仿真者绕过故障的仲裁点。因此，我们首先基于高级行为模型在AnalysisSet上分析故障案例。对于大规模的分析，我们应用了FirmAE的自动化和并行化，没有任何仲裁，因此仿真部分与Firmadyne相同。值得注意的是，web服务器只有16.9%的图像被模拟(§5.1)。为了做一个简洁的解释，我们根据仲裁点对失败案例进行了分类:引导(4.1)、网络(4.2)、NVRAM(4.3)、内核(4.4)和其他(4.5)。在本节中，我们将详细解释它们。

### 4.1 引导仲裁
我们在引导过程的早期阶段遇到了第一个问题，这使模拟失败并导致kernel panic。

**不当的引导序列** 引导顺序不正确的主要原因是用于系统初始化的程序没有正确执行。通常，大多数系统都需要在引导过程中进行初始化。在Linux内核中，初始化通常由一个名为init的程序执行，内核试图通过检查预定义的路径(例如/sbin/init、/etc/init和/bin/init)来查找该程序。然而，一些固件映像有用于初始化程序的自定义路径，这样内核就无法执行程序并崩溃。

这种故障经常发生在NETGEAR固件映像中。在分析它们之后，我们发现它们使用的名称是preinit，这是一个开源嵌入式设备项目OpenWrt经常使用的名称，并且我们验证了它们确实是在此基础上实现的。我们还发现一些TP-Link映像也使用了preinit。为了解决这个问题，Firmadyne构建了一个脚本，该脚本搜索并执行一个硬编码的文件列表，这些文件在初始化程序时经常被访问。但是，这些候选方案还不足以说明初始化程序的各种路径。

我们提出了另一种利用来自目标固件内核的信息的方法。具体地说，我们在引导过程的开始创建了一个干预，它从映像的内核中提取有用的信息。具体来说，我们利用内核的命令行字符串，该字符串用于引导过程中内核的默认配置。注意，这样的字符串是在开发阶段预先定义的，因此它自然嵌入到内核映像中。注意，这样的字符串是在开发阶段预先定义的，因此它自然嵌入到内核映像中。例如，从NETGEAR固件中的一个内核映像中，我们可以得到一个console=ttyS0,115200 root=31:08 rootfstype=squashfs init=/etc/preinit的字符串。我们可以识别出初始化程序路径为/etc/preinit，控制台类型为ttyS0，波特率为115200，根文件系统类型为squashfs。通过使用从原始内核获得的信息配置仿真环境，可以正确地初始化客户机系统而不会失败，即使初始化程序有不寻常的路径。如果我们无法提取任何信息，我们将从提取的文件系统中找到初始化程序，例如preinit或preinitMT。

**丢失文件系统结构。** 其他失败情况是由于缺少文件或目录而发生的。当内部程序访问这些路径时，它们将崩溃，模拟将停止。Firmadyne试图通过在自定义引导脚本的开头创建并挂载硬编码路径(如proc、dev、sys或root)来解决这个问题。一些硬编码的路径确实有效，例如，设置/etc/TZ或/etc/hosts可以帮助解决一些此类问题。然而，这种方法不能解释不同的情况。此外，由于它在固件初始化自己之前强制创建文件和目录，它会与在同一路径上创建和挂载其他文件或目录的内部程序发生冲突。

我们通过插入一个干预来仲裁这个问题，这个干预类似于前面的例子，但是从文件系统而不是内核检索信息。在模拟给定图像之前，我们从其文件系统中的可执行二进制文件中提取所有字符串。然后，我们对它们进行筛选，以获得极有可能指示路径的字符串，并根据这些路径准备文件结构。特别地，我们选择了以一般Unix路径开头的字符串，例如/var或/etc。

### 4.2 网络仲裁
在完成引导过程之后，应该配置网络，以便主机系统能够与客户机系统通信，并最终执行动态分析。对于网络通信，QEMU要求主机创建一个额外的网络接口TAP。这个TAP接口连接到客户系统中的一个网络接口，然后，主机和客户机通过它进行交流。

然而，正确配置TAP接口并非易事，因为应该使用与目标网络接口类型对应的特定选项来设置TAP接口。这种网络接口类型可以是以太网、无线局域网(WLAN)、网桥或虚拟局域网(VLAN)。由于在客户系统中静态区分接口类型并不容易，因此需要对目标镜像进行一次仿真。

Firmadyne对给定的图像进行两次模拟(§2.4)。在第一个模拟(即预模拟)中，Firmadyne通过钩取系统调用来收集内核日志。由于收集到的日志包括模拟过程中访问的网络接口的名称和IP地址，因此可以将它们用于最终模拟中的网络配置。然而，仍然有许多图像失败了。

**无效的IP别名处理。** 为一个网络接口分配多个IP地址被称为IP别名。它在路由器中很流行，因为它可以通过IP地址单独管理服务。在IP别名中，一个网络接口为自己创建多个实例，每个实例被分配一个唯一的IP地址。例如，网桥接口br0的IP地址为192.168.1.1，可以有IP别名169.254.39.3和1.1.1.1，分别分配给实例br0:0和br0:1。然后，br0链接到以太网接口eth0，到这里，br0可以被这些IP地址的任意一个进行访问。

与这种IP别名相关的失败案例经常在D-Link镜像中发现。经过调查，我们发现这是由于Firmadyne没有正确处理IP别名造成的。这个问题出现在主机系统配置Firmadyne网络过程。在预模拟步骤中，IP别名由内核记录，然后，Firmadyne解析日志并试图分配所有的记录的IP地址给对应的客户机接口。然后，它为这些IP地址添加静态路由规则，将它们链接到主机中的TAP接口。在这种情况下，在一个TAP接口上添加多条路由规则，会造成网络冲突。

基于记录的IP别名的信息，FirmAE通过让主机系统使用它的默认路由规则来进行仲裁。特别是，即使使用了IP别名，一旦客户机的网络接口连接到主机的TAP接口，所有数据包都会自动在主机和客户机之间路由。因此，这些情况不需要干预，这说明了在适当的位置进行干预的重要性。

**没有网络信息。** 一些固件映像在其内核日志中不包含任何关于可连接网络接口(如eth)的信息。这些映像只配置环回接口(lo)，不设置其他网络接口。由于缺乏可连接的网络接口，主机系统无法访问这些映像。此外，一些映像试图将其web服务器绑定到一个不存在的网络接口上，从而导致崩溃。

在分析这些情况后，我们发现一些映像使用动态主机配置协议(DHCP)从DHCP服务器检索IP地址，用于它们的wan接口。DHCP是在端点设备中设置网络接口的流行协议，因为它不需要任何用户交互。通常，无线路由器充当DHCP服务器本身，为其客户端所连接的LAN接口分配IP地址。然而，他们也可以从外部DHCP服务器获取一个IP地址连接到Internet，除非用户手动配置它。事实上，我们分析的镜像试图通过它们的Wan接口和主机系统的TAP接口之间的连接，用DHCP获取一个IP地址。但由于仿真环境中没有DHCP服务器，导致仿真固件获取IP地址和配置网口失败。此外，由于没有配置网络接口，无法安排将多个网络接口分组的网桥接口，从而绑定到这些网络接口的内部程序不能正常运行。

我们首先尝试用QEMU的内部DHCP服务器来解决这个问题，这样客户机的网络接口就可以从服务器获取IP地址。但是，即使设置了DHCP服务器，一些镜像仍然没有网络接口，这可能是由于外围设备支持不足造成的。如果在网络配置过程中任何程序访问这些外设，它将崩溃或运行异常，最终配置网络失败。

FirmAE通过强制使用默认设置配置网络的干预来仲裁这些情况。具体来说，我们设置一个以太网接口eth0，其IP地址为192.168.0.1。在以太网接口建立之后，它将与默认桥接接口br0链接（对于内核日志中包含桥接接口信息的映像）。这种简单的干预可以显著地帮助模拟web服务(§5.1)。

**ARM中的多个网络接口。** 要支持多个网络接口，必须选择一个适当的加载目标固件的机器。遵从先前研究中所采用的方法，我们选择了virt，这是QEMU支持的一种机器。这对一些固件镜像来说表现很好，然而，它不能模拟具有多个网络接口的ARM固件映像。Firmadyne试图通过准备固定数量(四个)的虚拟接口来解决这个多接口问题。它的基本假设是，接口的数量应该大于或等于从内核日志中提取出的接口名称的后缀，例如，如果记录了eth1，则很可能eth0也存在。然而，几乎所有的ARM图像仍然没有被模拟成功。

我们仔细调查了这些病例，但我们无法确定确切的原因。然而，我们可以通过强制只设置一个以太网接口的高级干预来解决这个故障。更具体地说，我们的干预强制设置一个以太网接口eth0，并避免设置其他接口。我们设置了一个网桥接口，在必要时将其连接到主机。通过这种干预，可以模拟很大一部分ARM固件映像。

**VLAN设置不足。** VLAN是路由器的一个典型特性，它提供了一个隔离的网络环境，在逻辑上对子网进行分组。VLAN接口与其他网络接口(如以太网或WLAN)具有不同的特性，因此必须为其设置额外的选项。为了支持VLAN，需要将TAP接口的类型设置为VLAN，并为其分配合适的VLAN id。

另一个故障发生在带有VLAN接口的固件映像中。在模拟这些映像时，即使以太网接口正确地配置了独立的IP地址，客户网络仍然不可访问。Firmadyne试图通过在设置主机TAP接口时运行命令来解决这个问题，但他们的配置不足以解决这个问题。特别是，VLAN应该被配置来对使用相同的VLAN id对主机和客户网络进行分组。然而，Firmadyne没有设置主机网络。FirmAE通过正确配置VLAN进行仲裁。

**iptables中的过滤规则。** 许多路由器都设置了防火墙，以防止未经授权的远程访问，否则，攻击者就可以访问管理接口。我们数据集中的一些固件映像通过使用iptables也实现了这个策略，因此，客户内核丢弃了所有来自主机的数据包。我们发现大多数这种情况发生在TP-Link中，即使主机和客户端网络配置正确，客户端也无法访问。

这并不代表模拟失败，因为设置iptables会模拟真实设备的原始行为。然而，这种过滤阻止了对其潜在漏洞和威胁的分析。显然，在分析过程中识别的漏洞可能无法被远程利用。然而，许多设备所有者或管理员错误地更改了这些规则，使设备公开可访问。

FirmAE通过检查客户系统中的过滤规则来进行仲裁，如果它们存在，则删除它们。这可以简单地通过刷新iptables中的所有策略并设置默认策略来接受所有传入的数据包来实现，然后，客户机网络可以从主机访问，并可以进行动态分析。

### 4.3 NVRAM仲裁
仿真与真实环境相似的外设是固件仿真中最具挑战性的部分之一(§2.3)。NVRAM本质上是一种闪存，是广泛用于嵌入式设备中存储配置数据的外设之一。嵌入式设备中的内部程序经常在其中存储/获取必要的信息。除非支持NVRAM，否则这些程序经常会崩溃。

Firmadyne实现了一个定制的NVRAM库来模拟NVRAM相关的函数。通过设置名为LD_PRELOAD的环境变量，可以预先加载这个自定义库以包含其他库。它拦截与NVRAM相关的函数，如nvram_get()和nvram_set()，并模拟一个没有物理访问的NVRAM。具体来说，当调用nvram_set()时，键值对存储在一个文件中，稍后在调用nvram_get()时提取它。对于这些在调用nvram_set()之前调用nvram_get()情况， Firmadyne使用给定固件中的默认文件初始化键-值对，这些默认文件通常用于设备的恢复出厂设置功能。Firmadyne有一个默认文件的硬编码路径列表，用于提取键-值对。然而，我们数据集中的许多固件映像仍然没有被模拟。

**支持自定义NVRAM默认文件。** 我们发现了许多情况，默认文件的路径取决于每个设备，甚至它们的键-值对具有不同的模式。例如，在一些D-Link映像中，默认文件位于/etc/nvram.default或/mnt/nvram_rt.default。此外，一些NETGEAR映像中的默认文件可以在/usr/etc/default.找到。这些文件中的键-值对用不同的分隔符分隔，例如回车符或NULL字节。有些默认文件甚至具有特定于供应商的格式，如OBJ或ELM。

为了开发可扩展的方法，FirmAE在预模拟期间准备仲裁。具体地说，FirmAE记录在预模拟期间使用nvram_get()和nvram_set()函数访问的所有键值对。然后，它扫描目标固件的文件系统，并搜索包含记录的键名(值是未知的)的多个实例的文件。irmAE从文件中提取键值对(如果存在的话)，并在最终的模拟中利用它们。

**没有NVRAM默认文件。** 不幸的是，不是所有固件映像都有默认的NVRAM文件。即使存在默认文件，它也可能不包含请求的键-值对。解决这个问题的一个简单方法是为未初始化的键返回NULL值，就像Firmadyne所做的那样。然而，我们观察到很多情况下，在nvram_get()返回NULL后，由于分段错误而崩溃。通过对崩溃的程序进行逆向工程，我们惊奇地发现，许多程序并不验证nvram_get()的返回值。它们只是将返回值传递给字符串相关的函数，如strcpy()或strtok()，并在NULL指针解引用时崩溃。

FirmAE通过仲裁nvram_get()函数的行为来处理这个问题。在访问未初始化的键时，FirmAE返回一个指向空字符串的指针，而不是返回NULL值。这个简单的改变大大减少了崩溃，特别是在NETGEAR映像中。因为在没有物理设备的情况下，我们无法获得真正的键值对，所以这是避免许多内部程序错误处理不足导致崩溃的最优方法之一。

### 4.4 内核仲裁
嵌入式设备中的许多程序通过内核中的设备驱动程序与外设进行协作，它们通常使用ioctl命令与外围设备通信。不幸的是，模拟这个过程不是一项简单的任务，因为每个设备驱动程序都有不同的特征，这取决于它的开发人员和相应的设备。虽然Firmadyne实现了一些虚拟内核模块，支持/dev/nvram和/dev/acos_nat_cli，但它无法覆盖在实际场景中固件映像的各种特性。由于这个问题，我们数据集中的许多固件映像也会崩溃。

**内核模块支持不足。** 由于Firmadyne使用硬编码的设备名称和ioctl命令实现了虚拟模块，因此在访问具有不同配置的内核模块时，一些程序会失败。例如，许多NETGEAR映像使用一个名为acos_nat的模块，该模块用于与挂载在/dev/acos_nat_cli上的外围设备通信。在这些映像中，Firmadyne模块返回不正确的值，并在httpd的web服务上造成无限循环。此外，我们发现ioctl命令根据固件架构的不同而不同，因此也应该考虑这一点。

FirmAE的高级方法利用了模拟特定内核模块的优势。这里的关键思路是，许多内核模块是通过具有发送相应ioctl命令的函数的共享库访问的，因此，FirmAE采用类似于处理NVRAM问题的方法(§4.3)，拦截库函数调用。当程序调用库函数时，FirmAE返回一个预定义的值。因此，不需要根据设备架构来模拟每个ioctl命令。在本例中，我们只关注acos_nat，而其他通过共享库的外设访问可以以相同的方式处理。

**不适当的内核版本。** 我们发现一些固件映像与内核版本存在问题。Firmadyne在固件仿真中定制了Linux内核v2.6.32，然而最近的嵌入式设备使用更新版本的内核。对于这个问题，升级内核版本似乎是一个很容易的解决方案。实际上，我们对Linux内核v4.1.17进行了实验测试，并成功模拟了更多固件映像。然而一些固件映像，特别是较旧的映像，不能用新版本的内核模拟，它们因为libc库崩溃而模拟失败。

我们调查了这些情况，并确定Linux内核v4.1.17的地址空间布局随机化与libc的旧版本不兼容。为了解决这个问题，我们在编译新内核时使用了兼容性选项。具体来说，我们设置了CONFIG_COMPAT_BRK选项，它排除了堆内存中的随机brk区域。使用这个新内核，FirmAE能够处理上述情况。在我们的实验中可能还存在其他没有检测到的兼容性问题。为了解决这些问题，应该进一步测试具有各种编译选项的多个内核版本，这是我们未来研究的目标之一。

### 4.5 其他仲裁
一些失败的案例可以通过其他的小干预来解决。
**未执行的web服务器。** 对于web服务的动态分析，我们需要同时实现网络可达性和web服务可用性。在一些映像中，即使网络配置成功，web服务器也不运行。我们找不到这一现象的确切根源。然而，强制执行web服务器的干预可以解决这个问题。具体来说，它在目标固件的文件系统中搜索广泛使用的web服务器，如httpd、lighttpd、boa或goahead，以及它们相应的配置文件，并执行它。

**超时的问题。** 长时间不响应的仿真固件映像应该被强制停止，因此设置适当的超时是必要的。Firmadyne应用了60秒超时，但是，固件映像(特别是来自NETGEAR的)需要很长时间才能完成引导过程，因此它们的模拟最终会被阻塞。我们调查了这种情况，并根据经验找到了240秒的合适超时时间。虽然这个更改很简单，但是成功模拟了60多个固件映像。

**缺少模拟工具。** 嵌入式设备开发人员经常删减不必要的功能以节省存储空间，因此固件映像可能没有适当的工具来模拟自身。由于模拟环境没有任何存储限制，我们可以添加几个必要的工具。为了成功模拟，应该在文件系统中准备一些像mount或ln这样的Linux命令。我们通过将最新版本的busybox添加到目标固件的文件系统中来解决这个问题。这个简单的添加可以启用必要的命令，并实现成功模拟。

## 5.评估
从对AnalysisSet的调查中，我们发现了几个仲裁点(§4)。在本节中，我们在数据集上用我们的原型FirmAE(§3.3)评估每个仲裁。为此，我们在Python和shell脚本中实现了总共3671行，我们还介绍了在使用FirmAE进行动态分析时识别出的漏洞。

### 5.1 固件模拟结果
我们对比了FirmAE和Firmadyne在每个数据集上的仿真率(§3.4)。所有数据集的总仿真时间小于4小时(14289秒)，因为FirmAE支持完全自动化和并行化(§3.3)。

**总体结果。** 由于我们的目标是模拟web服务进行动态分析(§3.1)，我们验证每个仿真固件的网络可达性和web服务可用性，因此我们将web服务的可用性作为仿真率。总的来说，仿真率显著地从16.28%提高到79.36%(提高了487%)。因为我们的调查是基于AnalysisSet，所以它显示了最高的比率91.83%。与Firmadyne获得的数据相比，LatestSet和CamSet的比例也有很大的提高，并且我们可以识别它们中的漏洞(§5.3)。在AnalysisSet中，NETGEAR镜像的仿真率增加最多，从10.95%增加到93.80%(增加了857%)，这是由于解决ARM网络问题的干预，因为大多数NETGEAR镜像都是基于ARM的。LatestSet中TRENDnet、ASUS、Belkin、Zyxel的仿真率均在60%以下，这些较低的比例归因于这些映像中内核模块的数量较多，以及使用了自定义硬件接口。我们在§5.2中详细描述了这一点。

CamSet的仿真率表明，解决无线路由器的故障问题也可以帮助模拟IP摄像机。特别的，没有一个D-Link镜像能被Firmadyne模拟，而FirmAE可以模拟超过65%的镜像。然而，FirmAE不能模拟所有的TP-Link图像。我们调查了这些失败的案例，发现它们不包含web服务器。CamSet的结果表明，许多IP摄像机具有与无线路由器相似的特性，因此无线路由器的仲裁也可以应用于IP摄像机。

**每次仲裁的影响。** 我们还通过从仲裁都适用的FirmAE的最终版本中删除一个特定的仲裁来调查每个仲裁的有效性。这是因为许多仲裁点应该合作解决故障，而扣除一个特定的仲裁直接影响仿真率。

NVRAM仲裁似乎是最有效的，在所有数据集中平均降低35%的模拟率，这与Firmadyne专注于模拟NVRAM的方法得到的结果是一致的。删除引导和网络仲裁也显著降低了仿真率约30%。在没有内核仲裁的情况下，所有数据集中只有4.88%的固件映像受到影响。其他仲裁影响了22.35%的固件映像。这些结果表明，所提出的仲裁对于成功的固件仿真确实是有效的和可扩展的。

### 5.2 模拟后分析
在大规模模拟之后，我们将研究无法通过简单仲裁轻松解决的未处理的故障问题，而需要更复杂的虚拟化。

**内核模块。** 正如之前的研究中讨论的那样，模拟内核模块具有挑战性，因为1)不同的内核版本经常会产生兼容性问题，2)一些固件映像可能没有内核以致于无法获得有用的信息。在少数案例中，web服务器和其他程序访问/proc目录下的内核模块。因为仿真环境中不存在这样的文件，所以这些程序经常崩溃。例如，TP-Link固件映像中的web服务器访问内核模块/proc/simple_config/system_code进行配置，随后由于该模块不存在而崩溃。

**硬件接口。** 一些固件内部程序使用自己的专用接口进行外围通信，强化了模拟的外围接口。例如，我们用流行的库调用来模拟NVRAM，然而一些D-Link固件的程序调用/bin/flash直接访问/dev/nvram。类似地，httpd服务器在一些TP-Link固件映像中访问闪存/dev/ar7100_flash_chrdev，以获得设备配置的信息。同时，Linksys固件中名为webs的web服务器直接操作/dev/mtd接口。他们甚至验证设备的完整性，验证给定固件的签名和版本。

**CGI错误。** 即使web服务器是可访问的，其中一些服务器很少响应服务器错误，即500内部服务器错误。这个错误有几个原因，如CGI程序中的语法/代码错误，无效的web界面配置和PHP错误。然而，大多数错误情况是由后端CGI程序的崩溃引起的。我们用逆向工程分析了CGI程序，发现它们有相同的硬件接口问题，它们尝试访问/proc或/dev下的条目以获取配置值，如果失败则异常停止。

上述情况显示了在没有物理设备的情况下模拟外围通信的困难。解决这些问题需要一个更加复杂的仿真环境，这将在未来的研究中得到解决。

### 5.3 应用动态分析—模糊测试
在成功模拟固件映像之后，我们将对其web服务进行动态分析和模糊测试。通过这个评估，我们1)验证了该仲裁仿真方法在嵌入式设备动态安全分析中的确是可行的，2)评估了当前嵌入式设备在外面的安全现状。我们以最新固件的LatestSet和CamSet为目标。

**动态分析引擎。** 对于大规模的分析，我们关注的是可伸缩性。因此，我们的动态分析工具需要在用户交互很少的情况下适用于不同的仿真固件图像。有了这些标准，我们首先搜索现有的工具并检查它们是否适用于FirmAE。

然而，现有的工具并不能满足我们的标准，因为它们1)无法公开获取，2)无法进行大规模分析，3)无法发现新的漏洞。例如，Firmadyne利用Metasploit检查已知的漏洞。其他web扫描器，如Burp Suite、Arachni或Commix，只检查预定义的HTTP模式的组合。因此，对于实际场景中的各种固件web服务，它们是不够的。此外，它们不是为查找内存损坏漏洞而设计的，比如缓冲区溢出或UAF。同时，最先进的模糊器Firm-AFL是一种有前途的检测内存损坏漏洞的工具。然而，它并不适用于大规模的分析，因为它需要为目标程序设置单独的环境。由于这些限制，我们构建了自己的分析引擎。开发分析引擎本身是一个研究领域，在这里我们只提出一个概念设计,我们的概念也可以应用于上述的工具。

我们的分析引擎由两部分组成:它自动初始化并在必要时登录到网页，并识别包括内存损坏bug在内的漏洞。为了找到1天漏洞，我们利用了routersplit，它具有之前已知漏洞的概念证明(PoC)代码，我们还添加了一些定制的PoC代码。为了分析0日漏洞，我们用Python开发了一个带有880 行的简单web模糊器。

**初始化web服务。** 动态分析的主要步骤是初始化web服务，除非它们没有接收到任何其他请求。我们数据集中的大部分web服务需要在管理页面中进行网络和安全配置(例如，admin或AP密码)。但是，这个初始化过程在每个固件中也不同。DLink、TP-Link、Belkin、Linksys和ZyXEL中大多数固件映像中的Web服务器在模拟成功后自动初始化，而ASUS和TRENDnet中的Web服务器必须亲自初始化。幸运的是，其中许多都有一个跳过按钮来配置默认选项。有些web服务没有显式的跳过按钮，但是有内部的JavaScript函数，它们的行为是相同的。同时，有些需要手动设置管理密码。

为了自动处理web服务的初始化过程，我们分析了web服务的初始化过程，并从中提取了具有代表性的模式，包括按钮和菜单。然后，我们利用这些模式使流程自动化。在这里，我们利用Selenium，它是一个开源工具，可以提供与真正的浏览器类似的界面。

**评估漏洞发现性能。** 在成功运行固件映像及其web服务之后，引擎首先使用routersplit和我们定制的PoC代码检查1天漏洞。因为routersplit由多个已知漏洞的攻击组成，在这个评估中，我们可以1)检查目标设备是否打了补丁，2)找到一个新的易受攻击的设备，之前是未知的，但有相同漏洞的。

为了找到0日漏洞，我们的引擎首先搜索目标固件的文件系统，并通过检查.html、.aspx或.xml等文件的扩展名，生成一个候选网页列表。然后，它从候选参数中提取可能的参数，并生成检测漏洞的请求。例如，对于.htm和. HTML候选文件，我们的引擎解析HTML标记，例如脚本、表单和输入、以提取目标url、方法和参数信息。当为使用家庭网络管理协议(HNAP)的模糊设备构建请求时，这种方法特别有用，HNAP请求基于XML格式，默认值在.html页面的javascript代码中设置。利用提取的信息，我们可以构造一个有效的模糊化请求模板。因为我们从文件系统中搜索候选服务，所以我们还可以检查无法通过爬行访问的web服务。

在各种类型的漏洞中，我们主要关注命令注入和缓冲区溢出这两种经常出现在嵌入式设备中的漏洞。为了检测命令注入漏洞，我们的引擎发送有效负载，它本质上是候选字符的组合，例如" '，' " '或' & '，后面是一个执行可执行二进制文件的shell命令。我们放置这个二进制文件来记录有用的信息，例如时间和环境变量，从而检查漏洞是否被触发。我们还挂钩execve系统调用，以便容易地检测输入是否注入到命令中。对于缓冲区溢出检测，FirmAE在发生崩溃时提供反馈。注意，我们必须在向目标web服务发送请求后等待，因为处理请求需要时间，根据经验，我们认为10到15秒就足够了。我们还利用边界值，例如用于模糊输入的大型缓冲区，因为它们更有可能触发漏洞。

我们的分析引擎报告的任何漏洞都必须进行验证。为此，我们将诸如strace、gdb和gdbserver等调试程序添加到目标固件的文件系统中。注意，当我们升级内核版本(§4.4)时，我们可以利用ptrace系统调用进行调试。我们还添加了netcat和telnetd来访问来宾shell。使用这些工具，我们手动验证了识别的错误。

### 5.4 动态分析结果
为了评估仲裁仿真的有效性，我们对每个仿真固件映像执行了动态分析，其中web服务已经由我们的引擎初始化。在目标固件映像的web服务由FirmAE和Firmadyne各自初始化之后，我们运行了之前已知的PoC漏洞。我们首先使用routersplit对使用FirmAE和Firmadyne在AnalysisSet中的模拟镜像上分别测试已知的漏洞。在不使用任何仲裁(即Firmadyne)的情况下，我们只能检查14个映像中的漏洞，其中9个是unique的设备。通过应用所有提议的仲裁(例如，FirmAE)，我们可以进行检查320个镜像中的漏洞，其中128个是unique。由于FirmAE的目标是模拟web服务(§3.1)，所有已识别的漏洞都位于web服务中，如SOAP CGI、UPnP和HNAP。这一结果表明，FirmAE的成功仿真有助于在动态分析固件映像方面优于Firmadyne。

此外，我们进行的动态分析包括一个构建在LatestSet和CamSet中的最新镜像上的模糊器。结果，我们在95个独特的设备上总共发现了23个独特的漏洞，这些漏洞包括11个1天漏洞和12个0天漏洞。对于模糊器，当并行运行50个镜像时，每个模糊测试请求平均需要10-15秒，发现每个漏洞的平均时间为70分钟，最长为150分钟。模糊吞吐量可以根据系统规格和并行仿真实例的数量而变化。

有趣的一点是，一些供应商有着相同的漏洞。例如D-Link和TRENDnet中的一些设备存在相同的信息泄露漏洞，以及UPnP和SOAP CGI程序中的命令注入漏洞。此外，一些NETGEAR设备与Xiongmai的设备都有路径遍历漏洞。另一点是，对目标web服务的分析可能会揭示与之相关的其他程序的漏洞。具体来说，当我们发送一个长的载荷以检测缓冲区溢出时，目标CGI程序将载荷存储在一个文件中，然后，另一个读取该文件的程序由于载荷溢出而崩溃。这样的漏洞只能在全系统仿真环境中找到，因为用户模式仿真不考虑文件系统的关系。

综上所述，结果表明FirmAE在漏洞分析中是可行的。我们认为，未被发现的漏洞仍然存在，应该在未来的研究中进行研究。

**负责任的披露。** 检测到的零日漏洞分布在四个供应商中。到2019年12月，我们向供应商报告了所有12个漏洞，最多的花了9个月的时间收到他们的回复。

## 6.讨论
**仲裁仿真中的仿真差异。** FirmAE的目的不是消除真实环境和仿真环境之间的差异，而是旨在运行固件的web服务器，并正确地服务于web界面，这可能会导致与在硬件上运行固件不同的行为。然而，在应用动态安全分析时，我们需要检查的是是否1)漏洞程序运行，2)接受恶意输入，3)触发程序中的漏洞。 尽管模拟可能是不正确的，但如果我们1)可以运行固件的web服务，2)通过网络发送攻击包，3)验证攻击是否成功执行，则可以检查这三个项目。因为我们的仲裁模拟可以支持这些，所以FirmAE发现的漏洞是合理的，并且在真实的设备中也可以工作。

**仲裁干预的一般性。** 尽管我们对仲裁模拟的启发式比其他工作对当前固件映像的性能更好，因为我们开发了启发式来经验地处理故障情况，但我们的系统化仲裁模拟只能处理观察到的情况，可能不适用于新设备和新配置。对此，我们认为有经验调查来寻找此类干预措施似乎是必要的，来处理物联网设备及其配置的复杂性质。为了鼓励未来的研究，我们发布了我们的代码，相信我们的经验发现可以作为参考。

**应用其他动态分析技术。** 在这项研究中，我们开发了一个简单的分析引擎来进行动态分析，它可以自动初始化、登录并分析web服务。然而，每一步都可以通过应用其他有前途的技术来进一步改进。例如，可以通过使用符号执行来分析和绕过登录过程。此外，采用其他模糊策略、混合分析方法或相似技术可能会发现更多的漏洞。我们将这些有希望的改进留在动态分析引擎上作为未来的工作。

**应用仿真构建物联网蜜罐。** 仲裁仿真也可以用于构建蜜罐，以分析针对物联网设备的大量攻击。事实上，已经有一些利用仿真的蜜罐研究。特别是，Vetterl等人提出了一个名为Honware的蜜罐，它基于类似于FirmAE的方法的固件模拟。由于蜜罐应该与网络外的攻击者进行交互，作者通过重点研究仿真失败案例来提高网络可达率。因此，FirmAE配置默认网络设置的网络干预与Honware的方法相当相似。然而，FirmAE包含了额外的干预来运行web服务，以积极地分析其中的漏洞，而这样的干预甚至进一步提高了模拟率。因此，我们相信仲裁仿真也可以用于构建物联网蜜罐。

## 7.结论
嵌入式设备的安全性分析受到了广泛关注，在这项研究中，我们调查了一个大规模的固件数据集，并发现固件仿真可以从简单的干预中获得实质性的好处。我们提出了仲裁模拟和干预，可以解决高级故障问题。通过一个原型FirmAE，我们证明了所提出的方法可以将最新框架的仿真率提高487%。我们还对仿真固件进行了动态分析，发现了23个独特的漏洞，包括12个0天。


## 学到的内容
state-of-the-art  adj. 最先进的
to this end 因此
Specifically, 具体的说
LoC, Lines of Code 代码行数

## 待了解
各种网络接口类型lan(局域网),wlan(无线局域网),vlan(虚拟局域网),network bridge 
linux系统启动过程
linux hook
ioctl
