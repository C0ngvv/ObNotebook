# Detecting Vulnerabilities in Linux-Based Embedded Firmware with SSE-Based On-Demand Alias Analysis

![](images/Pasted%20image%2020231018111655.png)

ISSTA 2023

# 翻译
## 摘要
尽管使用静态污染分析来检测基于linux的嵌入式软件中的污染类型漏洞的重要性已得到广泛认可，但现有方法存在以下主要局限性:(a)现有工作不能正确处理从攻击者控制的源到安全敏感的接收器的路径上的间接调用，导致大量误阴性。(b)他们采用启发式方法来确定中间污染源，但这种方法不够准确，导致误报率很高。

为了解决这些问题，我们提出了EmTaint，这是一种新的静态方法，用于准确快速地检测基于linux的嵌入式固件中的污染类型漏洞。在EmTaint中，我们首先设计了一个基于结构化符号表达式(SSE)的按需别名分析技术。在此基础上，提出了间接调用解析和精确的污点分析方案。EmTaint与消毒规则检查相结合，最终可以在有限的时间内准确地发现大量的污染式漏洞。我们将EmTaint与来自六个流行供应商的35个真实嵌入式软件样本进行了评估。结果显示，EmTaint发现了至少192个漏洞，其中n天漏洞41个，0天漏洞151个。在撰写本文时，已从报告的漏洞子集中分配了至少115个CVE/PSV编号。与KARONTE和SaTC等最先进的工具相比，EmTaint在更短的时间内在同一数据集上发现了多得多的漏洞。

关键字：按需别名分析，污点分析，嵌入式软件

## 1.引言
随着物联网技术的兴起，嵌入式设备在我们的日常生活中得到了广泛的应用。为了快速开发，设备厂商倾向于定制Linux内核，并编写基于Linux的嵌入式固件来管理和控制设备。例如，几乎所有主流的无线路由器都配备了基于linux的嵌入式固件。然而，由于厂商缺乏全面的安全评估，基于linux的嵌入式固件存在大量未被披露的漏洞，这给网络空间安全带来了重大的重大影响。在各种漏洞类型中，污点类型漏洞是一种典型的漏洞类型，用户输入未经适当检查或处理就可以到达安全敏感的sink[41]。由于路由器、网络摄像头等基于linux的嵌入式设备与外界的通信频繁，因此更容易触发污点型漏洞，因此我们需要对其进行优先级检测。

静态污点分析是一种有效的技术，用于发现嵌入式软件中的污点式漏洞，例如KARONTE[30]和SaTC[7]。它可以用来执行整个分析固件，而不需要仿真和真实的设备。在静态污点分析中，污点源指的是接收用户输入的库函数(例如，recv、recvfrom)，而污染汇聚点指的是安全敏感的库函数(例如，strcpy、system)，这些函数可能被利用来导致内存损坏或命令注入。污点分析的基本思想是寻找从污染source到sink的数据流路径(我们称之为潜在漏洞路径)，然后对路径进行安全检查，推断是否存在漏洞。

**挑战**。然而，对于嵌入式二进制文件的污染分析来说，有效地揭示潜在的漏洞路径是一个具有挑战性的问题。原因是双重的。一方面，在基于linux的固件的后端，大多数潜在的漏洞路径涉及间接调用(参见§4.3)，其中一些无法直接解决。因此，目标二进制文件中仍然存在许多潜在的易受攻击路径。另一方面，变量别名的频繁出现也使得数据分析技术无法发现隐含的潜在漏洞路径。为了缓解这些挑战，最新的研究[7,30]利用启发方法识别中间污染源作为原始污染源的替代方案，从而缩短从用户输入到汇聚点的潜在易受攻击路径的长度，从而减少遇到间接调用和变量别名问题的概率。不幸的是，这些方法有时会错误地识别后端二进制文件中的中间污染源，从而导致潜在的易受攻击路径的误报。同时，由于联系的困难性，这些工作中仍然没有考虑间接调用解析，因此许多潜在的脆弱路径没有被发现，从而产生了许多假阴性。

我们的解决方案。在本文中，我们旨在通过解决间接调用和隐式数据带来的问题，全面、准确地揭示从污染源到污染池的潜在脆弱路径。我们的见解是，准确的别名分析可以在污染传播期间促进间接调用解析和隐式数据分析。为此，我们提出了一种基于结构化符号表达(SSE)的按需别名分析技术。该技术从两个方面克服了现有别名分析技术(基于vsa或基于符号执行的方法)的缺点。首先，我们设计了一种新的符号表达式来表示别名信息，与现有的方法相比，提高了别名分析的准确性。其次，该技术只关注感兴趣的变量(间接调用目标和受污染的变量)来执行按需分析，避免了对其他不相关变量的整体分析。

在基于SSE的按需别名分析的基础上，我们提出了EmTaint，它可以有效地检测基于linux的嵌入式固件中的污染型漏洞。EmTaint的设计如下。首先，EmTaint从嵌入式固件中提取目标二进制可执行文件，并构建用于进一步静态分析的基本程序表示。然后，EmTaint执行基于SSE的按需别名分析，这可以帮助找到间接调用目标与函数指针之间的别名关系。在此基础上，EmTaint设计了间接调用解析和精确的污点初始化和传播方案。最后，EmTaint集成了消毒规则检查，可以有效地检查发现中基于linux固件中的污染型漏洞。

我们已经用Python实现了大约24000行EmTaint的原型。在EmTaint中，基本的程序表示是通过使用IDA Pro[22]、CLE[11]、pyvex[29]来构建的。本文提出的基于sse的按需别名分析和间接调用解析是基于Claripy开发的[10]。我们用35个真实的固件样本来评估EmTaint。结果显示，EmTaint至少发现了192个漏洞，其中n天漏洞41个，0天漏洞151个，平均每个样本耗时3分钟。我们已经向相关制造商报告了151个0天漏洞，以进行负责任的披露。在撰写本文时，115个漏洞已被CVE/PSV确认。我们还与最先进的KARONTE[30]和SaTC[7]进行了比较。对比结果表明，EmTaint可以在更短的时间内发现更多的漏洞。此外，我们在2021年的DataCon竞赛中使用EmTaint进行物联网固件漏洞检测，最终获得第一名，这证明了EmTaint在现实世界中的效率。

贡献。我们的贡献如下:

- 我们提出了一种新的别名分析技术，称为基于sse的按需别名分析，以应对有效地揭示了污染分析的潜在脆弱路径的挑战。
- 我们提出了EmTaint，这是一种用于检测基于linux的嵌入式固件中的污点型漏洞的新方法。原型是用Python实现的，大约有24,000行。
- 我们通过大量的实验来评估EmTaint。结果证明，EmTaint在检测基于linux的固件中的污染类型漏洞方面优于最先进的工作。此外，EmTaint在35个嵌入式固件样本中发现了151个0天漏洞(其中115个带有cve/psv)。
- 我们在https://sites.google.com/view/emtaint/home上发布了EmTaint的源代码和实验数据，以供将来的研究。

## 2.背景和动机
### 2.1 污点型漏洞检测
给定一个嵌入式二进制文件，检测污染类型漏洞的标准污染分析过程包括四个步骤。(1)恢复程序间控制流图(ICFG)。(2)识别攻击者控制的源和安全敏感的sink。(3)找到一条污点从源传播到sink的路径。(4)检查sink点污染数据的约束。如果没有约束，则会引发有关该漏洞的警报。理想的解决方案应该在所有这些步骤中实现高精度。

### 2.2 动机案例
然而，如何有效地揭示从污染源到接收器(步骤3)的完整路径是一个具有挑战性的问题。主要原因是嵌入式设备中的服务程序经常注册回调函数来处理不同类型的用户请求，从而阻止了从源到接收器的污染传播。只有在执行期间指定用户请求，间接调用目标可以被分配一个回调函数。这意味着，在执行静态污染分析时，间接调用目标仍然是未知的，因此污染分析将卡在这些点上。

图1显示了间接调用如何防止污染分析技术查找NETGEAR DGN2200路由器中的命令注入漏洞的示例。首先，后端接收来自前端的请求，并通过getReqName函数获取URL dnsloopup.cgi，并将其存储在变量name中(第10行)。然后，后端在注册用于处理dnsloopup.cgi(第12行)的全局函数表中搜索函数指针，最终调用函数diagCgiDnslookup(第13行)。diagCgiDnslookup函数包含命令注入漏洞：cmd的值来自用户请求(前端用红色标记)，没有进行任何清理检查。攻击者可以将额外的命令附加到字符串“router”上，从而在设备上运行任意命令。然而，在静态污染分析中，\*fn(第13行)是未知的，因此污染分析无法到达system函数和以及此潜在漏洞。

![](images/Pasted%20image%2020231018153346.png)

SaTC[7]、KARONTE[30]等现有研究采用启发法推断中间污染源作为用户输入的代表，从而缩短了污染源到汇点的距离，降低了污染分析的复杂性。然而，它们仍然有局限性。首先，识别中间污染源的启发式方法仍然会产生大量的假阳性和假阴性。特别是，SaTC利用来自前端web文件和后端二进制文件的共享接口关键字来识别中间污染源。但是，部分用户输入的关键字在前端web文件中不存在。例如，在NETGEAR R7800路由器固件版本V1.0.2.58中，在前端web文件中找不到关键字hidden_funjsq_username，导致SaTC无法识别，但该关键字的值可能导致命令注入漏洞。其次，间接调用问题仍然存在于从中间污染源到sink的短路径中，这在现有的工作中没有考虑到，导致在揭示脆弱路径时出现假阴性。

### 2.3 挑战与核心理念
通过对最新工作的研究和对激励示例的观察，我们总结了在基于linux的固件中检测污染类型漏洞的两个挑战。首先，当路径上涉及间接调用时，如何找到从实际输入源(例如，recv函数)到接收器的完整路径。二是如何在路径较深的情况下有效地检测漏洞。

为了解决上述两个挑战，我们提出了基于SSE的按需别名分析，它可以作为间接调用解析和精确有效污染分析的基本技术。基于SSE的按需别名分析可以从两个方面进行解释。首先，受访问路径[8]的启发，我们设计了一种新的符号表达式，称为结构化符号表达式(SSE)。但是，访问路径针对的是源代码，而不是二进制文件。SSE可以准确描述嵌套的内存访问变量(如x.y.z)，保证别名分析的准确性。与符号执行中使用的符号表达式不同，SSE对算术操作和内存操作(如加载和存储)进行编码。因此，给定变量的任何形式的别名都可以通过SSE精确地表示。其次，我们进行按需分析以确保别名分析的效率。这意味着，只需要跟踪感兴趣的变量，例如间接调用目标和受污染的变量，从而避免了耗时的整体分析。在基于SSE的按需别名分析的基础上，我们采取了处理间接调用的策略并实现准确的污染传播。之后，我们可以有效地揭示从输入源到安全敏感sink的完整潜在脆弱路径。

## 3.方法
### 3.1 概述
EmTaint将嵌入式固件映像作为输入，并将潜在的污染类型漏洞作为输出报告。如图2所示，EmTaint由四个主要组件组成。

**固件预处理**。固件预处理模块从固件解压提取二进制文件。然后，该模块将二进制代码转换为中间表示(IR)。之后，它构建控制流图(CFG)和部分调用图(CG)，以方便后续分析。

**基于SSE的按需别名分析**。别名分析引擎定义了一种新的结构化符号表达式(SSE)来准确地表示别名信息，并设计了别名更新机制，以发现别名贯穿整个二进制可执行文件。为了实现按需分析，它只计算与感兴趣的变量相关的别名。这将避免为大量不相关变量计算别名的开销，从而可以将分析应用于复杂的固件二进制文件。

**间接调用解析**。利用所提出的基于SSE的别名分析引擎提供的数据依赖性信息，我们进一步设计了一个间接调用解析算法，该算法检查间接调用点与引用的函数指针(或函数表指针)之间的数据依赖性。该机制有助于后续的污点分析跨越更多的功能边界，提高污点类漏洞的发现能力。

**污点类型漏洞检查**。污点类型漏洞检查模块负责识别潜在的污点类型漏洞。特别是，它首先污染由攻击者控制的污染源上的变量(例如，recv函数)。然后，它通过按需别名分析模块和污染传播操作捕获污染传播。最后，在安全敏感的sink点(例如，system函数)，如果相应的变量被污染且不受约束，我们将其标记为潜在的漏洞。由于污点类型漏洞检测的高级思想与[3,7,30]一致，所以我们在[37]中包含了详细的过程描述。

### 3.2 基于SSE的按需别名分析
在本节中，我们首先从结构化符号表达式(SSE)的定义开始。然后，我们用SSE对按需别名分析问题建模。在此基础上，我们描述了如何对每条指令执行SSE更新。

#### 3.2.1 SSE的定义
SSE是一种新的表示法，它使用抽象内存模型通过编码相关程序点的嵌套内存访问信息来表示变量的别名。在表1中，我们递归地定义SSE表达式。请注意，由于我们的实现是基于VEX IR的，因此SSE定义深受其设计的影响，特别是基本语句和内存模型。SSE可以是任何基本变量，也可以是对基本变量进行二元/一元算术运算的结果。基本变量可以是寄存器(表示为$\tau _{reg}$)、原始立即值(表示为$\tau _{val}$)或内存访问(表示为$\tau _{mem}$)。内存访问可以是一个从内存加载的值(表示为$load(expr)$或存储到内存中的值(表示为$store(expr)$)。这里，$expr$是一个指针。

一个直观的例子。我们使用一个直观的示例来解释如何利用SSE来发现一个给定指针的别名。在图3中的代码片段中有四条指令。我们的目标是在第3行中找到R1的所有别名，这是一个已知的指针。首先，我们初始化line 3'中使用R1设置的别名。通过回顾，我们在第1行中发现了R1的一个定义，它通过从内存R3+0x8加载来获得它的值。因此，通过将R1替换为load(R3+0x8)，我们将line 1'中的load(R3+0x8)添加到别名集。现在，如果我们从第1行往前看，我们在第4行使用R3。也就是说，R3的值存储在内存R6+0x4中。因此，通过将load(R3+0x8)中的store(R6+0x4)替换为R3，我们将第4'行中的load(store(R6+0x4)+0x8)添加到别名集。通过沿着define-use和use-define链反复这样做，我们最终可以到达为给定指针设置别名的固定点。特别是，我们只需要计算与感兴趣的变量相关的别名，避免分析其他无关变量(例如，第2行中的变量)，以提高速度。下面几节将解释每个指令的完整SSE更新规则和用于过程间分析的算法。

![](images/Pasted%20image%2020231018200851.png)

#### 3.2.2使用SSE进行按需别名分析
从程序间CFG和查询(例如，指针p)开始，我们的按需别名分析算法涉及两个主要方面:(方面1)一个特定函数的别名分析如何工作;(方面2)一个函数分析的终止如何触发另一个函数的分析开始。

我们算法的第一个方面。我们首先定义一个称为别名分析图(AAG)的图，以正式地对特定函数中基于SSE的分析的更新和传播行为建模。

定义1 (AAG)。AAG是一个有向属性图G(N,E,S,Ftran,Btran,Fprop,Bprop)，其中N是节点集{n1，n2，…，nk}，每个节点ni表示一条指令，E是一组有向边，表示节点之间的控制转移关系，每个节点有四组独立的SSE集作为节点属性，S是每个节点上所有SSE集的并集。最后，Ftran和Btran是两组传递函数，分别在前向分析和后向分析期间更新每个节点上的SSE集。Fprop和Bprop分别是沿每条边的方向和沿每条边的方向传播SSE的两组函数。

由于别名分析分为正向和反向两个方向，因此AAG中的S记录了每个节点两个方向的SSE信息。具体定义如下:

- Sn：对于一个节点n，Sn由四个SSE集组成：fin,fout,bin,bout。fin仅被用于前向分析，bin仅被用在后向分析。
- $Ftran_n$：对于一个节点n，它将节点n的fin和节点n上的指令作为输入，并且更新两个SSE集fout和bout。
- $Btran_n$：对于一个节点n，它将节点n的bin和节点n上的指令作为输入，更新fout和bout两个集。
...
#### 3.2.3 传递函数内更新规则

#### 3.2.4 处理数据流循环和递归数据结构

#### 3.2.5终止性、完整性、稳健性和复杂性

### 3.3 间接调用解析
EmTaint根据间接调用目标的别名与函数指针引用(或函数表指针)的别名之间的依赖关系来解析间接调用。首先，EmTaint通过遍历反汇编代码来识别所有的间接调用指令。EmTaint将所有带有寄存器的分支指令视为间接调用(例如，ARM中的blx 0和MIPS中的jalr $t9)。EmTaint然后使用IDA Pro 调用目标可以被识别的指令。其余的被视为未解决的间接调用。由于MIPS中几乎所有的调用指令都使用寄存器作为操作数，因此MIPS程序的间接调用数量比ARM程序大得多(见表6)。

其次，EmTaint通过扫描代码段和数据段来查找所有取址函数，并定位对取址函数的所有引用。这里的取址函数表示有函数指针指向它们的函数。引用函数主要有两种方式。包含函数地址的函数指针可以在间接调用中直接用作操作数。我们将这类引用表示为fptr，并在清单1的第2行中展示了一个示例。包含函数表地址的函数表指针可以间接使用(即，通过先解引用函数表)来获得真实的函数地址。我们将这类引用表示为dptr，并在第7行展示了一个示例。在本例中，表中的一个条目有两个域—指向索引名称的字符串指针和实际的函数指针。对于间接调用的目标，我们将其表示为tptr，并在第5行和第13行中显示示例。

![](images/Pasted%20image%2020231018203827.png)
最后，EmTaint执行基于SSE的别名分析以及间接调用目标tptr与原始引用fptr/dptr之间的和依赖关系。图5演示了间接调用解析的过程。EmTaint反向跟踪tptr到其所有别名。同时，EmTaint通过正向和反向分析，找到了fptr和dptr的别名。然后，EmTaint收集每个函数的入口块和出口块中的所有别名SSE，检查fptr/dptr的别名与tptr的别名之间的数据依赖关系，并进行匹配和更新。我们将tptr的别名SSE表示为CTexpr(调用目标表达式)，将fptr或dptr的别名SSE表示为Pexpr(指针表达式)。接下来，我们解释如何分析CTexpr和Pexpr，并推断与函数表相关的间接调用目标。

![](images/Pasted%20image%2020231018204210.png)

在最简单的形式中，CTexpr和Pexpr直接匹配。EmTaint可以直接从CTexpr计算调用目标。这通常表示由fptr引用的间接调用。如果CTexpr可以表示为$load(dptr+i*stride)$,其中dptr是一个函数的地址表,这stride是一个常数,i是一个索引,它强烈表明一个函数表引用。在这种情况下，EmTaint尝试从地址dptr+i\*stride读取值，其中索引i从0开始，每次递增1。当检索值大于函数表的最大地址时，它终止。如果返回值是合法的函数地址，则EmTaint将其添加到间接调用目标集合中。

对于不能准确地追踪到特定fptr或dptr的间接调用目标，我们间接地发现其依赖。我们的观察是fptr和dptr通常存储在一个多级数据结构中，其根指针是一个全局指针(表示为gptr)。因此，我们经常在Pexpr中找到$store(gptr)$。为了间接调用目标，程序也需要在调用点前指向相同的全局指针。如果CTexpr可以被简化为load(gptr)，其中相同的gptr被Pexpr使用，间接调用目标通过fptr立即恢复。如果CTexpr可以被简化为$load(load(gptr)+i*stride)$，其中相同的gptr被Pexpr使用，通过将CTexpr中的load(gptr)用dptr（因为dptr有一个别名SSE load(gptr）替换，一个新的SSE $load(dptr+i*stride)$可以被生成。然后EmTaint使用$load(dptr+i*stride)$解析间接调用目标。

## 4.实现和评估
EmTaint在Python中实现了大约24000行(不包括开源代码)，实现细节可以在[37]中找到。在评估中，我们的目标是回答以下四个问题。(1)它在发现嵌入式固件(§4.1)中的真实污染式漏洞方面有多有效? (2)基于SSE的按需别名分析算法(§4.2)的准确性如何?(3)在基于SSE的别名分析支持下，间接调用解析的有效性如何? 间接调用解析在改进漏洞发现(§4.3)方面发挥了多大的作用?(4)与最先进的技术(§4.4)相比，它的效果如何? 

**实验设置**。我们的评估数据集包括35个不同的固件样本，它们来自六个主要的嵌入式系统供应商:Cisco、D-Link、NETGEAR、TRENDnet、TP-Link和Tenda。大部分固件样本(31个样本)选择自基线KARONTE数据集[30]。其余4个示例从Cisco和TRENDnet的官方网站手动下载。总结的信息列在表3中，其中Size表示我们测试的二进制文件的大小(例如，httpd)。从表3可以看出，样本涵盖了ARM32、MIPS32和MIPS64三种架构，它们是基于linux的嵌入式设备中使用的主流架构。所有实验均在PC上运行Ubuntu 18.04.4 LTS操作系统，配备8核Intel酷睿i7-8550U CPU和24 GB RAM。

![](images/Pasted%20image%2020231018210735.png)

### 4.1 漏洞发现
表3显示了EmTaint发现的9346个受污染的数据可以到达不同sink的结果，其中1887个被确定为警报，因为没有检测到安全消毒。每个样品的分析时间平均约为180秒。

真阳性评估。鉴于EmTaint产生了大量的警报，研究其中有多少是真正的阳性是很重要的。然而，对true-positive的总体评估是劳动密集型的，因为它需要在实际设备上进行逆向工程和手工构建概念验证(PoC)，以验证它们是否是真正的bug。因此，我们随机选取一部分样本来估计真阳性率。具体来说，我们选择了10个物理设备，并从这些设备的971个警报中随机抽取100个警报。然后，我们确定一个警报是真阳，如果(1)它匹配一个已知的漏洞或(2)可以通过在真实设备上成功制作一个PoC来验证。表4显示，100个警报中有86个是真阳性，其中13个真阳性是通过已知漏洞验证的，其他的是通过成功构建的PoC验证的。这证明了EmTaint的高真阳性率。对于其余的误报警报，我们将其归因于不准确的间接调用解析、查找安全检查失败、假别名关系和污染源。

Nday和0day漏洞。除了前面提到的通过抽样验证警报之外，我们一直在努力验证更多的警报。我们优先考虑与我们可以访问的真实设备相关的警报。为了证实0day漏洞，我们尝试针对真实设备的最新固件版本制作PoC。从多个警报中识别漏洞的规则如下:由相同URL接口的POST请求的参数在不同的sink上触发的警报应该被识别为一个漏洞。该规则的灵感来自于我们对EmTaint发现的n天漏洞的观察。具体而言，我们通过搜索exploit-db[18]或MITRE CVE[13]中的记录，识别出41个n天漏洞，对应120个警报。[37]中的表3列出了41个n天漏洞在公共暴露ID中的分布情况。注意一个CVE ID可能对应多个告警。例如，CVE-2019-13278指的是一个独特的命令注入漏洞，它可以在目标二进制文件中的33个不同的sink点触发。最后，我们从512个警报中发现了总共151个0天漏洞。我们向制造商报告了151个漏洞，所有这些漏洞都已修复。发现的0天漏洞包括38个命令注入漏洞和113个缓冲区溢出漏洞，其中115个已经分配了CVE/PSV编号。包括相关CVE/PSV在内的漏洞信息汇总如[37]中的表5所示。由于我们数据集中的一些样本是旧版本，EmTaint生成的许多警报在最新版本中已经删除。我们推断这些漏洞是由供应商自己发现的，没有公开的细节。例如，EmTaint在NETGEAR R7800 v1.0.2.32中产生了119个警报，但我们只在其最新版本v1.0.2.68中验证了一个0天漏洞。通过对这两个样本进行逆向工程，我们发现许多漏洞通过用strncpy替换strcpy而得到了解决。

总之，EmTaint在我们的评估数据集中发现了151个0天漏洞(115个CVE/PSV)和41个n天漏洞。同时，EmTaint可以以较高的高真阳性率发现漏洞(86%)。

### 4.2 基于SSE的别名分析的有效性
为了评估基于SSE的别名分析的有效性，我们选择VSA[4]作为基准，VSA是最先进的二进制文件别名分析技术。所选择的测试数据集PTABEN[28]是SUPA[36]中使用的基准，SUPA是最先进的源代码需求驱动别名分析技术。我们从PTABEN中选择了C程序的三个测试集，包括基本测试集、上下文敏感测试集和低敏感测试集。我们选择的三个测试集涵盖了所有类型的指针。其余的测试集是用与我们的分析范围无关的其他语言编写的。我们使用实现VSA的Angr v9.0.5811[2]进行对比实验。

表5显示了结果。MAYALIAS(\*p，\*q)表示指针p和q是别名，NOALIAS(\*p， \*q)表示指针p和q不是别名。对于166例MAYALIAS和99例NOALIAS，我们的技术正确识别 249例(准确率为94.0%)，而angr-vsa正确识别214例(准确率为80.8%)。特别是，我们的技术的阳性率(95.2%)远高于angr-vsa(69.9%)。由于两个原因，我们的技术没有正确识别出8个MAYALIAS。首先，在堆栈中分配的复杂结构数组变量的一些字段无法通过SSE精确恢复。其次，我们的算法根据需要向前和向后跟踪变量，调用函数缺少上下文导致缺少对store定义的更新。angr- vsa精度低的原因是很多变量是不受约束的符号值，angr-vsa无法计算出它们的具体值。但是，EmTaint可以发现符号值与SSE的别名关系。

综上所述，我们提出的基于SSE的别名分析与PTABEN数据集中的VSA(80.8%， 69.9%)相比，在别名分析中具有更高的准确率(94.0%)和真阳性(95.2%)。

### 4.3 使用别名分析的间接调用解析
在本节中，我们评估了间接调用解析的有效性和效率，并评估了间接调用解析在发现污染式漏洞方面的有效性和必要性。需要注意的是，间接调用解析过程中有基于SSE的别名分析，因此，我们将基于SSE的别名分析和间接调用解析作为一个整体进行评估。

...

## 5.讨论
## 6.相关工作
## 7.总结
在这项工作中，我们提出了EmTaint，这是一种新颖的静态方法，用于准确快速地检测嵌入式固件中的污染式漏洞。EmTaint的关键技术是基于SSE的按需别名分析，它有助于间接调用解析和准确的污染分析。我们实现了EmTaint的原型，并对来自六个流行供应商的35个真实的嵌入式固件样本进行了评估。评估结果显示，EmTaint至少发现了192个漏洞，其中n天漏洞41个，0天漏洞151个。在撰写本文时，已从报告的漏洞子集中分配了至少115个CVE/PSV编号。与KARONTE和SaTC等最先进的工具相比，EmTaint在更短的时间内以更高的准确率在同一数据集上发现了多得多的漏洞。