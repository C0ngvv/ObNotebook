---
title: 2024-USENIX-Your Firmware Has Arrived-A Study of Firmware Update Vulnerabilities
date: 2023/12/15
categories:
  - 论文
tags:
  - 论文翻译
  - USENIX
---
# 2024-USENIX-Your Firmware Has Arrived-A Study of Firmware Update Vulnerabilities
## 基本信息
题目：你的固件已经到达:固件更新漏洞的研究

![](2024-USENIX-Your%20Firmware%20Has%20Arrived-A%20Study%20of%20Firmware%20Update%20Vulnerabilities/image-20231215164038033.png)

## 摘要
嵌入式设备在我们的社会中越来越普遍。固件更新是减轻嵌入式系统漏洞的主要机制之一。然而，固件更新过程也引入了新的攻击面，特别是通过易受攻击的固件验证过程。与内存损坏错误不同，固件更新中的许多漏洞源于不完整或不正确的验证步骤，而现有的固件分析方法不适用于此。为了弥补这一差距，我们提出了ChkUp，一种检查固件更新漏洞的方法。ChkUp可以通过跨语言的进程间控制流分析和程序切片来解析固件更新过程中的程序执行路径。通过这些路径，ChkUp定位固件验证过程，检查和验证其漏洞。我们实现了ChkUp，并对12,000个固件映像进行了全面分析。然后，我们在来自33个设备系列的150个固件映像中验证了警报，从而发现了零日和n日漏洞。我们负责地披露了我们的发现，在撰写本文时分配了25个CVE ID和1个PSV ID。

## 1.引言
嵌入式设备的快速增长，从智能手表等便携式设备到交通工具等大型机器，为我们的生活带来了更多的连接和便利。预计到2025年，嵌入式设备的市场规模将达到1162亿美元[10]。固件更新在修复漏洞和改进功能方面起着重要的作用。然而，实现不佳的固件更新机制可能会削弱这种优势，甚至引入新的攻击面。事实上，与软件更新相关的漏洞已经被认为是嵌入式设备的五大安全风险之一[12]。

**固件更新安全**。软件或固件更新是目前对抗网络攻击最有效的技术之一。然而，随着现代嵌入式系统连接性和复杂性的增加，越来越多的网络攻击专门针对固件更新过程，允许攻击者执行任意代码或回滚固件版本以暴露先前的漏洞[21,70]。最近Jeep Cherokee[52]、Samsung SmartThings Hub[8]和Asus Router[9]更新机制中的漏洞引起了人们的极大关注，凸显了自动识别固件更新漏洞的必要性。现有的固件漏洞检测方法通常侧重于识别用户控制输入对不安全sinks的调用[19,25,27,59,65]，或者使用常见的漏洞模式或已知规范的偏差来查找漏洞[24,33,49,50,64]。然而，固件更新漏洞构成了一个独特的挑战，因为它们通常来自跨多阶段更新过程的问题组合，由于缺乏全面的规范或系统的易受攻击模式分类而加剧。为了更好地了解固件更新漏洞的情况，我们对过去十年中与固件更新相关的CVE进行了分类和系统化。每种类型的漏洞都被放置在一般固件更新过程的不同抽象阶段，这在第2节中有详细介绍。

**我们的解决方案**-ChkUp。在本文中，我们提出了ChkUp，一种检查固件更新漏洞的新方法，包括缺少验证(例如缺乏版本检查)和不适当的验证(例如，使用MD5进行完整性检查)。直观地，ChkUp提取固件更新过程的程序执行路径，然后识别更新过程中的验证步骤链。然后，我们总结了多个固件更新阶段的漏洞模式，以进行漏洞检测。在进行此工作时，我们发现固件更新机制的现有实现存在独特的挑战，需要新技术。具体来说，有三个主要的技术挑战:

*C1.支持固件更新的多种系统组件*：在许多基于linux的固件映像中，各种类型的程序，如前端程序、脚本和二进制文件，被调用在软件更新执行路径中，跨越Web服务器的前端和后端。此外，固件更新中涉及的组件的多样性导致进程间通信(IPC)机制的异质性。为了应对这些挑战，我们开发了生成流程间更新流图(UFG)的技术。首先使用在固件更新过程中连接前端和后端的通用代码模式和语义信息来识别输入(entry)程序。然后，通过连接各个程序(即前端程序、脚本和二进制文件)的控制流并解析相应的IPC来提取跨语言控制流。有了这样一个跨语言、跨程序的控制流图，固件更新的执行路径可以使用带有固件更新特定语义的向后程序切片来解决。

*C2.验证程序识别*：固件更新是一个复杂的过程，包括各种检查和验证，从加密签名的验证到版本和设备ID的比较。只有当每个验证步骤(例如，签名验证或符合版本更新策略)及其组成得到适当实现时，更新过程才被认为是安全的。然而，固件更新没有标准化的规范，并且通常用多种编程语言实现。这导致了不同的验证实现，使得从执行路径中的众多功能中识别它们变得具有挑战性。为了应对这一挑战，ChkUp使用基于同构的数据流图(DFG)语义相似度匹配来识别固件验证过程。为了减少这个过程的开销，执行路径中的函数首先按照相似度评分进行排序，该评分是使用语法和结构特征计算的。然后，具有较高相似性分数的函数有限进行DFG同构的分析。

*C3.漏洞验证*：静态分析可能产生许多误报(FP)，这需要进一步的验证。但是，固件更新过程通常涉及一系列验证步骤，每个步骤都有其独特的功能和调用参数。为了测试链中后面的步骤，有必要创建能够通过前几个步骤的输入和环境。为了简化验证，我们提出了一种半自动的动态方法来验证可仿真固件映像的警报。具体来说，我们采用固件补丁来确保潜在的易受攻击程序的执行，然后根据输入恶意固件映像后的更新行为检查相应警报的有效性。

评价和发现。为了更深入地了解野外的漏洞，我们在12,000个固件映像上运行ChkUp。我们发现，弱验证算法，如使用MD5进行完整性验证，是普遍存在的。然后，我们对随机选择的150个固件映像进行漏洞验证:对于可仿真的固件映像，我们通过创建poc进行动态验证;对于其余的固件映像，我们进行了手动分析以验证它们的警报。我们的结果显示，真阳性率(TPR)为86.7%，假阳性率(FPR)为5.3%，导致在33个设备系列的固件映像中发现零日漏洞和n日漏洞。这些发现被负责地披露，并分配了25个CVE ID和1个PSV ID。最后，为了演示漏洞的可利用性，我们展示了固件降级和固件修改攻击。

**贡献**。我们的贡献概述如下:

- *固件更新安全的系统化*:我们将一般固件更新过程分为四个阶段，并通过分析和分类381个固件更新相关的CVE报告来检查每个阶段的安全问题。
- *更新漏洞检测的新方法*:我们提出了一种新的固件更新漏洞识别方法ChkUp，该方法解决了三个技术挑战:更新路径中的不同组件、验证过程识别和漏洞验证。
- *真实固件中的漏洞*:我们在12,000个固件映像上运行ChkUp，并使用概念验证(PoC)生成和手动分析相结合的方法验证其中150个固件的警报。结果证明了ChkUp识别零日漏洞和n日漏洞的能力。经过负责任的披露，已经分配了25个CVE ID和1个PSV ID。

## 2.固件更新安全系统化
### 2.1 固件更新挑战
为了更好地了解威胁形势，我们分析了过去十年中381个与固件更新相关的CVE，然后进行了系统化。虽然大多数CVE源于易受攻击的固件更新机制，但其他CVE只是对更新的安全性产生影响。图1显示了自2015年以来通用漏洞评分系统(CVSS) v3指标的年度分布。这一数字呈稳定增长趋势，从2020年到2021年，CVE的数量将翻一番。高、重度漏洞是低、中度漏洞的近4倍。这一增长不仅归因于CVE不断增加的总体趋势，还归因于嵌入式系统特有的新挑战[15,30,62,72 - 74,84,86]。这些挑战包括:1)由于连接性的增加，攻击面不断扩大;2)嵌入式系统的复杂性增加;3)产品生命周期长;4)嵌入式设备上的资源有限。这些因素导致了固件更新机制的多样化和漏洞的增加。

### 2.2 更新工作流和漏洞
典型的固件更新工作流有四个阶段，如图2所示:生成、交付、验证和安装。

![](2024-USENIX-Your%20Firmware%20Has%20Arrived-A%20Study%20of%20Firmware%20Update%20Vulnerabilities/image-20231215185954179.png)

**生成阶段**。生成阶段的目标是创建固件映像并使其可用。具体来说，作者首先开发了一个新的固件映像和一个清单。清单包含固件元数据，包括固件摘要、版本和设备ID。随后，使用数字签名对固件映像和清单进行签名，然后通过软件供应链将其传输到固件服务器。通常，作者通过在供应链中受信任方将固件上传到服务器。

在此阶段，外部攻击者可以进行供应链攻击以窃取证书并危害软件开发工具或基础设施。此类攻击的根本原因是对关键资产和基础设施的访问控制不当。近年来，越来越多的供应链相关漏洞被报道，这表明它们对现实世界的安全影响。报告显示，2020年，美国政府以及微软、英特尔和火眼等3万多家公共和私营组织遭受了大规模的软件供应链攻击，称为SolarWinds黑客攻击[55]。具体来说，网络犯罪分子入侵了Orion的IT管理软件，然后通过供应链向用户分发包含后门的恶意软件更新。

*结论1*:供应链漏洞带来了重大风险，通常来自不充分的访问控制。如果没有适当的设备上验证，受损的固件可能会安装在设备中，导致对设备的控制丧失。

**交付阶段**。交付阶段包括将新的固件映像从服务器传输到目标设备。一个固件组件，称为更新代理[46]，负责下载、验证和在持久内存中存储新映像。通常，新固件可以通过三种方式交付：1)固件服务器直接将固件和清单推送到设备的更新代理;2)更新代理轮询更新并在更新可用时下载更新;3)固件服务器通知设备用户/维护人员，设备用户/维护人员手动下载并上传更新到更新代理。在通信通道方面，常用的方法包括应用层协议(如HTTP、FTP)、无线媒体(如Wi-Fi、低功耗蓝牙)和物理接口(如USB、可移动存储卡)。对于一些低端的裸机设备，智能手机上的配套应用程序可以帮助进行固件更新。新的固件既可以捆绑在应用程序内部，也可以通过应用层协议从固件服务器获取。然后，这些应用程序通常通过无线媒体与设备通信，以进行通知、轮询和下载。值得注意的是，虽然应用程序充当传输固件的中介，但它们也可能预先验证更新。这样的早期验证可以过滤掉无效的更新，以避免不必要的后续设备上处理。

安全的通信通道对于交付的固件映像的机密性和完整性非常重要。不安全的交付主要源于缺乏加密协议或使用硬编码密钥，从而使系统暴露于中间机器(MITM)攻击之下。例如，CVE-2020-9544涉及没有身份验证的纯HTTP，而CVE-2020-25233则来自使用硬编码的RSA密钥进行通信。移动应用程序也可能与固件服务器或设备进行不安全的通信，如CVE-2018-3928所示，其中通信安全检查不足可能导致代码执行漏洞。重要的是，主要问题不仅仅是通信通道，还包括缺乏适当的安全验证。例如，即使泄露了通信密钥，如果有一个健壮的固件验证机制，就可以防止在更新期间恶意替换固件。

*结论2*:固件交付安全性主要依赖于通信通道和设备用户/维护者。如果其中一个是不安全的，设备可能会收到受损的固件，除非适当的设备上验证到位。

**验证阶段**。验证阶段确保接收到的固件的真实性、完整性、新鲜度和兼容性。具体而言，更新代理在将镜像存储到持久存储器之前执行一系列验证程序:通过验证固件的数字签名来确保固件的真实性;固件完整性通过检查清单中包含的摘要来验证;通过检查元数据以及清单中的版本和设备ID来确认新鲜度和兼容性。

根据CVE分析，表1列出了常见脆弱枚举(Common Weakness Enumeration, CWE)类别中与固件更新相关的十大漏洞。前8类问题占47.67%，主要涉及固件更新的验证缺失或验证方法不当。这些问题可以使攻击者在更新期间用恶意固件替换良性固件。例如，CVE-2018-10988的问题源于用于固件更新的shell脚本中缺乏数字签名验证。缺少或不正确的完整性验证可能导致固件损坏。例如，使用易于绕过的内部校验和进行固件完整性检查是有问题的(例如，CVE-2018-5441)。缺少或不正确的新鲜度验证可能导致固件降级攻击，而不充分的兼容性验证可能导致设备遭受DoS攻击。例如，CVE-20183891的根本原因是执行版本验证时的逻辑缺陷，其中整数比较运算符被错误地用于字符串比较。同样，在CVE-2020-10831的情况下，由于验证不足，可能会安装任意固件。

![](2024-USENIX-Your%20Firmware%20Has%20Arrived-A%20Study%20of%20Firmware%20Update%20Vulnerabilities/image-20231215193408384.png)

*结论3*:验证程序中任何步骤的缺失或不当实施都可能导致在嵌入式设备上安装意外的固件。

**安装阶段**。安装阶段是安装和执行新固件的过程。经过验证后，新的固件存储在设备的持久内存中，并在重新启动时激活。具体来说，当设备启动时，引导加载程序首先将新的固件映像移动到设备内存中的右偏移位置。然后，引导加载程序在进行固件检查后执行新的固件映像。然而，这种检查通常是不完整和不安全的，通常依赖于内部校验和[46]。

这一阶段的大多数漏洞都是典型的软件错误，例如命令注入和内存损坏错误。具体来说，在此阶段执行的固件更新相关命令可能接受来自用户输入的参数。如果攻击者操纵这些参数并随后被易受攻击的函数(例如system, strcpy)使用，则可能导致命令注入(例如CVE-2019-5155)或内存损坏(例如CVE-2021-22675)攻击。

*结论4*:在固件安装期间，引导加载程序中不完整的固件检查过程很常见，因此使固件更新的安全性依赖于更新代理中的验证机制。

**总结**。在固件更新过程的任何阶段都可能出现安全漏洞。尽管如此，由设备更新代理提供的健壮的固件验证机制可以减轻源自其他阶段的大多数漏洞。因此，我们的研究主要集中于识别验证阶段中的漏洞。

## 3.威胁模型与概述
**威胁模型**。ChkUp旨在发现基于操作系统的固件(与文件系统集成)中的固件更新漏洞，特别是在主流的基于linux的固件中[69]。它可以检测最常见的固件更新漏洞，包括缺失或不正确的真实性、完整性、新鲜度和兼容性验证。与现有研究[19,34,36,59,83]一致，我们假设没有固件源代码访问，使ChkUp成为基于二进制的漏洞检测方法。ChkUp的潜在用户可能是寻求通知供应商的安全研究人员，或者试图获取有关其设备的额外安全信息的最终用户。甚至可以访问源代码的供应商也可以从中受益，特别是在调查漏洞的可利用性方面，因为源代码分析可以忽略二进制和运行时级别的细节。值得注意的是，与入侵检测系统或恶意软件检测器类似，深入的领域专业知识在进一步改进警报方面证明是有价值的。

**ChkUp概述**。ChkUp的高级思想是从固件代码库中静态地提取固件更新程序的执行路径，并根据总结的漏洞模式，在这些路径上精确定位潜在的漏洞。然后，执行动态漏洞验证，以减少错误警报。然而，正如第1节所讨论的，要实现这个想法，需要解决三个主要挑战:*C1.更新路径存在多样的程序*，*C2.验证程序识别*来匹配漏洞模式，和*C3.漏洞验证*以减少错误警报。为了应对这些挑战，我们提出了ChkUp(如图3所示)。具体地说，为了解决C1问题，我们首先创建了一个UFG，该UFG捕获用不同编程语言编写的程序之间的控制流信息。接下来，我们执行向后程序切片以确定固件更新执行路径(第4.1节)。为了解决C2问题，我们提取语法和结构特征用于功能匹配，然后使用更复杂的DFG同构来识别固件更新执行路径中的验证链(第4.2节)。通过执行路径和相关的验证过程，我们根据定义的标准检查它们以发现漏洞(第4.3节)。最后，我们通过基于补丁的方法解决C3问题，其中在通过补丁绕过其执行依赖关系后，使用生成的poc对易受攻击的过程进行测试(第4.4节)。

![](2024-USENIX-Your%20Firmware%20Has%20Arrived-A%20Study%20of%20Firmware%20Update%20Vulnerabilities/image-20231215194939343.png)

## 4 . ChkUp的设计
### 4.1 执行路径恢复
**UFG定义**。Karonte[59]中的二进制依赖图(binary dependency graph, BDG)可以对固件映像中二进制文件之间的数据依赖关系进行建模，这对于固件更新漏洞检测至关重要。然而，准确的固件更新执行路径恢复需要额外的信息，包括控制流、IPC和不同语言程序之间的程序调用，以确定固件更新相关程序的进程内和进程间控制流。因此，在BDG的基础上，我们引入UFG来适应这些需求。用G表示的UFG是一个有向图，它在固件更新相关程序的基本块(BB)级别捕获进程内和进程间控制流信息。UFG定义为G = (V,E)，其中V是从固件更新过程中涉及的前端程序、脚本和二进制文件中提取的一组BB。E表示BB之间的有向边，每条边E∈E表示为E = ([v1, p1]，[v2, p2]， c)。这表明程序p1中的BB v1与程序p2中的BB v2传输执行流或共享数据，c是表示边类型的标志:c为0表示进程内控制流边，c为1表示IPC关系，c为2表示程序调用关系。

**更新入口查找**。接收固件通常是设备端更新过程的第一步。因此，UFG中的入口节点是负责此任务的节点，包含此入口节点的程序称为入口程序。对于包含基于web的更新界面的固件，入口程序可以是前端固件上传实用程序。为了识别入口程序，我们使用静态模式匹配方法。这是非常重要的，因为不同厂商的固件更新机制差异很大。为了解决这个问题，我们手动分析了许多固件映像(详细信息请参见附录B.2)，并识别出区分固件更新入口程序与其他程序的不同模式。具体来说，这样的入口程序总是包含可识别的代码模式。例如，上传固件映像的前端程序可能使用\<input type="file"...>模式，而下载固件映像的脚本或二进制文件可能使用wget…模式。此外，入口程序经常显示提示信息，其中包含常见的信息词，以及与固件更新相关的函数和变量名(例如，fw_version和fw_upload)。在这些观察的基础上，我们将匹配最多预定义模式的程序作为入口程序。

**跨语言控制流分析**。识别输入程序后，下一步是找到处理接收到的固件映像的程序。这些程序可以采用不同的形式，例如二进制文件和shell脚本[48]。为了全面了解固件更新期间执行的程序的控制流，跨语言控制流分析是必要的。然而，目前基于路径探索的漏洞检测方法[19,59]缺乏这种能力。为了应对这一挑战，我们解释了固件更新中用于构建UFG的各种常用的程序类型(即HTML与JavaScript、shell脚本和二进制)的控制流逻辑、IPC范式和程序调用范式。具体而言，我们构建了入口程序的调用图(CG)和过程间控制流图(CFG)，并确定了入口程序中的IPC(即套接字、文件、信号、环境变量、NVRAM和共享内存)和程序调用范式。请注意，支持的程序类型和IPC范例是由我们初步的手动固件分析确定的，它们的通用性是通过使用大量固件映像进行经验测量的。然后，创建从属边，表示入口程序和其他相关程序之间的控制依赖关系。该过程以递归的方式重复，其中构建每个新添加的程序的CFG，并确定IPC和程序调用范例。清单1通过发现IPC范例(nvram)和程序调用范例(eval)说明了两个程序之间的连接。一旦没有找到更多与更新相关的程序，则完成UFG构建。

![](2024-USENIX-Your%20Firmware%20Has%20Arrived-A%20Study%20of%20Firmware%20Update%20Vulnerabilities/image-20231215201228883.png)

**函数级后向切片**。有了构建好的UFG，下一步是使用功能级向后程序切片确定固件更新过程的可能程序执行路径。通常，固件更新过程以重新启动以执行新固件结束。因此，我们在UFG中定位对重启函数的调用，特别是那些触发重启二进制文件的调用，并将它们设置为向后切片的目标。向后切片遵循程序内部和跨程序的过程间控制流，以确定从固件接收函数开始到重新启动函数结束的所有可能的执行路径。这些路径表示潜在的固件更新执行路径。然而，与任何基于路径的勘探分析一样，这种执行路径恢复方法可能会遇到路径爆炸和路径缺失的问题。我们使用五种策略来处理路径爆炸，包括跳过标准库、跳过内置实用程序、使用超时、使用提示过滤路径和合并路径。有关这些策略的进一步详情，请参阅附录A.1。

### 4.2 验证程序识别
**两阶段方法概述**。关键函数是固件验证中使用的函数，例如用于完整性验证的哈希函数。我们的手工分析显示，验证过程经常使用一组相似的关键功能，因为它们都试图完成一组相似的功能。此外，函数中的值，无论是作为返回变量还是作为引用传递参数，都经常流入条件表达式。然后，这些表达式影响采用哪个条件分支。在验证固件完整性时可以看到一个示例:在条件表达式中使用哈希函数的返回值来确定验证结果，如清单2所示。为了识别验证过程，我们从常见的关键函数构造了一个函数签名语料库。接下来，我们分两个阶段从执行路径中识别验证过程:高效的函数相似度匹配，快速过滤掉不相关的函数;验证程序链识别，其中我们使用先进的语义分析来精确识别。

![](2024-USENIX-Your%20Firmware%20Has%20Arrived-A%20Study%20of%20Firmware%20Update%20Vulnerabilities/image-20231217212608263.png)

**高效函数相似度匹配**。第一阶段的目标是通过对具有语法和结构特征的函数进行排序来提高验证过程链识别的效率。Kim等人[39]表明，使用数字语法和结构特征可以有效地达到与更复杂的基于深度学习的方法相当的精度。因此，选择数字特征的组合(见附录A.2中的表4)有两个原因:1)这些特征可以有效地提取，而不需要复杂的语义代码分析;2)这些特性的组合可以实现高判别能力，同时在不同的体系结构、编译器类型和代码剥离中具有鲁棒性。值得注意的是，编译器优化对这些特性的影响在嵌入式系统中变得不那么显著，在嵌入式系统中，通常使用稳定的和行业标准的编译器选项，从而确保特性的健壮性。具体来说，我们从代码的中间表示(IR)中获得语法特征，包括其抽象语法树(AST)中的属性，如函数调用的数量和键字符串。结构特征来自cfg，包括BB数、边数和分支数。使用这些提取的特征，根据其特征值的相对差异计算执行路径中的函数与语料库中的函数之间的相似度得分[39]。这些分数通过优先考虑具有较高相似性分数的函数来提高第二阶段的效率。相似分数低于特定阈值(在本工作中为0.5)的函数对由于相似度低而被过滤。关于提取的特征、相似度分数的数学构造和相似度分数阈值确定的更多细节可在附录A.2中找到。

**验证程序链识别**。数据流图(data-flow graph, DFG)可以表示数据与算术和逻辑运算之间的关系，用于密码原语识别技术[47,51]。为了通过精确的语义分析进一步识别关键函数，我们采用了DFG子图同构。除了函数语义外，还考虑了关键函数的返回变量和引用传递参数的使用模式，以降低验证过程匹配的FPs。关键函数的返回变量或参数通常提供给条件表达式。然后，该表达式确定要执行的条件分支，并指示验证过程的通过或失败状态。清单2中可以看到一个示例，其中使用函数md5_verify_digest的返回变量来确定完整性验证是否通过。

我们从所有执行路径中搜索验证过程链。对于每个执行路径，依次确定各种类型的验证过程。为了识别验证过程，例如真实性验证，我们首先选择一个相似度得分最高的函数对(f, f')，其中f来自执行路径，f'是语料库中真实性验证的关键函数。然后，对函数f的DFG进行构造和规范化，以保留其底层语义，同时消除由开发人员、编译器优化或机器代码翻译引入的变化。通过DFG，我们可以使用Ullmann算法[71]，在f的DFG中寻找与f'的图签名同构的子图，从而验证函数f和f'是否在功能上等价。如果找到匹配项，则认为函数f在语义上等同于函数f'。然后对f的返回变量和引用传递参数执行到达定义分析，以获得数据流切片。如果返回变量或参数流入条件表达式，则认为验证过程已确定。如果没有找到匹配，则继续使用具有下一个最高相似度分数的函数对，除非没有剩余的函数对超过相似度分数阈值。在第二阶段完成后，所有执行路径中的验证过程链都被确定，并准备进行进一步检查。

**语料库创建**。关键函数要么是标准库函数，要么是专有函数。负责真实性和完整性检查的函数通常封装来自成熟库的标准加密例程[85]。为此，我们从嵌入式系统中常用的库中收集开源加密函数。尽管用于新鲜度和功能检查的功能通常是专有的，但根据我们的分析，它们在同一设备系列中具有相似性。这些是通过对不同主要供应商的固件映像进行逆向工程获得的。我们将所有函数分为两类:采用适当加密算法或评估受保护验证信息的函数和不采用适当加密算法或评估受保护验证信息的函数(详见4.3节)。下一阶段涉及提取函数签名，它由特征向量和图表示组成。特征向量是通过句法和结构分析得到的，图形表示是通过构造、归一化和剪枝DFG生成的。规范化用于消除冗余的节点和边缘，然后修剪以删除与验证过程无关的元素。这种方法在现有研究中经常使用[47,51,78]，确保在各种可能的实现中实现准确的功能匹配。具体地说，这个过程需要精确地指出持有基本验证数据的变量或参数。将这些节点设置为目标后，执行程序切片以维护所有相关节点和边。有关更详细的语料库统计，请参阅附录A.3。

### 4.3 漏洞发现
**漏洞发现标准**。重点检查产品真实性、完整性、新鲜度、兼容性四种属性验证程序的执行偏差。尽管缺乏验证是大多数验证阶段漏洞的原因，但验证过程的不当实现也可能导致不安全或可利用的验证过程。在我们的工作中，不正确的真实性验证的主要问题来自对称加密算法的使用(例如，HMAC, CMAC, Poly1305)。同样，我们发现不正确的完整性验证的根本原因往往在于使用弱摘要验证算法，如CRC、SHA1和MD5。最后，对于新鲜度和兼容性验证，我们的工作强调，当验证信息(包括固件版本和兼容设备ID)从未受保护的数据源(例如固件映像的文件名)中提取时，验证可能是不安全的。

**漏洞发现过程**。我们通过检查执行路径和相关的验证过程来识别漏洞。如果固件映像只包含一个执行路径，我们将重点关注该路径。对于具有多个路径的固件，我们选择具有最适当验证程序的路径，因为这通常表示彻底验证。该策略可以减少FPs，确保更保守的漏洞识别。接下来，根据先前定义的标准在唯一或选择的路径上执行漏洞检测。具体来说，为了识别缺失的验证漏洞，我们检查执行路径中验证过程的真实性、完整性、新鲜度或兼容性的缺失。为了检测不适当的验证漏洞，我们检查在执行路径中相应的验证过程中使用了不适当的函数。值得注意的是，一些固件映像使用弱算法执行快速完整性检查，然后基于数字签名/MAC算法对真实性和完整性进行更彻底的验证。只有在相应的数字签名/MAC中使用的摘要算法也是不安全的情况下，我们才会报告不正确的完整性验证警报。

### 4.4 漏洞验证
**PoC创建**。我们动态地验证警报，方法是提供一个PoC输入，该输入明确违反了测试中的安全属性，并观察固件更新过程是否仍然到达重新启动阶段。如果存在，则存在漏洞;如果不是，则警报是FP。PoC镜像根据警报类型而变化，如表2所示。例如，为了验证缺失的兼容性验证，我们用来自同一设备系列的不兼容版本替换良性固件。然而，这个过程也可能改变其他属性，使根本原因分析复杂化。例如，选择的固件映像也可能包含不正确的版本号。为了缓解这个问题，ChkUp修补并重新打包测试固件，以使验证过程的执行路径与被测属性保持一致。

**补丁生成**。我们打补丁是为了跳过可能妨碍对测试中的特定属性进行漏洞验证的验证过程。根据程序类型，在源代码或二进制级别进行修补。通常，我们不需要添加额外的代码就可以反转条件表达式，本质上是改变对其对立面的比较(例如，等于不等于)。附录A.4中的清单4给出了TP-Link固件映像的兼容性验证过程的反汇编和反编译代码。这个过程使用getProductVer()函数获取当前产品ID，并从新固件的文件体中提取兼容的产品ID。ID比较由一条bne(如果不相等则为分支)指令执行。为了绕过PoC固件的这种验证，我们可以用beq指令代替bne。尽管大多数验证过程使用直接的条件表达式，但有些验证过程包含涉及各种逻辑运算符和多个变量的复杂条件，其中一些仅在运行时才知道。这种复杂性使得像否定比较这样的简单方法无效。为了解决这个问题，我们首先使用良性映像进行一次成功的固件更新，并记录条件表达式中涉及的变量的值。接下来，我们执行静态价值流分析，从这些变量向后跟踪，以确定定义其值的指令。我们的研究表明，这些指令通常在同一功能中，从而避免了复杂的控制流恢复[66]。最后，对于记录的值和已识别的指令，我们采用就地二进制重写技术[43]来利用先前记录的值，同时包括条件以确保替换仅适用于感兴趣的固件执行阶段。

## 5.实现
ChkUp的原型支持跨各种体系结构(包括ARM、MIPS和PowerPC)的基于linux和其他嵌入式基于os的固件映像(配备了文件系统)。具体来说，执行路径恢复模块有效地为每个固件映像在300秒超时内构建一个UFG，使用NetworkX将每个UFG表示为一个图[13]。使用angr[66]等工具[22,61,66]分析各种程序的控制流。IPC和程序调用范例是基于KARONTE[59]中的CPF模块确定的，该模块扩展为支持JavaScript和shell脚本。在构造UFG之后，使用NetworkX的Simple Paths模块在功能级进行执行路径恢复。在验证程序识别模块中，从源代码(特别是JavaScript和shell脚本)、CFG以及反汇编和反编译代码(利用Ghidra[14])中提取数字特征。在使用Meijer等[51]的归一化规则构造DFG并对其进行归一化后，采用Ullmann算法对DFG子图同构进行识别验证程序。漏洞发现模块基于前两个模块，并使用所描述的标准和流程执行漏洞发现。在Vulnerability Validation模块中，最初使用Firmadyne[18]进行动态分析，如果仿真不成功，则使用更高级的FirmAE[42]。此外，使用Ghidra和firmware-mod-kit[11]来修补和重新打包固件映像。

## 6.评估
在本节中，我们评估了ChkUp的三个关键模块的有效性，即执行路径恢复(第6.1节)、验证程序识别(第6.2节)和漏洞验证(第6.3节)。

**数据集**。我们从物联网供应商的网站上收集了157,141个固件映像，并成功解包了其中的111,958个。为了进行大规模分析，我们从8个主要供应商(包括Netgear、TP-Link、D-Link、TRENDnet、Asus、Ubiquiti、Zyxel和Linksys)随机抽取12000个固件图像，创建了一个数据集DL。为了评估ChkUp的有效性并验证其警报，通过从DL中采样创建了一个基础事实数据集DG。DG中固件映像的ground truth的构建由四位安全专家通过手工分析完成。关于数据集构建和手工分析的详细信息，请参见附录B.1和附录B.2。

**实验环境**。在一台安装了Ubuntu 18.04 LTS操作系统和AMD EPYC 7302P CPU和64GB RAM的服务器上进行了评估。

...
## 7.漏洞发现结果
...
### 7.3 案例研究
清单3显示了来自Netgear wnr系列路由器的固件映像中的固件验证流。这些设备为手动固件更新提供了一个web界面。在界面的前端，如upgrade.js的第3行到第10行所示，通过检查上传文件的文件名来验证兼容性和新鲜度，我们已经确定了这种方法是脆弱的。通过这些验证后，后端shell脚本webupgrade.sh进行进一步验证。从webuupgrade.sh的第2行到第6行，检查固件头以确保兼容性。因此，只要保证固件的完整性，就可以保证兼容性。完整性验证在webupgrade.sh(参见第7行到第10行)中通过二进制mychecksum进行。检查后，mychecksum使用弱CRC算法进行验证。值得注意的是，没有真实性验证。因此，这些易受攻击的验证过程使固件更新机制容易受到现实世界的攻击。

![](2024-USENIX-Your%20Firmware%20Has%20Arrived-A%20Study%20of%20Firmware%20Update%20Vulnerabilities/image-20231217214030547.png)

**现实世界的利用**。我们通过制作两个exploits来展示这些漏洞的可利用性，特别是固件降级攻击和固件修改攻击，针对Netgear wnr系列路由器。在这些攻击场景中，攻击者和目标设备共享同一个网络环境。如果固件传递的通信使用未加密的HTTP，攻击者可以直接访问固件更新接口，也可以嗅探网络并发起MITM攻击。值得注意的是，在我们初步的手动固件分析期间，我们发现大量公共固件映像缺乏用于更新接口的TLS，这突出了这些攻击在现实世界中的可行性。

*A1.固件降级攻击*:由于固件新鲜度是通过检查上传文件的文件名来确定的，攻击者可以通过更改文件名中的版本字段来匹配合法的版本，从而使用旧固件映像来制作恶意固件映像。然后，他们可以通过web界面上传恶意固件镜像，也可以通过MITM替换良性固件镜像。随后，固件被替换为具有漏洞的不安全遗留版本，这些漏洞可以被进一步利用。

*A2.固件修改攻击*:由于固件完整性校验基于CRC校验和，攻击者可以在保持校验和值一致的情况下创建修改后的固件镜像。但是，有些字段(例如用于兼容性验证的报头中的设备ID)需要保持不变，以确保其他验证过程顺利进行。攻击者可以通过与固件降级攻击相同的方式将恶意固件引入设备。对于这种攻击，如果恶意固件精心制作，则可以引入各种进一步的攻击，包括后门、恶意软件和DoS攻击。

## 8.讨论
## 9.相关工作
## 10.结论
在本文中，我们提出了ChkUp，一种检测固件更新漏洞的新方法，包括在更新期间缺少和不正确的验证。具体来说，ChkUp通过跨语言的进程间控制流分析和程序切片来解析固件更新的执行路径。然后，通过语法、结构和语义程序分析确定固件验证过程。这些过程以及相应的执行路径将根据我们定义的标准进一步检查，以检测漏洞。为了减少误报，使用基于补丁的方法动态验证可仿真固件映像的警报，而其他警报则手动验证。ChkUp实现并用于分析12,000个固件映像，随后对来自33个设备系列的150个固件映像进行警报验证。结果表明，ChkUp可以识别零日漏洞和n日漏洞，导致分配25个CVE ID和1个PSV ID。

## A 附加设计细节
### A.1 路径爆炸减少
ChkUp采用了五种路径爆炸减少策略。在构建ufg时应用前三个，在向后切片时应用后两个。1)排除非加密标准库:在UFG构建中省略标准库以降低复杂性，但加密库除外，用于漏洞识别，不会显著增加UFG的复杂性。2)省略内置实用程序:在固件更新期间，执行已知的内置实用程序(例如，mtd, reboot)，从而消除了对控制流分析的需要。3)实现超时:如果UFG生成需要过多的时间，超时策略会限制UFG的复杂性和FP路径的包含。4)应用路径过滤:根据固件更新失败导致设备重启的错误消息进行过滤，细化执行路径。5)路径合并:后向切片，将具有相同验证过程和节点的路径合并为语义等价的路径。

### A.2 函数相似度匹配
...


