---
title: 2024-USENIX-Your Firmware Has Arrived-A Study of Firmware Update Vulnerabilities
date: 2023/12/15
categories:
  - 论文
tags:
  - 论文翻译
  - USENIX
---
# 2024-USENIX-Your Firmware Has Arrived-A Study of Firmware Update Vulnerabilities
## 基本信息
题目：你的固件已经到达:固件更新漏洞的研究

![](2024-USENIX-Your%20Firmware%20Has%20Arrived-A%20Study%20of%20Firmware%20Update%20Vulnerabilities/image-20231215164038033.png)

## 摘要
嵌入式设备在我们的社会中越来越普遍。固件更新是减轻嵌入式系统漏洞的主要机制之一。然而，固件更新过程也引入了新的攻击面，特别是通过易受攻击的固件验证过程。与内存损坏错误不同，固件更新中的许多漏洞源于不完整或不正确的验证步骤，而现有的固件分析方法不适用于此。为了弥补这一差距，我们提出了ChkUp，一种检查固件更新漏洞的方法。ChkUp可以通过跨语言的进程间控制流分析和程序切片来解析固件更新过程中的程序执行路径。通过这些路径，ChkUp定位固件验证过程，检查和验证其漏洞。我们实现了ChkUp，并对12,000个固件映像进行了全面分析。然后，我们在来自33个设备系列的150个固件映像中验证了警报，从而发现了零日和n日漏洞。我们负责地披露了我们的发现，在撰写本文时分配了25个CVE ID和1个PSV ID。

## 1.引言
嵌入式设备的快速增长，从智能手表等便携式设备到交通工具等大型机器，为我们的生活带来了更多的连接和便利。预计到2025年，嵌入式设备的市场规模将达到1162亿美元[10]。固件更新在修复漏洞和改进功能方面起着重要的作用。然而，实现不佳的固件更新机制可能会削弱这种优势，甚至引入新的攻击面。事实上，与软件更新相关的漏洞已经被认为是嵌入式设备的五大安全风险之一[12]。

**固件更新安全**。软件或固件更新是目前对抗网络攻击最有效的技术之一。然而，随着现代嵌入式系统连接性和复杂性的增加，越来越多的网络攻击专门针对固件更新过程，允许攻击者执行任意代码或回滚固件版本以暴露先前的漏洞[21,70]。最近Jeep Cherokee[52]、Samsung SmartThings Hub[8]和Asus Router[9]更新机制中的漏洞引起了人们的极大关注，凸显了自动识别固件更新漏洞的必要性。现有的固件漏洞检测方法通常侧重于识别用户控制输入对不安全sinks的调用[19,25,27,59,65]，或者使用常见的漏洞模式或已知规范的偏差来查找漏洞[24,33,49,50,64]。然而，固件更新漏洞构成了一个独特的挑战，因为它们通常来自跨多阶段更新过程的问题组合，由于缺乏全面的规范或系统的易受攻击模式分类而加剧。为了更好地了解固件更新漏洞的情况，我们对过去十年中与固件更新相关的CVE进行了分类和系统化。每种类型的漏洞都被放置在一般固件更新过程的不同抽象阶段，这在第2节中有详细介绍。

**我们的解决方案**-ChkUp。在本文中，我们提出了ChkUp，一种检查固件更新漏洞的新方法，包括缺少验证(例如缺乏版本检查)和不适当的验证(例如，使用MD5进行完整性检查)。直观地，ChkUp提取固件更新过程的程序执行路径，然后识别更新过程中的验证步骤链。然后，我们总结了多个固件更新阶段的漏洞模式，以进行漏洞检测。在进行此工作时，我们发现固件更新机制的现有实现存在独特的挑战，需要新技术。具体来说，有三个主要的技术挑战:

*C1.支持固件更新的多种系统组件*：在许多基于linux的固件映像中，各种类型的程序，如前端程序、脚本和二进制文件，被调用在软件更新执行路径中，跨越Web服务器的前端和后端。此外，固件更新中涉及的组件的多样性导致进程间通信(IPC)机制的异质性。为了应对这些挑战，我们开发了生成流程间更新流图(UFG)的技术。首先使用在固件更新过程中连接前端和后端的通用代码模式和语义信息来识别输入(entry)程序。然后，通过连接各个程序(即前端程序、脚本和二进制文件)的控制流并解析相应的IPC来提取跨语言控制流。有了这样一个跨语言、跨程序的控制流图，固件更新的执行路径可以使用带有固件更新特定语义的向后程序切片来解决。

*C2.验证程序识别*：固件更新是一个复杂的过程，包括各种检查和验证，从加密签名的验证到版本和设备ID的比较。只有当每个验证步骤(例如，签名验证或符合版本更新策略)及其组成得到适当实现时，更新过程才被认为是安全的。然而，固件更新没有标准化的规范，并且通常用多种编程语言实现。这导致了不同的验证实现，使得从执行路径中的众多功能中识别它们变得具有挑战性。为了应对这一挑战，ChkUp使用基于同构的数据流图(DFG)语义相似度匹配来识别固件验证过程。为了减少这个过程的开销，执行路径中的函数首先按照相似度评分进行排序，该评分是使用语法和结构特征计算的。然后，具有较高相似性分数的函数有限进行DFG同构的分析。

*C3.漏洞验证*：静态分析可能产生许多误报(FP)，这需要进一步的验证。但是，固件更新过程通常涉及一系列验证步骤，每个步骤都有其独特的功能和调用参数。为了测试链中后面的步骤，有必要创建能够通过前几个步骤的输入和环境。为了简化验证，我们提出了一种半自动的动态方法来验证可仿真固件映像的警报。具体来说，我们采用固件补丁来确保潜在的易受攻击程序的执行，然后根据输入恶意固件映像后的更新行为检查相应警报的有效性。

评价和发现。为了更深入地了解野外的漏洞，我们在12,000个固件映像上运行ChkUp。我们发现，弱验证算法，如使用MD5进行完整性验证，是普遍存在的。然后，我们对随机选择的150个固件映像进行漏洞验证:对于可仿真的固件映像，我们通过创建poc进行动态验证;对于其余的固件映像，我们进行了手动分析以验证它们的警报。我们的结果显示，真阳性率(TPR)为86.7%，假阳性率(FPR)为5.3%，导致在33个设备系列的固件映像中发现零日漏洞和n日漏洞。这些发现被负责地披露，并分配了25个CVE ID和1个PSV ID。最后，为了演示漏洞的可利用性，我们展示了固件降级和固件修改攻击。

**贡献**。我们的贡献概述如下:

- *固件更新安全的系统化*:我们将一般固件更新过程分为四个阶段，并通过分析和分类381个固件更新相关的CVE报告来检查每个阶段的安全问题。
- *更新漏洞检测的新方法*:我们提出了一种新的固件更新漏洞识别方法ChkUp，该方法解决了三个技术挑战:更新路径中的不同组件、验证过程识别和漏洞验证。
- *真实固件中的漏洞*:我们在12,000个固件映像上运行ChkUp，并使用概念验证(PoC)生成和手动分析相结合的方法验证其中150个固件的警报。结果证明了ChkUp识别零日漏洞和n日漏洞的能力。经过负责任的披露，已经分配了25个CVE ID和1个PSV ID。

## 2.固件更新安全系统化
### 2.1 固件更新挑战
为了更好地了解威胁形势，我们分析了过去十年中381个与固件更新相关的CVE，然后进行了系统化。虽然大多数CVE源于易受攻击的固件更新机制，但其他CVE只是对更新的安全性产生影响。图1显示了自2015年以来通用漏洞评分系统(CVSS) v3指标的年度分布。这一数字呈稳定增长趋势，从2020年到2021年，CVE的数量将翻一番。高、重度漏洞是低、中度漏洞的近4倍。这一增长不仅归因于CVE不断增加的总体趋势，还归因于嵌入式系统特有的新挑战[15,30,62,72 - 74,84,86]。这些挑战包括:1)由于连接性的增加，攻击面不断扩大;2)嵌入式系统的复杂性增加;3)产品生命周期长;4)嵌入式设备上的资源有限。这些因素导致了固件更新机制的多样化和漏洞的增加。

### 2.2 更新工作流和漏洞
典型的固件更新工作流有四个阶段，如图2所示:生成、交付、验证和安装。

![](2024-USENIX-Your%20Firmware%20Has%20Arrived-A%20Study%20of%20Firmware%20Update%20Vulnerabilities/image-20231215185954179.png)

**生成阶段**。生成阶段的目标是创建固件映像并使其可用。具体来说，作者首先开发了一个新的固件映像和一个清单。清单包含固件元数据，包括固件摘要、版本和设备ID。随后，使用数字签名对固件映像和清单进行签名，然后通过软件供应链将其传输到固件服务器。通常，作者通过在供应链中受信任方将固件上传到服务器。

在此阶段，外部攻击者可以进行供应链攻击以窃取证书并危害软件开发工具或基础设施。此类攻击的根本原因是对关键资产和基础设施的访问控制不当。近年来，越来越多的供应链相关漏洞被报道，这表明它们对现实世界的安全影响。报告显示，2020年，美国政府以及微软、英特尔和火眼等3万多家公共和私营组织遭受了大规模的软件供应链攻击，称为SolarWinds黑客攻击[55]。具体来说，网络犯罪分子入侵了Orion的IT管理软件，然后通过供应链向用户分发包含后门的恶意软件更新。

*结论1*:供应链漏洞带来了重大风险，通常来自不充分的访问控制。如果没有适当的设备上验证，受损的固件可能会安装在设备中，导致对设备的控制丧失。

**交付阶段**。交付阶段包括将新的固件映像从服务器传输到目标设备。一个固件组件，称为更新代理[46]，负责下载、验证和在持久内存中存储新映像。通常，新固件可以通过三种方式交付：1)固件服务器直接将固件和清单推送到设备的更新代理;2)更新代理轮询更新并在更新可用时下载更新;3)固件服务器通知设备用户/维护人员，设备用户/维护人员手动下载并上传更新到更新代理。在通信通道方面，常用的方法包括应用层协议(如HTTP、FTP)、无线媒体(如Wi-Fi、低功耗蓝牙)和物理接口(如USB、可移动存储卡)。对于一些低端的裸机设备，智能手机上的配套应用程序可以帮助进行固件更新。新的固件既可以捆绑在应用程序内部，也可以通过应用层协议从固件服务器获取。然后，这些应用程序通常通过无线媒体与设备通信，以进行通知、轮询和下载。值得注意的是，虽然应用程序充当传输固件的中介，但它们也可能预先验证更新。这样的早期验证可以过滤掉无效的更新，以避免不必要的后续设备上处理。

安全的通信通道对于交付的固件映像的机密性和完整性非常重要。不安全的交付主要源于缺乏加密协议或使用硬编码密钥，从而使系统暴露于中间机器(MITM)攻击之下。例如，CVE-2020-9544涉及没有身份验证的纯HTTP，而CVE-2020-25233则来自使用硬编码的RSA密钥进行通信。移动应用程序也可能与固件服务器或设备进行不安全的通信，如CVE-2018-3928所示，其中通信安全检查不足可能导致代码执行漏洞。重要的是，主要问题不仅仅是通信通道，还包括缺乏适当的安全验证。例如，即使泄露了通信密钥，如果有一个健壮的固件验证机制，就可以防止在更新期间恶意替换固件。

*结论2*:固件交付安全性主要依赖于通信通道和设备用户/维护者。如果其中一个是不安全的，设备可能会收到受损的固件，除非适当的设备上验证到位。

**验证阶段**。验证阶段确保接收到的固件的真实性、完整性、新鲜度和兼容性。具体而言，更新代理在将镜像存储到持久存储器之前执行一系列验证程序:通过验证固件的数字签名来确保固件的真实性;固件完整性通过检查清单中包含的摘要来验证;通过检查元数据以及清单中的版本和设备ID来确认新鲜度和兼容性。

根据CVE分析，表1列出了常见脆弱枚举(Common Weakness Enumeration, CWE)类别中与固件更新相关的十大漏洞。前8类问题占47.67%，主要涉及固件更新的验证缺失或验证方法不当。这些问题可以使攻击者在更新期间用恶意固件替换良性固件。例如，CVE-2018-10988的问题源于用于固件更新的shell脚本中缺乏数字签名验证。缺少或不正确的完整性验证可能导致固件损坏。例如，使用易于绕过的内部校验和进行固件完整性检查是有问题的(例如，CVE-2018-5441)。缺少或不正确的新鲜度验证可能导致固件降级攻击，而不充分的兼容性验证可能导致设备遭受DoS攻击。例如，CVE-20183891的根本原因是执行版本验证时的逻辑缺陷，其中整数比较运算符被错误地用于字符串比较。同样，在CVE-2020-10831的情况下，由于验证不足，可能会安装任意固件。

![](2024-USENIX-Your%20Firmware%20Has%20Arrived-A%20Study%20of%20Firmware%20Update%20Vulnerabilities/image-20231215193408384.png)

*结论3*:验证程序中任何步骤的缺失或不当实施都可能导致在嵌入式设备上安装意外的固件。

**安装阶段**。安装阶段是安装和执行新固件的过程。经过验证后，新的固件存储在设备的持久内存中，并在重新启动时激活。具体来说，当设备启动时，引导加载程序首先将新的固件映像移动到设备内存中的右偏移位置。然后，引导加载程序在进行固件检查后执行新的固件映像。然而，这种检查通常是不完整和不安全的，通常依赖于内部校验和[46]。

这一阶段的大多数漏洞都是典型的软件错误，例如命令注入和内存损坏错误。具体来说，在此阶段执行的固件更新相关命令可能接受来自用户输入的参数。如果攻击者操纵这些参数并随后被易受攻击的函数(例如system, strcpy)使用，则可能导致命令注入(例如CVE-2019-5155)或内存损坏(例如CVE-2021-22675)攻击。

*结论4*:在固件安装期间，引导加载程序中不完整的固件检查过程很常见，因此使固件更新的安全性依赖于更新代理中的验证机制。

**总结**。在固件更新过程的任何阶段都可能出现安全漏洞。尽管如此，由设备更新代理提供的健壮的固件验证机制可以减轻源自其他阶段的大多数漏洞。因此，我们的研究主要集中于识别验证阶段中的漏洞。

## 3.威胁模型与概述
**威胁模型**。ChkUp旨在发现基于操作系统的固件(与文件系统集成)中的固件更新漏洞，特别是在主流的基于linux的固件中[69]。它可以检测最常见的固件更新漏洞，包括缺失或不正确的真实性、完整性、新鲜度和兼容性验证。与现有研究[19,34,36,59,83]一致，我们假设没有固件源代码访问，使ChkUp成为基于二进制的漏洞检测方法。ChkUp的潜在用户可能是寻求通知供应商的安全研究人员，或者试图获取有关其设备的额外安全信息的最终用户。甚至可以访问源代码的供应商也可以从中受益，特别是在调查漏洞的可利用性方面，因为源代码分析可以忽略二进制和运行时级别的细节。值得注意的是，与入侵检测系统或恶意软件检测器类似，深入的领域专业知识在进一步改进警报方面证明是有价值的。

**ChkUp概述**。ChkUp的高级思想是从固件代码库中静态地提取固件更新程序的执行路径，并根据总结的漏洞模式，在这些路径上精确定位潜在的漏洞。然后，执行动态漏洞验证，以减少错误警报。然而，正如第1节所讨论的，要实现这个想法，需要解决三个主要挑战:*C1.更新路径存在多样的程序*，*C2.验证程序识别*来匹配漏洞模式，和*C3.漏洞验证*以减少错误警报。为了应对这些挑战，我们提出了ChkUp(如图3所示)。具体地说，为了解决C1问题，我们首先创建了一个UFG，该UFG捕获用不同编程语言编写的程序之间的控制流信息。接下来，我们执行向后程序切片以确定固件更新执行路径(第4.1节)。为了解决C2问题，我们提取语法和结构特征用于功能匹配，然后使用更复杂的DFG同构来识别固件更新执行路径中的验证链(第4.2节)。通过执行路径和相关的验证过程，我们根据定义的标准检查它们以发现漏洞(第4.3节)。最后，我们通过基于补丁的方法解决C3问题，其中在通过补丁绕过其执行依赖关系后，使用生成的poc对易受攻击的过程进行测试(第4.4节)。

![](2024-USENIX-Your%20Firmware%20Has%20Arrived-A%20Study%20of%20Firmware%20Update%20Vulnerabilities/image-20231215194939343.png)

## 4 . ChkUp的设计
### 4.1 执行路径恢复
**UFG定义**。Karonte[59]中的二进制依赖图(binary dependency graph, BDG)可以对固件映像中二进制文件之间的数据依赖关系进行建模，这对于固件更新漏洞检测至关重要。然而，准确的固件更新执行路径恢复需要额外的信息，包括控制流、IPC和不同语言程序之间的程序调用，以确定固件更新相关程序的进程内和进程间控制流。因此，在BDG的基础上，我们引入UFG来适应这些需求。用G表示的UFG是一个有向图，它在固件更新相关程序的基本块(BB)级别捕获进程内和进程间控制流信息。UFG定义为G = (V,E)，其中V是从固件更新过程中涉及的前端程序、脚本和二进制文件中提取的一组BB。E表示BB之间的有向边，每条边E∈E表示为E = ([v1, p1]，[v2, p2]， c)。这表明程序p1中的BB v1与程序p2中的BB v2传输执行流或共享数据，c是表示边类型的标志:c为0表示进程内控制流边，c为1表示IPC关系，c为2表示程序调用关系。

**更新入口查找**。接收固件通常是设备端更新过程的第一步。因此，UFG中的入口节点是负责此任务的节点，包含此入口节点的程序称为入口程序。对于包含基于web的更新界面的固件，入口程序可以是前端固件上传实用程序。为了识别入口程序，我们使用静态模式匹配方法。这是非常重要的，因为不同厂商的固件更新机制差异很大。为了解决这个问题，我们手动分析了许多固件映像(详细信息请参见附录B.2)，并识别出区分固件更新入口程序与其他程序的不同模式。具体来说，这样的入口程序总是包含可识别的代码模式。例如，上传固件映像的前端程序可能使用\<input type="file"...>模式，而下载固件映像的脚本或二进制文件可能使用wget…模式。此外，入口程序经常显示提示信息，其中包含常见的信息词，以及与固件更新相关的函数和变量名(例如，fw_version和fw_upload)。在这些观察的基础上，我们将匹配最多预定义模式的程序作为入口程序。

**跨语言控制流分析**。识别输入程序后，下一步是找到处理接收到的固件映像的程序。这些程序可以采用不同的形式，例如二进制文件和shell脚本[48]。为了全面了解固件更新期间执行的程序的控制流，跨语言控制流分析是必要的。然而，目前基于路径探索的漏洞检测方法[19,59]缺乏这种能力。为了应对这一挑战，我们解释了固件更新中用于构建UFG的各种常用的程序类型(即HTML与JavaScript、shell脚本和二进制)的控制流逻辑、IPC范式和程序调用范式。具体而言，我们构建了入口程序的调用图(CG)和过程间控制流图(CFG)，并确定了入口程序中的IPC(即套接字、文件、信号、环境变量、NVRAM和共享内存)和程序调用范式。请注意，支持的程序类型和IPC范例是由我们初步的手动固件分析确定的，它们的通用性是通过使用大量固件映像进行经验测量的。然后，创建从属边，表示入口程序和其他相关程序之间的控制依赖关系。该过程以递归的方式重复，其中构建每个新添加的程序的CFG，并确定IPC和程序调用范例。清单1通过发现IPC范例(nvram)和程序调用范例(eval)说明了两个程序之间的连接。一旦没有找到更多与更新相关的程序，则完成UFG构建。

![](2024-USENIX-Your%20Firmware%20Has%20Arrived-A%20Study%20of%20Firmware%20Update%20Vulnerabilities/image-20231215201228883.png)

**函数级后向切片**。有了构建好的UFG，下一步是使用功能级向后程序切片确定固件更新过程的可能程序执行路径。通常，固件更新过程以重新启动以执行新固件结束。因此，我们在UFG中定位对重启函数的调用，特别是那些触发重启二进制文件的调用，并将它们设置为向后切片的目标。向后切片遵循程序内部和跨程序的过程间控制流，以确定从固件接收函数开始到重新启动函数结束的所有可能的执行路径。这些路径表示潜在的固件更新执行路径。然而，与任何基于路径的勘探分析一样，这种执行路径恢复方法可能会遇到路径爆炸和路径缺失的问题。我们使用五种策略来处理路径爆炸，包括跳过标准库、跳过内置实用程序、使用超时、使用提示过滤路径和合并路径。有关这些策略的进一步详情，请参阅附录A.1。

### 4.2 验证程序识别



## 参考链接

