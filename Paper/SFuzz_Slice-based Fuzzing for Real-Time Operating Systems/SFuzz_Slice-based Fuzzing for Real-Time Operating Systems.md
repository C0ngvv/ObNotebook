

# 翻译
SFuzz:针对实时操作系统的基于片的模糊测试
## 摘要
实时操作系统(RTOS)已成为嵌入式系统的主要类别。它被广泛用于支持需要实时响应的任务，如打印机和交换机。由于RTOS运行在与攻击者隔离的特殊环境中，其安全性长期以来一直被忽视。然而，随着物联网设备的快速发展，大量的RTOS设备接入了公共网络。由于缺乏安全机制，这些设备极易受到各种攻击。更糟糕的是，RTOS的单片设计将各种任务和服务合并到一个二进制文件中，这阻碍了当前在RTOS上工作的程序测试和分析技术。

在本文中，我们提出了一种新的基于切片的模糊器SFuzz来检测RTOS中的安全漏洞。我们的见解是，RTOS通常将复杂的二进制文件分成许多独立但单一的任务。每个任务以确定的方式完成一个特定的事件，其控制流通常是直接和独立的。因此，我们从单片RTOS二进制文件中识别出这样的代码，并合成一个切片进行有效的测试。具体来说，SFuzz首先识别处理用户输入的函数，构造从这些函数的调用者开始的调用图，并利用前向切片来基于调用图构建执行树，并修剪独立于外部输入的路径。然后，它在粗粒度范围内检测并处理阻碍有效模糊测试的障碍，例如与用户输入无关的指令。然后，它对这些代码片段进行覆盖引导的模糊测试。最后，SFuzz利用前向和后向切片来跟踪和验证每个路径约束，并确定在fuzzer中发现的错误是否是真正的漏洞。SFuzz在35个RTOS样本中成功发现了77个零日漏洞，其中67个已被分配CVE或CNVD id。我们的经验评估表明，SFuzz在测试RTOS方面优于最先进的工具(例如，UnicornAFL)。

关键字：RTOS；基于片的模糊测试；污点分析；混合执行

## 1.引言
实时操作系统(RTOS)是为实时应用程序服务而设计的。它已被广泛部署在嵌入式微控制器和cpu之上，安装数量甚至超过了成熟的操作系统。例如，VxWorks，业界领先的RTOS[38]，运行在超过20亿台设备上[33]。RTOS的许多行业场景不仅需要实时、确定性的性能，而且还需要安全认证，如NASA的InSight航天器[24]

然而，由于各种发展限制，将传统的安全机制应用到RTOS中是具有挑战性的。例如，为了支持对实时任务的即时响应，RTOS放弃了内核和用户空间之间的隔离[20]，以平面模式运行所有任务，以避免频繁的上下文切换。在这种情况下，所有软件模块都可以不受限制地访问内存空间中的所有数据和指令[11]，这给RTOS带来了更多的潜在威胁。这种单片设计是可以接受的，因为RTOS主要在本地网络中运行，并且与外部威胁隔离。

如今，物联网(IoT)将更多的RTOS设备直接连接到互联网，这为外部攻击者打开了RTOS设备的大门。在攻击者破坏这些薄弱设备之前，发现RTOS系统中的漏洞是当务之急。尽管许多研究者提出了各种针对嵌入式设备的漏洞检测机制[7,9,21,31,44]，但能够直接应用于RTOS的机制很少。主要原因是RTOS通常以blob-firmware格式呈现，并且在单个单片执行中几乎不运行在微控制器和cpu上，包括内核模块、调度模块和其他任务模块。这个特性给传统的bug检测机制带来了困难。

对于静态分析[9,31]，考虑到单片RTOS二进制文件的大容量，经典的静态方法(例如符号执行[6,10,34])存在路径爆炸问题。此外，由于缺乏显式的函数符号和RTOS的复杂性，很难在二进制级别上揭示函数的语义。因此，我们无法轻易识别与敏感数据相关的模块，也无法对这些模块进行分析。动态解决方案[7,21,37,44]，如模糊测试，要么需要实际设备，要么依赖于正确和稳定的仿真来测试目标固件和基本服务。由于来自不同供应商的RTOS[15,16,38]采用具有不同接口的各种外设，因此用可管理的努力模拟所有现实世界场景是具有挑战性的。

随着RTOS得到越来越多的关注，一些工作开发了定制的工具来检测RTOS中的错误。Zhu等人[45]介绍了一种调试方法来检测基于vxworks的物联网设备的漏洞。Wen等[37]提出在BLE设备上检查裸机固件的配置错误。然而，这些方法要么只能在特定设备上工作，要么依赖于真实设备[45]，要么只能检测到有限的漏洞类型[37]。Salehi等人[32]插桩裸机固件二进制文件来观察内存损坏。Clements等[12]扩展了HALucinator[13]以与VxWorks一起工作。然而，这些工具需要手工分析和领域知识，因此很难应用于不同的RTOS系统。这些工作中的许多甚至需要RTOS的源代码来获得更多的硬件细节[12,13]，或者需要大量的扩展开发来进行有效的模糊测试[32]。因此，它们都受到可伸缩性的限制。总的来说，缺乏一种灵活和通用的方法来有效地发现RTOS中的漏洞。

尽管困难重重，但我们注意到，特定的RTOS特性为绕过测试障碍提供了独特的机会，比如多任务机制。具体来说，RTOS通常将复杂的应用程序划分为许多独立但单一的任务。每个任务以确定的方式完成一个特定的事件。每个原子任务的控制流通常是直接和独立的。更重要的是，如果这些任务属于同一类别，它们的数据流可能具有相似的模式。因此，我们搜索从各种外部数据条目开始到潜在sink函数(例如，memcpy)的数据流，并在RTOS任务之间切片相应的代码片段。这些片段足够小，可以使用现有的模糊测试逻辑进行测试。此外，它们提供了更小但更关键的控制流范围。它可以大大减轻仿真难度和分析复杂性，这将允许我们执行更有效和高效的测试，如灰盒模糊和符号执行。

基于我们的见解，我们提出了SFuzz，这是一种新颖的模糊测试方法，它利用前向切片来构建定制的代码空间，从而在模拟器上驱动灰盒模糊测试。然后，SFuzz结合向后切片来执行concolic执行，以验证来自模糊的崩溃输入。我们设计的SFuzz有四个主要组件:

切片器。我们的代码切片器首先识别处理用户输入的函数。由于RTOS二进制文件没有函数名，我们定义了一组启发式方法来定位这些函数。之后，我们构造一个从这些函数的一个调用者开始的调用图。通过粗粒度传播，我们通过修剪独立于外部输入的路径，在该调用图中执行前向切片。我们还修改了与输入无关的条件分支，以确保控制流达到潜在的sink函数。由于覆盖了直接物理内存访问的数据共享范式(在RTOS中经常使用)，我们的前向切片器可以灵活地跨不同的任务扩展，并在执行中动态地缝合路径。

控制流节点处理程序。如果直接执行代码片段，模糊测试引擎将缺乏RTOS的完整上下文和运行时状态。因此，使用控制流节点处理程序来指导模糊器确定如何处理与用户输入无关的函数调用和条件分支，帮助模糊引擎提高路径探索的效率和稳定性。

微模糊测试。我们的模糊测试引擎专注于修剪过的执行树中的指令。从输入源开始，它通过指令级仿真更新执行上下文。模糊测试引擎将执行与输入相关的代码片段，并忽略大量不必要的路径，包括其他输入处理程序。为了检查危险行为，它监视接收函数调用的上下文，并在上下文违反预定义的安全策略时报告潜在的错误。

Concolic分析器。为了从剪枝后的调用图中获取遗漏的上下文信息，我们恢复了修改后的条件分支，并对被忽略的函数的上下文进行了符号化。然后，我们基于前向切片执行concolic执行，并使用bug触发输入来提供具体值。我们执行向后切片，从sink函数开始到写入的对象分配位置和其他输入引用位置。然后，我们从向后切片的结尾开始执行符号执行，以获得对象大小的约束，并迭代其他输入的每个谓词，以检查相应的条件是否必要。最后，我们可以实现一个完整而准确的路径条件来评估漏洞。

我们基于Ghidra[17]和UnicornAFL[25]实现了我们的SFuzz原型，其中包含大约6200行Python代码、4300行C代码和5100行Java代码。为了了解SFuzz在检测RTOS安全漏洞方面的有效性，我们将我们的工具应用于来自11家供应商的35个固件样本。SFuzz在这些最新版本的固件样本中成功发现了77个未知漏洞。我们还将SFuzz与最先进的工具进行了比较，SFuzz优于所有被比较的工具。

综上所述，我们做出了以下贡献:

- 我们提出了一种基于切片的RTOS测试方法，该方法利用前向切片来修剪控制流以进行有效的模糊测试，并结合后向切片来验证来自模糊测试的警报。
- 我们设计并实现了SFuzz，它通过跨平台CPU仿真执行基于切片的模糊测试，有效检测RTOS固件中的漏洞。
- 我们在来自11家供应商的35个真实RTOS固件样本上对SFuzz进行了评估，发现了77个未知bug。已经为68个bug分配了CVE/CNVD id。

## 2.问题和方法概述
在本节中，我们首先提供RTOS漏洞的背景。然后，我们概述了我们的方法并讨论了相关的挑战。

### 2.1 RTOS和嵌入式设备










