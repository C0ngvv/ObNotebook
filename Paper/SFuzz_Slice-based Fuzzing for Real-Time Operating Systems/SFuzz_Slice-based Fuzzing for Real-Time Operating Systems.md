

# 翻译
SFuzz:针对实时操作系统的基于片的模糊测试
## 摘要
实时操作系统(RTOS)已成为嵌入式系统的主要类别。它被广泛用于支持需要实时响应的任务，如打印机和交换机。由于RTOS运行在与攻击者隔离的特殊环境中，其安全性长期以来一直被忽视。然而，随着物联网设备的快速发展，大量的RTOS设备接入了公共网络。由于缺乏安全机制，这些设备极易受到各种攻击。更糟糕的是，RTOS的单片设计将各种任务和服务合并到一个二进制文件中，这阻碍了当前在RTOS上工作的程序测试和分析技术。

在本文中，我们提出了一种新的基于切片的模糊器SFuzz来检测RTOS中的安全漏洞。我们的见解是，RTOS通常将复杂的二进制文件分成许多独立但单一的任务。每个任务以确定的方式完成一个特定的事件，其控制流通常是直接和独立的。因此，我们从单片RTOS二进制文件中识别出这样的代码，并合成一个切片进行有效的测试。具体来说，SFuzz首先识别处理用户输入的函数，构造从这些函数的调用者开始的调用图，并利用前向切片来基于调用图构建执行树，并修剪独立于外部输入的路径。然后，它在粗粒度范围内检测并处理阻碍有效模糊测试的障碍，例如与用户输入无关的指令。然后，它对这些代码片段进行覆盖引导的模糊测试。最后，SFuzz利用前向和后向切片来跟踪和验证每个路径约束，并确定在fuzzer中发现的错误是否是真正的漏洞。SFuzz在35个RTOS样本中成功发现了77个零日漏洞，其中67个已被分配CVE或CNVD id。我们的经验评估表明，SFuzz在测试RTOS方面优于最先进的工具(例如，UnicornAFL)。

关键字：RTOS；基于片的模糊测试；污点分析；混合执行

## 1.引言
实时操作系统(RTOS)是为实时应用程序服务而设计的。它已被广泛部署在嵌入式微控制器和cpu之上，安装数量甚至超过了成熟的操作系统。例如，VxWorks，业界领先的RTOS[38]，运行在超过20亿台设备上[33]。RTOS的许多行业场景不仅需要实时、确定性的性能，而且还需要安全认证，如NASA的InSight航天器[24]

然而，由于各种发展限制，将传统的安全机制应用到RTOS中是具有挑战性的。例如，为了支持对实时任务的即时响应，RTOS放弃了内核和用户空间之间的隔离[20]，以平面模式运行所有任务，以避免频繁的上下文切换。在这种情况下，所有软件模块都可以不受限制地访问内存空间中的所有数据和指令[11]，这给RTOS带来了更多的潜在威胁。这种单片设计是可以接受的，因为RTOS主要在本地网络中运行，并且与外部威胁隔离。

如今，物联网(IoT)将更多的RTOS设备直接连接到互联网，这为外部攻击者打开了RTOS设备的大门。在攻击者破坏这些薄弱设备之前，发现RTOS系统中的漏洞是当务之急。尽管许多研究者提出了各种针对嵌入式设备的漏洞检测机制[7,9,21,31,44]，但能够直接应用于RTOS的机制很少。主要原因是RTOS通常以blob-firmware格式呈现，并且在单个单片执行中几乎不运行在微控制器和cpu上，包括内核模块、调度模块和其他任务模块。这个特性给传统的bug检测机制带来了困难。

对于静态分析[9,31]，考虑到单片RTOS二进制文件的大容量，经典的静态方法(例如符号执行[6,10,34])存在路径爆炸问题。此外，由于缺乏显式的函数符号和RTOS的复杂性，很难在二进制级别上揭示函数的语义。因此，我们无法轻易识别与敏感数据相关的模块，也无法对这些模块进行分析。动态解决方案[7,21,37,44]，如模糊测试，要么需要实际设备，要么依赖于正确和稳定的仿真来测试目标固件和基本服务。由于来自不同供应商的RTOS[15,16,38]采用具有不同接口的各种外设，因此用可管理的努力模拟所有现实世界场景是具有挑战性的。

随着RTOS得到越来越多的关注，一些工作开发了定制的工具来检测RTOS中的错误。Zhu等人[45]介绍了一种调试方法来检测基于vxworks的物联网设备的漏洞。Wen等[37]提出在BLE设备上检查裸机固件的配置错误。然而，这些方法要么只能在特定设备上工作，要么依赖于真实设备[45]，要么只能检测到有限的漏洞类型[37]。Salehi等人[32]插桩裸机固件二进制文件来观察内存损坏。Clements等[12]扩展了HALucinator[13]以与VxWorks一起工作。然而，这些工具需要手工分析和领域知识，因此很难应用于不同的RTOS系统。这些工作中的许多甚至需要RTOS的源代码来获得更多的硬件细节[12,13]，或者需要大量的扩展开发来进行有效的模糊测试[32]。因此，它们都受到可伸缩性的限制。总的来说，缺乏一种灵活和通用的方法来有效地发现RTOS中的漏洞。

尽管困难重重，但我们注意到，特定的RTOS特性为绕过测试障碍提供了独特的机会，比如多任务机制。具体来说，RTOS通常将复杂的应用程序划分为许多独立但单一的任务。每个任务以确定的方式完成一个特定的事件。每个原子任务的控制流通常是直接和独立的。更重要的是，如果这些任务属于同一类别，它们的数据流可能具有相似的模式。因此，我们搜索从各种外部数据条目开始到潜在sink函数(例如，memcpy)的数据流，并在RTOS任务之间切片相应的代码片段。这些片段足够小，可以使用现有的模糊测试逻辑进行测试。此外，它们提供了更小但更关键的控制流范围。它可以大大减轻仿真难度和分析复杂性，这将允许我们执行更有效和高效的测试，如灰盒模糊和符号执行。

基于我们的见解，我们提出了SFuzz，这是一种新颖的模糊测试方法，它利用前向切片来构建定制的代码空间，从而在模拟器上驱动灰盒模糊测试。然后，SFuzz结合向后切片来执行concolic执行，以验证来自模糊的崩溃输入。我们设计的SFuzz有四个主要组件:

切片器。我们的代码切片器首先识别处理用户输入的函数。由于RTOS二进制文件没有函数名，我们定义了一组启发式方法来定位这些函数。之后，我们构造一个从这些函数的一个调用者开始的调用图。通过粗粒度传播，我们通过修剪独立于外部输入的路径，在该调用图中执行前向切片。我们还修改了与输入无关的条件分支，以确保控制流达到潜在的sink函数。由于覆盖了直接物理内存访问的数据共享范式(在RTOS中经常使用)，我们的前向切片器可以灵活地跨不同的任务扩展，并在执行中动态地缝合路径。

控制流节点处理程序。如果直接执行代码片段，模糊测试引擎将缺乏RTOS的完整上下文和运行时状态。因此，使用控制流节点处理程序来指导模糊器确定如何处理与用户输入无关的函数调用和条件分支，帮助模糊引擎提高路径探索的效率和稳定性。

微模糊测试。我们的模糊测试引擎专注于修剪过的执行树中的指令。从输入源开始，它通过指令级仿真更新执行上下文。模糊测试引擎将执行与输入相关的代码片段，并忽略大量不必要的路径，包括其他输入处理程序。为了检查危险行为，它监视接收函数调用的上下文，并在上下文违反预定义的安全策略时报告潜在的错误。

Concolic分析器。为了从剪枝后的调用图中获取遗漏的上下文信息，我们恢复了修改后的条件分支，并对被忽略的函数的上下文进行了符号化。然后，我们基于前向切片执行concolic执行，并使用bug触发输入来提供具体值。我们执行向后切片，从sink函数开始到写入的对象分配位置和其他输入引用位置。然后，我们从向后切片的结尾开始执行符号执行，以获得对象大小的约束，并迭代其他输入的每个谓词，以检查相应的条件是否必要。最后，我们可以实现一个完整而准确的路径条件来评估漏洞。

我们基于Ghidra[17]和UnicornAFL[25]实现了我们的SFuzz原型，其中包含大约6200行Python代码、4300行C代码和5100行Java代码。为了了解SFuzz在检测RTOS安全漏洞方面的有效性，我们将我们的工具应用于来自11家供应商的35个固件样本。SFuzz在这些最新版本的固件样本中成功发现了77个未知漏洞。我们还将SFuzz与最先进的工具进行了比较，SFuzz优于所有被比较的工具。

综上所述，我们做出了以下贡献:

- 我们提出了一种基于切片的RTOS测试方法，该方法利用前向切片来修剪控制流以进行有效的模糊测试，并结合后向切片来验证来自模糊测试的警报。
- 我们设计并实现了SFuzz，它通过跨平台CPU仿真执行基于切片的模糊测试，有效检测RTOS固件中的漏洞。
- 我们在来自11家供应商的35个真实RTOS固件样本上对SFuzz进行了评估，发现了77个未知bug。已经为68个bug分配了CVE/CNVD id。

## 2.问题和方法概述
在本节中，我们首先提供RTOS漏洞的背景。然后，我们概述了我们的方法并讨论了相关的挑战。

### 2.1 RTOS和嵌入式设备
实时操作系统(RTOS)旨在提供确定性的执行模式。它专注于任务的及时执行，适用于具有实时需求的嵌入式设备，如打印机、交换机和路由器。由于内存空间的限制以及对快速任务调度和快速响应的要求(即性能约束)[20,31]，一些供应商将其RTOS编译为具有所有功能的单个二进制文件。同时，它们还剥离系统符号以减小二进制文件的大小。这些因素给以RTOS为操作系统的嵌入式设备的全系统仿真或安全性分析带来了挑战。

然而，这些设备(如打印机、路由器等)通常会接收来自外部(如网络、蓝牙等)的数据包，并对其进行解析以完成各种任务，从而为攻击者提供劫持它们的方法。同时，这些设备通常是家庭网络或局域网(LAN)的关键点。没有最先进的防御机制，如可执行空间保护[23]和堆栈金丝雀[14]，攻击者会非常关注它们，并喜欢通过它们的数据入口（data entries）来攻击它们。因此，安全研究人员有必要克服这些挑战，提出一种合适的方法，通过易于接触的嵌入式设备的数据入口来检测漏洞。

### 2.2 动机案例
清单1显示了一个简化的代码片段，在第40行中包含一个缓冲区溢出错误。我们使用我们的工具SFuzz在TP-Link WDR7660的RTOS中发现了这个错误，并向其供应商报告了它。该漏洞已被修复，并分配了一个CVE编号CVE-2020-28877。这个代码片段的功能是从外部接收数据(第7行)并调用相应的函数集来处理数据包(第9-44行)。详细地说，它首先进入函数protocol_handler(第9行)，检查包头的基本格式和大小(第15行)，匹配魔术字节(第16行)，并检查整个包的完整性(第17行)。如果输入包满足所有约束，则执行将进入函数msg_handler(第18行)，根据包的版本(第23行)调用相应的处理程序(第24行)。函数parse_advertisement解析并提取结构元素的头(第35-36行)，它是包负载中的基本数据单元，并将元素复制到内存空间(第40行)。因为structure元素中数据部分的长度记录在len字段中，攻击者可以通过精确构造一个包并将len的值设置为大于用于存储数据部分的缓冲区的长度来触发堆栈溢出漏洞。

![](images/Pasted%20image%2020230906105908.png)

不幸的是，目前用于嵌入式系统的bug查找技术无法有效地检测到此漏洞。动态解决方案，如模糊测试和仿真，不能保证模拟具有封闭硬件功能的整个RTOS并覆盖所有程序状态，特别是对于解析自定义数据格式的特定代码。例如，假设我们有一个设备，并希望使用最近的工作SRFuzzer[43]来识别这个bug。在这种情况下，我们必须利用逆向工程来分析设备可以处理的所有数据格式，然后生成和发送请求来触发处理逻辑代码。它需要很高的人工成本，并且对分析人员的要求非常高。静态方法如KARONTE[31]和SaTC[9]不能有效地定位单片RTOS二进制文件中的数据入口。例如，KARONTE只关注与进程间通信相关的数据，而SaTC则使用用于标记用户输入的关键字来查找数据入口。此外，代码段中复杂的代码逻辑(我们简化了动机样本中代码段的控制流图)使他们很难进行静态污点分析或符号执行，以有效地找到从数据入口点(例如recvfrom)到sink函数(例如memcpy)的敏感路径。

### 2.3 SFuzz的必要性和合理性
根据以上分析和比较，动态方法比静态分析方法更适用于检测RTOS漏洞。然而，如果没有大量的人工分析和健壮的全系统仿真方法，我们如何通过动态的方法有效地检测各种嵌入式设备实时操作系统中的这些漏洞?

我们的直觉是，对功能独立的片段进行模糊测试是发现RTOS漏洞的有效方法，我们将其命名为基于片段的模糊测试。假设我们收集一个程序片，其中包含接收和处理相应数据包的完整函数集。通过混合模糊测试和指令级仿真，可以有效合理地检测出代码段中的漏洞。此外，我们可以忽略模拟各种硬件和服务特性的困难。

考虑清单1中的示例，在确定了数据接收函数(第7行)和所有与包处理相关的函数(例如，第40行中的复制)之后，我们可以构造代码片段并生成输入，通过覆盖引导的混合模糊测试触发堆栈溢出漏洞。由于在执行代码片段时缺乏完整的上下文，我们需要处理与外部包无关的控制流节点，以使模糊测试高效和稳定。一旦发现漏洞，我们将根据触发漏洞的输入进行concolic分析，并获得最终结果，包括与我们处理的控制流节点相关的完整约束，以帮助我们确定漏洞是否为假阳性。正如我们所看到的，通过静态分析，我们的方法的探索范围仅限于有风险的代码片段。同时，我们只使用符号执行来帮助我们在模糊测试卡住时创建新的测试用例，并验证崩溃结果。这使得我们的方法与传统的静态分析和符号执行方法相比，具有更好的性能，减轻了路径爆炸问题。

为了证明基于切片的模糊测试方法在RTOS上的合理性，我们选择了来自两家供应商(TP-Link和MERCURY)的四个嵌入式设备的系统，检查它们的功能是否可以划分为特定于任务的独立片段。我们选择这四种设备是因为它们都包含符号文件或日志函数，这便于我们对每个函数的功能进行判断，并对结果进行人工验证。我们搜索系统中所有类型的数据读入点，例如recvfrom函数，并将它们的调用函数(例如devDiscoverHandle)作为数据处理树和特定任务模块的根点。然后递归搜索存在于根点函数及其子函数中的函数调用，形成函数集。我们使用根点函数的名称来命名它的函数集(如UpSet图所示)。理论上，这些函数集应该对应于不同的数据读入点、数据处理任务和功能。只有这样才能证明我们的基于切片的模糊方法是合理的。不同函数集之间的函数交集越少，各函数集的函数独立性越高。

由于这四种设备的验证结果相似，我们以TP-Link WDR7660为例来说明它们的结果。我们提供了CDF图来简化不同功能片段之间的函数交集分布的表示。如图1所示，很少有函数(少于25%)属于多个集合。根据我们的分析，交集主要来自两个方面。一个是标准库的函数(例如recvfrom、memcpy等)，不同的功能将使用它们。二是不同函数集之间的相似性。尽管这些函数集具有不同的数据入口点，但它们处理类似的数据包，例如bindRequestHandle和registerRequestHandle。我们还提供了一个UpSet图(由于页面限制，我们把它放在Github上)，一种用于集合定量分析的可视化技术，以显示从RTOS收集的不同功能集之间交集的细节。

![](images/Pasted%20image%2020230906151441.png)

![](images/Pasted%20image%2020230906151821.png)

为了进一步研究RTOS中模块的耦合度量，我们考察了上述四种嵌入式设备中任务之间的共享数据。结果表明，用于在功能片段之间共享数据的全局变量的比例很低。我们确定了14,592个全局变量，其中207个在我们确定的功能片段中使用，只有27个全局变量被不同的片段共享(不到13%，如图1所示)。此外，我们通过由几个API对(例如set_env和get_env)操作的共享关键字来检查数据共享范式，如KARONTE[31]和SaTC[9]所示。由于其便利性，这种数据共享范例在嵌入式系统中很流行。我们发现这四个使用相应API对的示例中的功能片段之间没有数据共享。

以上分析表明，从RTOS中采集的这些功能集满足控制流和数据流功能独立的特点。因此，实验结果验证了基于切片的模糊方法的合理性。

### 2.4 基于片的模糊测试的挑战
为了将我们的方法应用于各种嵌入式设备的RTOS，我们需要解决三个主要挑战。

**C1.如何确定片段的范围?**

首先，无论目标RTOS是否包含符号文件，我们都需要识别数据读取函数的方法。其次，我们需要一种方法来确定与数据接收点相对应的代码片段的作用域。通过函数调用构造功能集将包括一些与输入数据的处理逻辑无关的路径和函数。同时，一些不能接触到sink函数的路径也会被包含在作用域中。两者都会影响基于切片的模糊检测的效率。

**C2.如何处理与代码片段中的控制流相关的点?**

一些函数调用和条件分支会影响执行路径的可达性和模糊测试的效率。例如，模拟器无法模拟的某些函数将影响路径可达性。另一个例子，一些比较指令将使用全局变量或与我们正在改变的输入无关的变量。因为我们不能通过种子突变来改变这些变量的值，所以我们不能控制这些比较指令的后续分支的跳转方向。

**C3.如何有效地进行基于切片的模糊测试并验证PoC?**

一方面，纯模糊技术在不事先了解应用或输入格式的情况下，很难生成有效的种子来通过各种条件保护[30,35]。与Driller[35]类似，我们将模糊与符号执行相结合，使路径探索更加有效。另一方面，由于我们对代码片段进行模糊测试，并对一些与控制流相关的指令进行预处理，因此我们需要设计一种方法来判断导致崩溃的概念验证(PoC)是否是原始RTOS中的真正漏洞。

## 3.设计
**方法概述**。在本文中，我们设计了SFuzz来解决上述挑战，并利用基于切片的模糊测试技术来检测嵌入式设备RTOS代码片段中的漏洞。如图2所示，SFuzz将实时嵌入式设备的固件作为输入并输出它们的bug报告。它首先恢复RTOS中函数的语义，然后使用前向切片器和Control Flow Nodes处理程序提取与外部输入相关的代码片段。然后，它使用基于片的模糊测试技术来探索代码片段的执行树。最后，构建了基于concolic分析器的PoC。

![](images/Pasted%20image%2020230906153611.png)

其中，前向切片器将调用图分析与前向污点分析相结合，确定每个任务进行基于切片的模糊处理的探索空间;控制流节点处理程序用于帮助后续模糊部分跳过不必要的路径探索和那些会使模糊阶段卡住的节点;微模糊引擎是一种混合灰盒模糊器，它结合了一些低级技术，如错误检测策略，使模糊器能够平稳运行并发现错误;Concolic Analyzer主要是帮助我们过滤由于探索修剪和上下文缺失而导致的误报。

### 3.1 前向切片器Forward Slicer
为了对目标RTOS的功能片段进行基于切片的模糊测试，我们首先恢复固件中关键功能的语义(详细信息见§4)，以定位外部数据入口点(例如，recvfrom)，全局数据共享函数(例如，nvram_get)和易受攻击的函数(例如，memcpy)，然后利用前向切片器模块输出与处理外部输入和全局数据相关的执行树。

Forward Slicer包含三个部分，其工作流程如图2所示。敏感调用图构造器检测输入获取函数(例如，清单1中的recvfrom)和全局数据读取点，然后将这些函数的调用者作为根节点来构建调用图。为了使模糊测试集中在易受攻击的路径上，我们修剪了图中不能接触潜在汇聚函数(即memcpy、strcpy、sprintf等)的分支。调用图修剪组件进一步修剪独立于外部输入的子图或路径。最后，调用图缝合组件在不同调用图的节点之间拼接一些边。由于缺乏直接相关性，在构建这些调用图时缺少这些边。

**调用图剪枝**。为了判断外部输入或全局数据是否会影响潜在sink函数的参数，SFuzz利用轻量级(粗粒度)污点分析技术跟踪调用图中的每条路径(从根节点到叶节点)，确定外部输入和全局数据可能的影响范围，并过滤独立于它们的路径。在这里，我们描述了污染引擎的高层级设计。对于每个调用路径，污点引擎将进入路径中每个节点的函数体。它根据函数的语义将输入接收和解析函数的参数或返回值标记为污染源，例如清单1中recvfrom的参数Global_addr+0x1c，它指向的内存空间用于存储输入数据。在对每条指令进行污点分析时，污点引擎首先将指令翻译成语义比各种不同体系结构的汇编指令更简单的中间指令。然后，对于每个中间指令，如果输入操作数受到外部输入的影响，它将该指令的输出操作数包含到受污染的操作数集中。对于被调用方不属于调用路径的函数调用指令，污染引擎将把污染属性从其污染参数传播到返回值。如果sink函数的风险参数(例如，函数memcpy(\*dest， \*src, count)的count)受到输入的影响，则SFuzz保留相应的调用路径。

> taint analysis的准确率好像确实是不高的，只能是一种粗略的污染，它只标记污点而不包含任何语义信息，有很多会经过（传播）但无影响的也会被标记为污点，实际找到的危险路径根本不可用。

**调用图形拼接**。KARONTE[31]和SaTC[9]提出，一些外部输入的数据流可能被数据共享范式(例如set_env和get_env)中断。不幸的是，RTOS也面临着同样的挑战。与之前的方法不同，除了使用静态分析来拼接确定性关联节点外，我们还使用动态技术来检测数据设置和使用点之间的非确定性相关性。对于用常量字符串标记的数据共享范式(即集合点和使用点)，我们基于常量字符串进行搜索和匹配。然后连接两个调用路径并使用一个虚拟节点(即，两个元组，如<nvram_set, nvram_get>)来表示合并调用图中的范例。对于由动态创建的变量标记的范例，例如清单2中的“wan%d_pppoe_username”，我们基于近似字符串匹配方法获得这些范例，并创建一个虚拟条件节点来连接潜在的数据共享范例。然后根据仿真执行期间变量的实际值确定是否跳转到全局数据读取点。对于设定点有多个对应的得到点，我们还建立虚拟条件节点，并根据随机概率确定跳跃方向。

![](images/Pasted%20image%2020230906155306.png)

### 3.2 控制流节点处理程序
在处理Forward Slicer模块之后，我们可以基于调用图构建目标代码片段的执行树。然而，为了使执行树上的模糊测试顺利进行，避免不必要的路径探索，我们仍然需要处理几种与控制流相关的指令(即(i)函数调用，(ii)条件分支)，这将影响执行路径的可达性和测试的效率。换句话说，由于缺乏RTOS的完整上下文和运行时状态，我们需要策略来指导fuzzer确定如何处理代码片段中的函数调用，并选择跳转条件语句的哪个分支。

**调用指令**。一方面，我们将函数调用指令的地址(其被调用者的参数不受外部输入的影响)添加到PatchFunc集合中，并引导fuzzer跳过函数调用。我们这样做主要是因为它的参数与输入无关，并且它的返回值和参数不会通过改变种子输入而改变。因此，修补这类函数有助于模糊器忽略其复杂性，提高模糊效率。另一方面，对于属于敏感调用图或其参数受输入影响的所有函数调用(如清单1中的protocol_handler和header_check)，我们保留它们。只有逐步进入这些功能，才能保证敏感路径的可达性。

**条件分支**。条件语句仅在满足指定的分支约束时才将控制流定向到目标地址。然而，在对代码片段进行模糊测试时，如果条件与输入数据没有关系，我们必须面对确定条件跳转方向的问题，这意味着我们不能通过改变输入来改变跳转方向。为了使模糊测试更加有效和合理，我们提出了几种处理各种条件分支的方法。

- 假设只有条件跳转指令的一个分支能跳转到sink函数。如果它的条件受到输入的影响，我们将不可达分支的目标地址插入到PatchedJMP集，这将引导模糊器避免探索该分支。否则，我们将跳转指令的地址添加到PatchchJMP集合中，并引导模糊器将条件跳转替换为可到达分支的固定跳转。
- 假设条件语句的两个分支都可以到达sink函数。如果它的约束与输入数据无关，我们将指令的地址添加到PatchedJMP集合中，这将引导模糊器用随机跳转语句替换该指令。否则，我们不更改代码，它主要是帮助我们探索尽可能多的不受输入决定的路径。
- 如果没有一个条件跳转指令的分支可以到达sink函数，我们将两个分支的目标地址添加到PatchedJMP集合中，这将引导模糊器在遇到这些地址时退出当前的路径探索。

### 3.3 微模糊测试
作为模糊测试引擎的核心，我们将基于切片的模糊测试技术称为微模糊测试。它将代码片段作为输入，探索执行树中的路径，并忽略不相关的调用点和其他输入数据处理程序。该引擎在根据预定义策略访问内存时检查sink函数调用点的上下文并导出崩溃输入。

**镜像加载程序**。加载RTOS固件后，图像加载器将预处理由上一个模块标记的裁剪的代码片段。对于应该被跳过的调用指令(在PatchedFuncset中)，镜像加载程序将调用指令替换为类似nop的指令。对于应该避免被探索的分支(在PatchedJMPset中)，SFuzz将AvoidExplore语句添加到其目标地址。当程序执行到相应的地址时，程序将直接退出当前的路径探索。对于应该用固定跳转或随机跳转替换的分支，SFuzz用相应的操作处理它。

**模糊测试引擎**。


### 3.4 Concolic分析器

## 4.实现
我们用大约6200行Python代码、4300行C代码和5100行Java代码实现了SFuzz的原型系统。污点分析模块和语义恢复部分基于Ghidra实现[17]。模糊测试引擎基于UnicornAFL和Driller[35]构建，concolic分析器基于Angr[36]实现。我们扩展了Driller，使其适用于RTOS映像，包括基于我们自己设计的RTOS加载器重新实现其跟踪记录器，以跟踪目标代码片段的执行轨迹。我们的系统基于以下几个基本程序:

**镜像提取**。我们利用嵌入固件中的字符串来识别RTOS的类型(例如，VxWorks 5.5.1)，并利用BinWalk来提取RTOS映像的内容。同时，对于内容的反汇编，我们利用图像中机器代码的特征来确定CPU架构的类型(例如，MIPS)。

**基址识别**。由于RTOS系统中许多数据引用或函数调用操作依赖于基址，错误的基址会导致错误的数据引用或控制流跳转。我们实现这一部分的核心思想是，只有正确的基址才能将大多数数据引用指针与预期目标链接起来。该方法在Vxhunter[45]中提出，并在一些相关作品中使用，如FirmXRay[37]。该模块包含两个步骤来识别基址。首先从系统中识别并提取数据引用指针;其次，它将数据指针的绝对地址与预期目标相匹配。应该声明:(i)我们只使用字符串指针来帮助识别基于地址，这已经足够好了(如§5.4所示);(ii)我们基于PCode实现该方法，PCode是Ghidra对汇编语言指令的中间表示，而不是特定架构的指令。因此，它可以支持更多的体系结构。

**功能语义重构**。如§3.1所述，我们需要函数语义来指导污点分析并定位敏感片段。SFuzz主要恢复三种函数的语义和功能:(i)接收、解析或共享外部输入数据(即用户输入)的函数;(ii)sink函数(如memcpy);(iii)设置或获取全局数据的函数。我们实现了四种方法来自动恢复函数的函数语义和识别敏感函数。

- **符号文件和日志功能**。根据我们的分析，一些供应商(例如TP-Link和MERCURY)会发布标记函数名称的符号文件;同时，用于输出运行时错误的日志函数也可以用于恢复函数名。根据我们的分析，一些供应商(例如TP-Link和MERCURY)保留了可以标记固件中功能名称的符号文件。同时，一些厂商使用日志函数输出运行时错误，这也可以帮助恢复函数名，如语句logOutput(ostream， "devDiscover: error, ret = %d"， retcode)中的devDiscover。
- **虚拟执行**。首先，该方法将目标函数的参数和返回值的数量与标准库函数进行比较，以找到潜在的匹配函数，例如strcpy。其次，它分配内存空间，初始化寄存器的状态，并设置函数参数的初始值。最后在函数体中对代码进行仿真，通过分析输出值和仿真对内存空间的影响来确定匹配的函数。我们利用这个方法来识别标准库函数，比如memcpy和printf。
- **Web服务语义**。我们在前端文件(例如HTML、PHP和JavaScript)和后端文件中利用用于标记用户输入的共享字符串来恢复与web服务相关的一些函数的语义。我们基于SaTC[9]中提出的方法实现了该方法。
- **开源固件**。一些供应商选择开源的RTOS项目来构建他们的系统，比如eCos和FreeRTOS。对于这些类型的系统，在预处理固件时确定其版本后，我们可以利用B2SFinder[42]和其他一些工具[41]，根据代码中嵌入的字符串、即时和其他显式特性，将固件中的功能与开源项目中的功能进行匹配。

## 5.评估






## 6.相关工作
**RTOS安全**。Armis Labs[2]揭示了可以远程危害最流行的实时操作系统Vxworks[33]的关键零日漏洞，并演示了如何利用这些发现的漏洞接管整个工厂[18]。Zhu等人[45]介绍了如何通过模糊测试和调试VxWorks设备来发现漏洞。然而，目前的方法不是通用的，需要依靠设备进行调试[45]，或者需要大量的人工进行分析[33]。

**符号执行**。欠约束符号执行[28]和组合符号执行[1,27]可以分析UNIX操作系统中的程序，如UC-KLEE[28]、RWSet[3]及其改进方法[4,22,40]。它们识别影响新代码可达性的关键数据(例如，读写集[3]，相关位置集[4])，并在探索代码空间时检测和消除冗余状态和路径。我们的切片方法根据当前函数是否与处理外部输入相关来修剪路径。探索这些不相关的函数无助于发现bug，但可能会使指令模拟失败或使测试卡住。因此，在SFuzz中消除路径被设计为启动RTOS中的模糊测试，并且在原理和目标上独立于这些工作。UC-KLEE[28]执行功能范围分析，但缺少过程间数据流。此外，这些高级方法[1,3,4,27,28]都是为检查源代码或IR而设计的，这在成熟的操作系统中很流行，但在RTOS中很少。因此，这些方法需要在RTOS的二进制上进行大量的扩展，并且在低级指令上运行时具有很高的计算复杂度。注意，无论在Micro Fuzzing引擎还是Concolic Analyzer模块中，SFuzz都是基于对具体输入进行符号化来执行符号执行的。因此，它们在由这个具体值(例如，崩溃输入)触发的路径中迭代分支，并缓解路径爆炸问题。


## 7.评估
我们提出了一种新的基于切片的模糊检测方法SFuzz来检测RTOS中的安全漏洞。基于RTOS单片系统可以被分割成有意义的代码片的洞见，SFuzz利用前向切片来构建一个定制的执行树，该树足够小，可以在模拟器上驱动灰盒模糊测试，并利用前向和后向切片来执行concolic测试，以验证来自模糊测试的独特崩溃。SFuzz在20个RTOS设备中成功发现了77个零日软件漏洞，并为67个设备分配了CVE或CNVD ID。我们的评估结果表明，SFuzz的每个部分都帮助它在发现RTOS中的错误方面优于最先进的工具(例如，UnicornAFL)。
