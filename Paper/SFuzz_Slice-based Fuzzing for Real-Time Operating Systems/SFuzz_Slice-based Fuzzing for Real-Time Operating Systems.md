

# 翻译
SFuzz:针对实时操作系统的基于片的模糊测试
## 摘要
实时操作系统(RTOS)已成为嵌入式系统的主要类别。它被广泛用于支持需要实时响应的任务，如打印机和交换机。由于RTOS运行在与攻击者隔离的特殊环境中，其安全性长期以来一直被忽视。然而，随着物联网设备的快速发展，大量的RTOS设备接入了公共网络。由于缺乏安全机制，这些设备极易受到各种攻击。更糟糕的是，RTOS的单片设计将各种任务和服务合并到一个二进制文件中，这阻碍了当前在RTOS上工作的程序测试和分析技术。

在本文中，我们提出了一种新的基于切片的模糊器SFuzz来检测RTOS中的安全漏洞。我们的见解是，RTOS通常将复杂的二进制文件分成许多独立但单一的任务。每个任务以确定的方式完成一个特定的事件，其控制流通常是直接和独立的。因此，我们从单片RTOS二进制文件中识别出这样的代码，并合成一个切片进行有效的测试。具体来说，SFuzz首先识别处理用户输入的函数，构造从这些函数的调用者开始的调用图，并利用前向切片来基于调用图构建执行树，并修剪独立于外部输入的路径。然后，它在粗粒度范围内检测并处理阻碍有效模糊测试的障碍，例如与用户输入无关的指令。然后，它对这些代码片段进行覆盖引导的模糊测试。最后，SFuzz利用前向和后向切片来跟踪和验证每个路径约束，并确定在fuzzer中发现的错误是否是真正的漏洞。SFuzz在35个RTOS样本中成功发现了77个零日漏洞，其中67个已被分配CVE或CNVD id。我们的经验评估表明，SFuzz在测试RTOS方面优于最先进的工具(例如，UnicornAFL)。

关键字：RTOS；基于片的模糊测试；污点分析；混合执行

## 1.引言
实时操作系统(RTOS)是为实时应用程序服务而设计的。它已被广泛部署在嵌入式微控制器和cpu之上，安装数量甚至超过了成熟的操作系统。例如，VxWorks，业界领先的RTOS[38]，运行在超过20亿台设备上[33]。RTOS的许多行业场景不仅需要实时、确定性的性能，而且还需要安全认证，如NASA的InSight航天器[24]

然而，由于各种发展限制，将传统的安全机制应用到RTOS中是具有挑战性的。例如，为了支持对实时任务的即时响应，RTOS放弃了内核和用户空间之间的隔离[20]，以平面模式运行所有任务，以避免频繁的上下文切换。在这种情况下，所有软件模块都可以不受限制地访问内存空间中的所有数据和指令[11]，这给RTOS带来了更多的潜在威胁。这种单片设计是可以接受的，因为RTOS主要在本地网络中运行，并且与外部威胁隔离。

如今，物联网(IoT)将更多的RTOS设备直接连接到互联网，这为外部攻击者打开了RTOS设备的大门。在攻击者破坏这些薄弱设备之前，发现RTOS系统中的漏洞是当务之急。尽管许多研究者提出了各种针对嵌入式设备的漏洞检测机制[7,9,21,31,44]，但能够直接应用于RTOS的机制很少。主要原因是RTOS通常以blob-firmware格式呈现，并且在单个单片执行中几乎不运行在微控制器和cpu上，包括内核模块、调度模块和其他任务模块。这个特性给传统的bug检测机制带来了困难。

对于静态分析[9,31]，考虑到单片RTOS二进制文件的大容量，经典的静态方法(例如符号执行[6,10,34])存在路径爆炸问题。此外，由于缺乏显式的函数符号和RTOS的复杂性，很难在二进制级别上揭示函数的语义。因此，我们无法轻易识别与敏感数据相关的模块，也无法对这些模块进行分析。动态解决方案[7,21,37,44]，如模糊测试，要么需要实际设备，要么依赖于正确和稳定的仿真来测试目标固件和基本服务。由于来自不同供应商的RTOS[15,16,38]采用具有不同接口的各种外设，因此用可管理的努力模拟所有现实世界场景是具有挑战性的。

随着RTOS得到越来越多的关注，一些工作开发了定制的工具来检测RTOS中的错误。Zhu等人[45]介绍了一种调试方法来检测基于vxworks的物联网设备的漏洞。Wen等[37]提出在BLE设备上检查裸机固件的配置错误。然而，这些方法要么只能在特定设备上工作，要么依赖于真实设备[45]，要么只能检测到有限的漏洞类型[37]。Salehi等人[32]插桩裸机固件二进制文件来观察内存损坏。Clements等[12]扩展了HALucinator[13]以与VxWorks一起工作。然而，这些工具需要手工分析和领域知识，因此很难应用于不同的RTOS系统。这些工作中的许多甚至需要RTOS的源代码来获得更多的硬件细节[12,13]，或者需要大量的扩展开发来进行有效的模糊测试[32]。因此，它们都受到可伸缩性的限制。总的来说，缺乏一种灵活和通用的方法来有效地发现RTOS中的漏洞。

尽管困难重重，但我们注意到，特定的RTOS特性为绕过测试障碍提供了独特的机会，比如多任务机制。具体来说，RTOS通常将复杂的应用程序划分为许多独立但单一的任务。每个任务以确定的方式完成一个特定的事件。每个原子任务的控制流通常是直接和独立的。更重要的是，如果这些任务属于同一类别，它们的数据流可能具有相似的模式。因此，我们搜索从各种外部数据条目开始到潜在sink函数(例如，memcpy)的数据流，并在RTOS任务之间切片相应的代码片段。这些片段足够小，可以使用现有的模糊测试逻辑进行测试。此外，它们提供了更小但更关键的控制流范围。它可以大大减轻仿真难度和分析复杂性，这将允许我们执行更有效和高效的测试，如灰盒模糊和符号执行。

基于我们的见解，我们提出了SFuzz，这是一种新颖的模糊测试方法，它利用前向切片来构建定制的代码空间，从而在模拟器上驱动灰盒模糊测试。然后，SFuzz结合向后切片来执行concolic执行，以验证来自模糊的崩溃输入。我们设计的SFuzz有四个主要组件:

切片器。我们的代码切片器首先识别处理用户输入的函数。由于RTOS二进制文件没有函数名，我们定义了一组启发式方法来定位这些函数。之后，我们构造一个从这些函数的一个调用者开始的调用图。通过粗粒度传播，我们通过修剪独立于外部输入的路径，在该调用图中执行前向切片。我们还修改了与输入无关的条件分支，以确保控制流达到潜在的sink函数。由于覆盖了直接物理内存访问的数据共享范式(在RTOS中经常使用)，我们的前向切片器可以灵活地跨不同的任务扩展，并在执行中动态地缝合路径。

控制流节点处理程序。如果直接执行代码片段，模糊测试引擎将缺乏RTOS的完整上下文和运行时状态。因此，使用控制流节点处理程序来指导模糊器确定如何处理与用户输入无关的函数调用和条件分支，帮助模糊引擎提高路径探索的效率和稳定性。

微模糊测试。我们的模糊测试引擎专注于修剪过的执行树中的指令。从输入源开始，它通过指令级仿真更新执行上下文。模糊测试引擎将执行与输入相关的代码片段，并忽略大量不必要的路径，包括其他输入处理程序。为了检查危险行为，它监视接收函数调用的上下文，并在上下文违反预定义的安全策略时报告潜在的错误。

Concolic分析器。为了从剪枝后的调用图中获取遗漏的上下文信息，我们恢复了修改后的条件分支，并对被忽略的函数的上下文进行了符号化。然后，我们基于前向切片执行concolic执行，并使用bug触发输入来提供具体值。我们执行向后切片，从sink函数开始到写入的对象分配位置和其他输入引用位置。然后，我们从向后切片的结尾开始执行符号执行，以获得对象大小的约束，并迭代其他输入的每个谓词，以检查相应的条件是否必要。最后，我们可以实现一个完整而准确的路径条件来评估漏洞。

我们基于Ghidra[17]和UnicornAFL[25]实现了我们的SFuzz原型，其中包含大约6200行Python代码、4300行C代码和5100行Java代码。为了了解SFuzz在检测RTOS安全漏洞方面的有效性，我们将我们的工具应用于来自11家供应商的35个固件样本。SFuzz在这些最新版本的固件样本中成功发现了77个未知漏洞。我们还将SFuzz与最先进的工具进行了比较，SFuzz优于所有被比较的工具。

综上所述，我们做出了以下贡献:

- 我们提出了一种基于切片的RTOS测试方法，该方法利用前向切片来修剪控制流以进行有效的模糊测试，并结合后向切片来验证来自模糊测试的警报。
- 我们设计并实现了SFuzz，它通过跨平台CPU仿真执行基于切片的模糊测试，有效检测RTOS固件中的漏洞。
- 我们在来自11家供应商的35个真实RTOS固件样本上对SFuzz进行了评估，发现了77个未知bug。已经为68个bug分配了CVE/CNVD id。

## 2.问题和方法概述
在本节中，我们首先提供RTOS漏洞的背景。然后，我们概述了我们的方法并讨论了相关的挑战。

### 2.1 RTOS和嵌入式设备
实时操作系统(RTOS)旨在提供确定性的执行模式。它专注于任务的及时执行，适用于具有实时需求的嵌入式设备，如打印机、交换机和路由器。由于内存空间的限制以及对快速任务调度和快速响应的要求(即性能约束)[20,31]，一些供应商将其RTOS编译为具有所有功能的单个二进制文件。同时，它们还剥离系统符号以减小二进制文件的大小。这些因素给以RTOS为操作系统的嵌入式设备的全系统仿真或安全性分析带来了挑战。

然而，这些设备(如打印机、路由器等)通常会接收来自外部(如网络、蓝牙等)的数据包，并对其进行解析以完成各种任务，从而为攻击者提供劫持它们的方法。同时，这些设备通常是家庭网络或局域网(LAN)的关键点。没有最先进的防御机制，如可执行空间保护[23]和堆栈金丝雀[14]，攻击者会非常关注它们，并喜欢通过它们的数据入口（data entries）来攻击它们。因此，安全研究人员有必要克服这些挑战，提出一种合适的方法，通过易于接触的嵌入式设备的数据入口来检测漏洞。

### 2.2 动机案例
清单1显示了一个简化的代码片段，在第40行中包含一个缓冲区溢出错误。我们使用我们的工具SFuzz在TP-Link WDR7660的RTOS中发现了这个错误，并向其供应商报告了它。该漏洞已被修复，并分配了一个CVE编号CVE-2020-28877。这个代码片段的功能是从外部接收数据(第7行)并调用相应的函数集来处理数据包(第9-44行)。详细地说，它首先进入函数protocol_handler(第9行)，检查包头的基本格式和大小(第15行)，匹配魔术字节(第16行)，并检查整个包的完整性(第17行)。如果输入包满足所有约束，则执行将进入函数msg_handler(第18行)，根据包的版本(第23行)调用相应的处理程序(第24行)。函数parse_advertisement解析并提取结构元素的头(第35-36行)，它是包负载中的基本数据单元，并将元素复制到内存空间(第40行)。因为structure元素中数据部分的长度记录在len字段中，攻击者可以通过精确构造一个包并将len的值设置为大于用于存储数据部分的缓冲区的长度来触发堆栈溢出漏洞。

![](images/Pasted%20image%2020230906105908.png)

不幸的是，目前用于嵌入式系统的bug查找技术无法有效地检测到此漏洞。动态解决方案，如模糊测试和仿真，不能保证模拟具有封闭硬件功能的整个RTOS并覆盖所有程序状态，特别是对于解析自定义数据格式的特定代码。例如，假设我们有一个设备，并希望使用最近的工作SRFuzzer[43]来识别这个bug。在这种情况下，我们必须利用逆向工程来分析设备可以处理的所有数据格式，然后生成和发送请求来触发处理逻辑代码。它需要很高的人工成本，并且对分析人员的要求非常高。静态方法如KARONTE[31]和SaTC[9]不能有效地定位单片RTOS二进制文件中的数据入口。例如，KARONTE只关注与进程间通信相关的数据，而SaTC则使用用于标记用户输入的关键字来查找数据入口。此外，代码段中复杂的代码逻辑(我们简化了动机样本中代码段的控制流图)使他们很难进行静态污点分析或符号执行，以有效地找到从数据入口点(例如recvfrom)到sink函数(例如memcpy)的敏感路径。

### 2.3 SFuzz的必要性和合理性
根据以上分析和比较，动态方法比静态分析方法更适用于检测RTOS漏洞。然而，如果没有大量的人工分析和健壮的全系统仿真方法，我们如何通过动态的方法有效地检测各种嵌入式设备实时操作系统中的这些漏洞?

我们的直觉是，对功能独立的片段进行模糊测试是发现RTOS漏洞的有效方法，我们将其命名为基于片段的模糊测试。假设我们收集一个程序片，其中包含接收和处理相应数据包的完整函数集。通过混合模糊测试和指令级仿真，可以有效合理地检测出代码段中的漏洞。此外，我们可以忽略模拟各种硬件和服务特性的困难。

考虑清单1中的示例，在确定了数据接收函数(第7行)和所有与包处理相关的函数(例如，第40行中的复制)之后，我们可以构造代码片段并生成输入，通过覆盖引导的混合模糊测试触发堆栈溢出漏洞。由于在执行代码片段时缺乏完整的上下文，我们需要处理与外部包无关的控制流节点，以使模糊测试高效和稳定。一旦发现漏洞，我们将根据触发漏洞的输入进行concolic分析，并获得最终结果，包括与我们处理的控制流节点相关的完整约束，以帮助我们确定漏洞是否为假阳性。正如我们所看到的，通过静态分析，我们的方法的探索范围仅限于有风险的代码片段。同时，我们只使用符号执行来帮助我们在模糊测试卡住时创建新的测试用例，并验证崩溃结果。这使得我们的方法与传统的静态分析和符号执行方法相比，具有更好的性能，减轻了路径爆炸问题。

为了证明基于切片的模糊测试方法在RTOS上的合理性，我们选择了来自两家供应商(TP-Link和MERCURY)的四个嵌入式设备的系统，检查它们的功能是否可以划分为特定于任务的独立片段。我们选择这四种设备是因为它们都包含符号文件或日志函数，这便于我们对每个函数的功能进行判断，并对结果进行人工验证。我们搜索系统中所有类型的数据读入点，例如recvfrom函数，并将它们的调用函数(例如devDiscoverHandle)作为数据处理树和特定任务模块的根点。然后递归搜索存在于根点函数及其子函数中的函数调用，形成函数集。我们使用根点函数的名称来命名它的函数集(如UpSet图所示)。理论上，这些函数集应该对应于不同的数据读入点、数据处理任务和功能。只有这样才能证明我们的基于切片的模糊方法是合理的。不同函数集之间的函数交集越少，各函数集的函数独立性越高。

由于这四种设备的验证结果相似，我们以TP-Link WDR7660为例来说明它们的结果。我们提供了CDF图来简化不同功能片段之间的函数交集分布的表示。如图1所示，很少有函数(少于25%)属于多个集合。根据我们的分析，交集主要来自两个方面。一个是标准库的函数(例如recvfrom、memcpy等)，不同的功能将使用它们。二是不同函数集之间的相似性。尽管这些函数集具有不同的数据入口点，但它们处理类似的数据包，例如bindRequestHandle和registerRequestHandle。我们还提供了一个UpSet图(由于页面限制，我们把它放在Github上)，一种用于集合定量分析的可视化技术，以显示从RTOS收集的不同功能集之间交集的细节。

![](images/Pasted%20image%2020230906151441.png)

![](images/Pasted%20image%2020230906151821.png)

为了进一步研究RTOS中模块的耦合度量，我们考察了上述四种嵌入式设备中任务之间的共享数据。结果表明，用于在功能片段之间共享数据的全局变量的比例很低。我们确定了14,592个全局变量，其中207个在我们确定的功能片段中使用，只有27个全局变量被不同的片段共享(不到13%，如图1所示)。此外，我们通过由几个API对(例如set_env和get_env)操作的共享关键字来检查数据共享范式，如KARONTE[31]和SaTC[9]所示。由于其便利性，这种数据共享范例在嵌入式系统中很流行。我们发现这四个使用相应API对的示例中的功能片段之间没有数据共享。

以上分析表明，从RTOS中采集的这些功能集满足控制流和数据流功能独立的特点。因此，实验结果验证了基于切片的模糊方法的合理性。

### 2.4 基于片的模糊测试的挑战
为了将我们的方法应用于各种嵌入式设备的RTOS，我们需要解决三个主要挑战。

**C1.如何确定片段的范围?**

首先，无论目标RTOS是否包含符号文件，我们都需要识别数据读取函数的方法。其次，我们需要一种方法来确定与数据接收点相对应的代码片段的作用域。通过函数调用构造功能集将包括一些与输入数据的处理逻辑无关的路径和函数。同时，一些不能接触到sink函数的路径也会被包含在作用域中。两者都会影响基于切片的模糊检测的效率。

**C2.如何处理与代码片段中的控制流相关的点?**

一些函数调用和条件分支会影响执行路径的可达性和模糊测试的效率。例如，模拟器无法模拟的某些函数将影响路径可达性。另一个例子，一些比较指令将使用全局变量或与我们正在改变的输入无关的变量。因为我们不能通过种子突变来改变这些变量的值，所以我们不能控制这些比较指令的后续分支的跳转方向。

**C3.如何有效地进行基于切片的模糊测试并验证PoC?**

一方面，纯模糊技术在不事先了解应用或输入格式的情况下，很难生成有效的种子来通过各种条件保护[30,35]。与Driller[35]类似，我们将模糊与符号执行相结合，使路径探索更加有效。另一方面，由于我们对代码片段进行模糊测试，并对一些与控制流相关的指令进行预处理，因此我们需要设计一种方法来判断导致崩溃的概念验证(PoC)是否是原始RTOS中的真正漏洞。

## 3.设计
**方法概述**。在本文中，我们设计了SFuzz来解决上述挑战，并利用基于切片的模糊测试技术来检测嵌入式设备RTOS代码片段中的漏洞。如图2所示，SFuzz将实时嵌入式设备的固件作为输入并输出它们的bug报告。它首先恢复RTOS中函数的语义，然后使用前向切片器和Control Flow Nodes处理程序提取与外部输入相关的代码片段。然后，它使用基于片的模糊测试技术来探索代码片段的执行树。最后，构建了基于concolic分析器的PoC。

![](images/Pasted%20image%2020230906153611.png)

其中，前向切片器将调用图分析与前向污点分析相结合，确定每个任务进行基于切片的模糊处理的探索空间;控制流节点处理程序用于帮助后续模糊部分跳过不必要的路径探索和那些会使模糊阶段卡住的节点;微模糊引擎是一种混合灰盒模糊器，它结合了一些低级技术，如错误检测策略，使模糊器能够平稳运行并发现错误;Concolic Analyzer主要是帮助我们过滤由于探索修剪和上下文缺失而导致的误报。

### 3.1 前向切片器Forward Slicer
为了对目标RTOS的功能片段进行基于切片的模糊测试，我们首先恢复固件中关键功能的语义(详细信息见§4)，以定位外部数据入口点(例如，recvfrom)，全局数据共享函数(例如，nvram_get)和易受攻击的函数(例如，memcpy)，然后利用前向切片器模块输出与处理外部输入和全局数据相关的执行树。





















