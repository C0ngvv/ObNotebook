

# 翻译
SFuzz:针对实时操作系统的基于片的模糊测试
## 摘要
实时操作系统(RTOS)已成为嵌入式系统的主要类别。它被广泛用于支持需要实时响应的任务，如打印机和交换机。由于RTOS运行在与攻击者隔离的特殊环境中，其安全性长期以来一直被忽视。然而，随着物联网设备的快速发展，大量的RTOS设备接入了公共网络。由于缺乏安全机制，这些设备极易受到各种攻击。更糟糕的是，RTOS的单片设计将各种任务和服务合并到一个二进制文件中，这阻碍了当前在RTOS上工作的程序测试和分析技术。

在本文中，我们提出了一种新的基于切片的模糊器SFuzz来检测RTOS中的安全漏洞。我们的见解是，RTOS通常将复杂的二进制文件分成许多独立但单一的任务。每个任务以确定的方式完成一个特定的事件，其控制流通常是直接和独立的。因此，我们从单片RTOS二进制文件中识别出这样的代码，并合成一个切片进行有效的测试。具体来说，SFuzz首先识别处理用户输入的函数，构造从这些函数的调用者开始的调用图，并利用前向切片来基于调用图构建执行树，并修剪独立于外部输入的路径。然后，它在粗粒度范围内检测并处理阻碍有效模糊测试的障碍，例如与用户输入无关的指令。然后，它对这些代码片段进行覆盖引导的模糊测试。最后，SFuzz利用前向和后向切片来跟踪和验证每个路径约束，并确定在fuzzer中发现的错误是否是真正的漏洞。SFuzz在35个RTOS样本中成功发现了77个零日漏洞，其中67个已被分配CVE或CNVD id。我们的经验评估表明，SFuzz在测试RTOS方面优于最先进的工具(例如，UnicornAFL)。

关键字：RTOS；基于片的模糊测试；污点分析；混合执行

## 1.引言
实时操作系统(RTOS)是为实时应用程序服务而设计的。它已被广泛部署在嵌入式微控制器和cpu之上，安装数量甚至超过了成熟的操作系统。例如，VxWorks，业界领先的RTOS[38]，运行在超过20亿台设备上[33]。RTOS的许多行业场景不仅需要实时、确定性的性能，而且还需要安全认证，如NASA的InSight航天器[24]。

然而，由于各种发展限制，将传统的安全机制应用到RTOS中是具有挑战性的。例如，为了支持对实时任务的即时响应，RTOS放弃了内核和用户空间之间的隔离[20]，以平面模式运行所有任务，以避免频繁的上下文切换。在这种情况下，所有软件模块都可以不受限制地访问内存空间中的所有数据和指令[11]，这给RTOS带来了更多的潜在威胁。这种单片设计是可以接受的，因为RTOS主要在本地网络中运行，并且与外部威胁隔离。

如今，物联网(IoT)将更多的RTOS设备直接连接到互联网，这为外部攻击者打开了RTOS设备的大门。在攻击者破坏这些薄弱设备之前，发现RTOS系统中的漏洞是当务之急。尽管许多研究者提出了各种针对嵌入式设备的漏洞检测机制[7,9,21,31,44]，但能够直接应用于RTOS的机制很少。主要原因是RTOS通常以blob-firmware格式呈现，并且在单个单片执行中几乎不运行在微控制器和cpu上，包括内核模块、调度模块和其他任务模块。这个特性给传统的bug检测机制带来了困难。

对于静态分析[9,31]，考虑到单片RTOS二进制文件的大容量，经典的静态方法(例如符号执行[6,10,34])存在路径爆炸问题。此外，由于缺乏显式的函数符号和RTOS的复杂性，很难在二进制级别上揭示函数的语义。因此，我们无法轻易识别与敏感数据相关的模块，也无法对这些模块进行分析。动态解决方案[7,21,37,44]，如模糊测试，要么需要实际设备，要么依赖于正确和稳定的仿真来测试目标固件和基本服务。由于来自不同供应商的RTOS[15,16,38]采用具有不同接口的各种外设，因此用可管理的努力模拟所有现实世界场景是具有挑战性的。

随着RTOS得到越来越多的关注，一些工作开发了定制的工具来检测RTOS中的错误。Zhu等人[45]介绍了一种调试方法来检测基于vxworks的物联网设备的漏洞。Wen等[37]提出在BLE设备上检查裸机固件的配置错误。然而，这些方法要么只能在特定设备上工作，要么依赖于真实设备[45]，要么只能检测到有限的漏洞类型[37]。Salehi等人[32]插桩裸机固件二进制文件来观察内存损坏。Clements等[12]扩展了HALucinator[13]以与VxWorks一起工作。然而，这些工具需要手工分析和领域知识，因此很难应用于不同的RTOS系统。这些工作中的许多甚至需要RTOS的源代码来获得更多的硬件细节[12,13]，或者需要大量的扩展开发来进行有效的模糊测试[32]。因此，它们都受到可伸缩性的限制。总的来说，缺乏一种灵活和通用的方法来有效地发现RTOS中的漏洞。

尽管困难重重，但我们注意到，特定的RTOS特性为绕过测试障碍提供了独特的机会，比如多任务机制。具体来说，RTOS通常将复杂的应用程序划分为许多独立但单一的任务。每个任务以确定的方式完成一个特定的事件。每个原子任务的控制流通常是直接和独立的。更重要的是，如果这些任务属于同一类别，它们的数据流可能具有相似的模式。因此，我们搜索从各种外部数据条目开始到潜在sink函数(例如，memcpy)的数据流，并在RTOS任务之间切片相应的代码片段。这些片段足够小，可以使用现有的模糊测试逻辑进行测试。此外，它们提供了更小但更关键的控制流范围。它可以大大减轻仿真难度和分析复杂性，这将允许我们执行更有效和高效的测试，如灰盒模糊和符号执行。

基于我们的见解，我们提出了SFuzz，这是一种新颖的模糊测试方法，它利用前向切片来构建定制的代码空间，从而在模拟器上驱动灰盒模糊测试。然后，SFuzz结合向后切片来执行concolic执行，以验证来自模糊的崩溃输入。我们设计的SFuzz有四个主要组件:

切片器。我们的代码切片器首先识别处理用户输入的函数。由于RTOS二进制文件没有函数名，我们定义了一组启发式方法来定位这些函数。之后，我们构造一个从这些函数的一个调用者开始的调用图。通过粗粒度传播，我们通过修剪独立于外部输入的路径，在该调用图中执行前向切片。我们还修改了与输入无关的条件分支，以确保控制流达到潜在的sink函数。由于覆盖了直接物理内存访问的数据共享范式(在RTOS中经常使用)，我们的前向切片器可以灵活地跨不同的任务扩展，并在执行中动态地缝合路径。

控制流节点处理程序。如果直接执行代码片段，模糊测试引擎将缺乏RTOS的完整上下文和运行时状态。因此，使用控制流节点处理程序来指导模糊器确定如何处理与用户输入无关的函数调用和条件分支，帮助模糊引擎提高路径探索的效率和稳定性。

微模糊测试。我们的模糊测试引擎专注于修剪过的执行树中的指令。从输入源开始，它通过指令级仿真更新执行上下文。模糊测试引擎将执行与输入相关的代码片段，并忽略大量不必要的路径，包括其他输入处理程序。为了检查危险行为，它监视接收函数调用的上下文，并在上下文违反预定义的安全策略时报告潜在的错误。

Concolic分析器。为了从剪枝后的调用图中获取遗漏的上下文信息，我们恢复了修改后的条件分支，并对被忽略的函数的上下文进行了符号化。然后，我们基于前向切片执行concolic执行，并使用bug触发输入来提供具体值。我们执行向后切片，从sink函数开始到写入的对象分配位置和其他输入引用位置。然后，我们从向后切片的结尾开始执行符号执行，以获得对象大小的约束，并迭代其他输入的每个谓词，以检查相应的条件是否必要。最后，我们可以实现一个完整而准确的路径条件来评估漏洞。

我们基于Ghidra[17]和UnicornAFL[25]实现了我们的SFuzz原型，其中包含大约6200行Python代码、4300行C代码和5100行Java代码。为了了解SFuzz在检测RTOS安全漏洞方面的有效性，我们将我们的工具应用于来自11家供应商的35个固件样本。SFuzz在这些最新版本的固件样本中成功发现了77个未知漏洞。我们还将SFuzz与最先进的工具进行了比较，SFuzz优于所有被比较的工具。

综上所述，我们做出了以下贡献:

- 我们提出了一种基于切片的RTOS测试方法，该方法利用前向切片来修剪控制流以进行有效的模糊测试，并结合后向切片来验证来自模糊测试的警报。
- 我们设计并实现了SFuzz，它通过跨平台CPU仿真执行基于切片的模糊测试，有效检测RTOS固件中的漏洞。
- 我们在来自11家供应商的35个真实RTOS固件样本上对SFuzz进行了评估，发现了77个未知bug。已经为68个bug分配了CVE/CNVD id。

## 2.问题和方法概述
在本节中，我们首先提供RTOS漏洞的背景。然后，我们概述了我们的方法并讨论了相关的挑战。

### 2.1 RTOS和嵌入式设备
实时操作系统(RTOS)旨在提供确定性的执行模式。它专注于任务的及时执行，适用于具有实时需求的嵌入式设备，如打印机、交换机和路由器。由于内存空间的限制以及对快速任务调度和快速响应的要求(即性能约束)[20,31]，一些供应商将其RTOS编译为具有所有功能的单个二进制文件。同时，它们还剥离系统符号以减小二进制文件的大小。这些因素给以RTOS为操作系统的嵌入式设备的全系统仿真或安全性分析带来了挑战。

然而，这些设备(如打印机、路由器等)通常会接收来自外部(如网络、蓝牙等)的数据包，并对其进行解析以完成各种任务，从而为攻击者提供劫持它们的方法。同时，这些设备通常是家庭网络或局域网(LAN)的关键点。没有最先进的防御机制，如可执行空间保护[23]和堆栈金丝雀[14]，攻击者会非常关注它们，并喜欢通过它们的数据入口（data entries）来攻击它们。因此，安全研究人员有必要克服这些挑战，提出一种合适的方法，通过易于接触的嵌入式设备的数据入口来检测漏洞。

### 2.2 动机案例
清单1显示了一个简化的代码片段，在第40行中包含一个缓冲区溢出错误。我们使用我们的工具SFuzz在TP-Link WDR7660的RTOS中发现了这个错误，并向其供应商报告了它。该漏洞已被修复，并分配了一个CVE编号CVE-2020-28877。这个代码片段的功能是从外部接收数据(第7行)并调用相应的函数集来处理数据包(第9-44行)。详细地说，它首先进入函数protocol_handler(第9行)，检查包头的基本格式和大小(第15行)，匹配魔术字节(第16行)，并检查整个包的完整性(第17行)。如果输入包满足所有约束，则执行将进入函数msg_handler(第18行)，根据包的版本(第23行)调用相应的处理程序(第24行)。函数parse_advertisement解析并提取结构元素的头(第35-36行)，它是包负载中的基本数据单元，并将元素复制到内存空间(第40行)。因为structure元素中数据部分的长度记录在len字段中，攻击者可以通过精确构造一个包并将len的值设置为大于用于存储数据部分的缓冲区的长度来触发堆栈溢出漏洞。

![](images/Pasted%20image%2020230906105908.png)

不幸的是，目前用于嵌入式系统的bug查找技术无法有效地检测到此漏洞。动态解决方案，如模糊测试和仿真，不能保证模拟具有封闭硬件功能的整个RTOS并覆盖所有程序状态，特别是对于解析自定义数据格式的特定代码。例如，假设我们有一个设备，并希望使用最近的工作SRFuzzer[43]来识别这个bug。在这种情况下，我们必须利用逆向工程来分析设备可以处理的所有数据格式，然后生成和发送请求来触发处理逻辑代码。它需要很高的人工成本，并且对分析人员的要求非常高。静态方法如KARONTE[31]和SaTC[9]不能有效地定位单片RTOS二进制文件中的数据入口。例如，KARONTE只关注与进程间通信相关的数据，而SaTC则使用用于标记用户输入的关键字来查找数据入口。此外，代码段中复杂的代码逻辑(我们简化了动机样本中代码段的控制流图)使他们很难进行静态污点分析或符号执行，以有效地找到从数据入口点(例如recvfrom)到sink函数(例如memcpy)的敏感路径。

### 2.3 SFuzz的必要性和合理性
根据以上分析和比较，动态方法比静态分析方法更适用于检测RTOS漏洞。然而，如果没有大量的人工分析和健壮的全系统仿真方法，我们如何通过动态的方法有效地检测各种嵌入式设备实时操作系统中的这些漏洞?

我们的直觉是，对功能独立的片段进行模糊测试是发现RTOS漏洞的有效方法，我们将其命名为基于片段的模糊测试。假设我们收集一个程序片，其中包含接收和处理相应数据包的完整函数集。通过混合模糊测试和指令级仿真，可以有效合理地检测出代码段中的漏洞。此外，我们可以忽略模拟各种硬件和服务特性的困难。

考虑清单1中的示例，在确定了数据接收函数(第7行)和所有与包处理相关的函数(例如，第40行中的复制)之后，我们可以构造代码片段并生成输入，通过覆盖引导的混合模糊测试触发堆栈溢出漏洞。由于在执行代码片段时缺乏完整的上下文，我们需要处理与外部包无关的控制流节点，以使模糊测试高效和稳定。一旦发现漏洞，我们将根据触发漏洞的输入进行concolic分析，并获得最终结果，包括与我们处理的控制流节点相关的完整约束，以帮助我们确定漏洞是否为假阳性。正如我们所看到的，通过静态分析，我们的方法的探索范围仅限于有风险的代码片段。同时，我们只使用符号执行来帮助我们在模糊测试卡住时创建新的测试用例，并验证崩溃结果。这使得我们的方法与传统的静态分析和符号执行方法相比，具有更好的性能，减轻了路径爆炸问题。

为了证明基于切片的模糊测试方法在RTOS上的合理性，我们选择了来自两家供应商(TP-Link和MERCURY)的四个嵌入式设备的系统，检查它们的功能是否可以划分为特定于任务的独立片段。我们选择这四种设备是因为它们都包含符号文件或日志函数，这便于我们对每个函数的功能进行判断，并对结果进行人工验证。我们搜索系统中所有类型的数据读入点，例如recvfrom函数，并将它们的调用函数(例如devDiscoverHandle)作为数据处理树和特定任务模块的根点。然后递归搜索存在于根点函数及其子函数中的函数调用，形成函数集。我们使用根点函数的名称来命名它的函数集(如UpSet图所示)。理论上，这些函数集应该对应于不同的数据读入点、数据处理任务和功能。只有这样才能证明我们的基于切片的模糊方法是合理的。不同函数集之间的函数交集越少，各函数集的函数独立性越高。

由于这四种设备的验证结果相似，我们以TP-Link WDR7660为例来说明它们的结果。我们提供了CDF图来简化不同功能片段之间的函数交集分布的表示。如图1所示，很少有函数(少于25%)属于多个集合。根据我们的分析，交集主要来自两个方面。一个是标准库的函数(例如recvfrom、memcpy等)，不同的功能将使用它们。二是不同函数集之间的相似性。尽管这些函数集具有不同的数据入口点，但它们处理类似的数据包，例如bindRequestHandle和registerRequestHandle。我们还提供了一个UpSet图(由于页面限制，我们把它放在Github上)，一种用于集合定量分析的可视化技术，以显示从RTOS收集的不同功能集之间交集的细节。

![](images/Pasted%20image%2020230906151441.png)

![](images/Pasted%20image%2020230906151821.png)

为了进一步研究RTOS中模块的耦合度量，我们考察了上述四种嵌入式设备中任务之间的共享数据。结果表明，用于在功能片段之间共享数据的全局变量的比例很低。我们确定了14,592个全局变量，其中207个在我们确定的功能片段中使用，只有27个全局变量被不同的片段共享(不到13%，如图1所示)。此外，我们通过由几个API对(例如set_env和get_env)操作的共享关键字来检查数据共享范式，如KARONTE[31]和SaTC[9]所示。由于其便利性，这种数据共享范例在嵌入式系统中很流行。我们发现这四个使用相应API对的示例中的功能片段之间没有数据共享。

以上分析表明，从RTOS中采集的这些功能集满足控制流和数据流功能独立的特点。因此，实验结果验证了基于切片的模糊方法的合理性。

### 2.4 基于片的模糊测试的挑战
为了将我们的方法应用于各种嵌入式设备的RTOS，我们需要解决三个主要挑战。

**C1.如何确定片段的范围?**

首先，无论目标RTOS是否包含符号文件，我们都需要识别数据读取函数的方法。其次，我们需要一种方法来确定与数据接收点相对应的代码片段的作用域。通过函数调用构造功能集将包括一些与输入数据的处理逻辑无关的路径和函数。同时，一些不能接触到sink函数的路径也会被包含在作用域中。两者都会影响基于切片的模糊检测的效率。

**C2.如何处理与代码片段中的控制流相关的点?**

一些函数调用和条件分支会影响执行路径的可达性和模糊测试的效率。例如，模拟器无法模拟的某些函数将影响路径可达性。另一个例子，一些比较指令将使用全局变量或与我们正在改变的输入无关的变量。因为我们不能通过种子突变来改变这些变量的值，所以我们不能控制这些比较指令的后续分支的跳转方向。

**C3.如何有效地进行基于切片的模糊测试并验证PoC?**

一方面，纯模糊技术在不事先了解应用或输入格式的情况下，很难生成有效的种子来通过各种条件保护[30,35]。与Driller[35]类似，我们将模糊与符号执行相结合，使路径探索更加有效。另一方面，由于我们对代码片段进行模糊测试，并对一些与控制流相关的指令进行预处理，因此我们需要设计一种方法来判断导致崩溃的概念验证(PoC)是否是原始RTOS中的真正漏洞。

## 3.设计
**方法概述**。在本文中，我们设计了SFuzz来解决上述挑战，并利用基于切片的模糊测试技术来检测嵌入式设备RTOS代码片段中的漏洞。如图2所示，SFuzz将实时嵌入式设备的固件作为输入并输出它们的bug报告。它首先恢复RTOS中函数的语义，然后使用前向切片器和Control Flow Nodes处理程序提取与外部输入相关的代码片段。然后，它使用基于片的模糊测试技术来探索代码片段的执行树。最后，构建了基于concolic分析器的PoC。

![](images/Pasted%20image%2020230906153611.png)

其中，前向切片器将调用图分析与前向污点分析相结合，确定每个任务进行基于切片的模糊处理的探索空间;控制流节点处理程序用于帮助后续模糊部分跳过不必要的路径探索和那些会使模糊阶段卡住的节点;微模糊引擎是一种混合灰盒模糊器，它结合了一些低级技术，如错误检测策略，使模糊器能够平稳运行并发现错误;Concolic Analyzer主要是帮助我们过滤由于探索修剪和上下文缺失而导致的误报。

### 3.1 前向切片器Forward Slicer
为了对目标RTOS的功能片段进行基于切片的模糊测试，我们首先恢复固件中关键功能的语义(详细信息见§4)，以定位外部数据入口点(例如，recvfrom)，全局数据共享函数(例如，nvram_get)和易受攻击的函数(例如，memcpy)，然后利用前向切片器模块输出与处理外部输入和全局数据相关的执行树。

Forward Slicer包含三个部分，其工作流程如图2所示。敏感调用图构造器检测输入获取函数(例如，清单1中的recvfrom)和全局数据读取点，然后将这些函数的调用者作为根节点来构建调用图。为了使模糊测试集中在易受攻击的路径上，我们修剪了图中不能接触潜在汇聚函数(即memcpy、strcpy、sprintf等)的分支。调用图修剪组件进一步修剪独立于外部输入的子图或路径。最后，调用图缝合组件在不同调用图的节点之间拼接一些边。由于缺乏直接相关性，在构建这些调用图时缺少这些边。

**调用图剪枝**。为了判断外部输入或全局数据是否会影响潜在sink函数的参数，SFuzz利用轻量级(粗粒度)污点分析技术跟踪调用图中的每条路径(从根节点到叶节点)，确定外部输入和全局数据可能的影响范围，并过滤独立于它们的路径。在这里，我们描述了污染引擎的高层级设计。对于每个调用路径，污点引擎将进入路径中每个节点的函数体。它根据函数的语义将输入接收和解析函数的参数或返回值标记为污染源，例如清单1中recvfrom的参数Global_addr+0x1c，它指向的内存空间用于存储输入数据。在对每条指令进行污点分析时，污点引擎首先将指令翻译成语义比各种不同体系结构的汇编指令更简单的中间指令。然后，对于每个中间指令，如果输入操作数受到外部输入的影响，它将该指令的输出操作数包含到受污染的操作数集中。对于被调用方不属于调用路径的函数调用指令，污染引擎将把污染属性从其污染参数传播到返回值。如果sink函数的风险参数(例如，函数memcpy(\*dest， \*src, count)的count)受到输入的影响，则SFuzz保留相应的调用路径。

> taint analysis的准确率好像确实是不高的，只能是一种粗略的污染，它只标记污点而不包含任何语义信息，有很多会经过（传播）但无影响的也会被标记为污点，实际找到的危险路径根本不可用。

**调用图形拼接**。KARONTE[31]和SaTC[9]提出，一些外部输入的数据流可能被数据共享范式(例如set_env和get_env)中断。不幸的是，RTOS也面临着同样的挑战。与之前的方法不同，除了使用静态分析来拼接确定性关联节点外，我们还使用动态技术来检测数据设置和使用点之间的非确定性相关性。对于用常量字符串标记的数据共享范式(即集合点和使用点)，我们基于常量字符串进行搜索和匹配。然后连接两个调用路径并使用一个虚拟节点(即，两个元组，如<nvram_set, nvram_get>)来表示合并调用图中的范例。对于由动态创建的变量标记的范例，例如清单2中的“wan%d_pppoe_username”，我们基于近似字符串匹配方法获得这些范例，并创建一个虚拟条件节点来连接潜在的数据共享范例。然后根据仿真执行期间变量的实际值确定是否跳转到全局数据读取点。对于设定点有多个对应的得到点，我们还建立虚拟条件节点，并根据随机概率确定跳跃方向。

![](images/Pasted%20image%2020230906155306.png)

### 3.2 控制流节点处理程序
在处理Forward Slicer模块之后，我们可以基于调用图构建目标代码片段的执行树。然而，为了使执行树上的模糊测试顺利进行，避免不必要的路径探索，我们仍然需要处理几种与控制流相关的指令(即(i)函数调用，(ii)条件分支)，这将影响执行路径的可达性和测试的效率。换句话说，由于缺乏RTOS的完整上下文和运行时状态，我们需要策略来指导fuzzer确定如何处理代码片段中的函数调用，并选择跳转条件语句的哪个分支。

**调用指令**。一方面，我们将函数调用指令的地址(其被调用者的参数不受外部输入的影响)添加到PatchFunc集合中，并引导fuzzer跳过函数调用。我们这样做主要是因为它的参数与输入无关，并且它的返回值和参数不会通过改变种子输入而改变。因此，修补这类函数有助于模糊器忽略其复杂性，提高模糊效率。另一方面，对于属于敏感调用图或其参数受输入影响的所有函数调用(如清单1中的protocol_handler和header_check)，我们保留它们。只有逐步进入这些功能，才能保证敏感路径的可达性。

**条件分支**。条件语句仅在满足指定的分支约束时才将控制流定向到目标地址。然而，在对代码片段进行模糊测试时，如果条件与输入数据没有关系，我们必须面对确定条件跳转方向的问题，这意味着我们不能通过改变输入来改变跳转方向。为了使模糊测试更加有效和合理，我们提出了几种处理各种条件分支的方法。

- 假设只有条件跳转指令的一个分支能跳转到sink函数。如果它的条件受到输入的影响，我们将不可达分支的目标地址插入到PatchedJMP集，这将引导模糊器避免探索该分支。否则，我们将跳转指令的地址添加到PatchchJMP集合中，并引导模糊器将条件跳转替换为可到达分支的固定跳转。
- 假设条件语句的两个分支都可以到达sink函数。如果它的约束与输入数据无关，我们将指令的地址添加到PatchedJMP集合中，这将引导模糊器用随机跳转语句替换该指令。否则，我们不更改代码，它主要是帮助我们探索尽可能多的不受输入决定的路径。
- 如果没有一个条件跳转指令的分支可以到达sink函数，我们将两个分支的目标地址添加到PatchedJMP集合中，这将引导模糊器在遇到这些地址时退出当前的路径探索。

### 3.3 微模糊测试
作为模糊测试引擎的核心，我们将基于切片的模糊测试技术称为微模糊测试。它将代码片段作为输入，探索执行树中的路径，并忽略不相关的调用点和其他输入数据处理程序。该引擎在根据预定义策略访问内存时检查sink函数调用点的上下文并导出崩溃输入。

**镜像加载程序**。加载RTOS固件后，镜像加载器将预处理由上一个模块标记的裁剪的代码片段。对于应该被跳过的调用指令(在PatchedFuncset中)，镜像加载程序将调用指令替换为类似nop的指令。对于应该避免被探索的分支(在PatchedJMPset中)，SFuzz将AvoidExplore语句添加到其目标地址。当程序执行到相应的地址时，程序将直接退出当前的路径探索。对于应该用固定跳转或随机跳转替换的分支，SFuzz用相应的操作处理它。

**模糊测试引擎**。当核心引擎被调用时，它会加载RTOS系统，并从最开始(执行树的根节点)重复执行目标代码片段。该引擎将在输入入口点生成随机数据。基于UnicornAFL，该引擎可以执行覆盖率引导的模糊测试，并在此修剪的执行树上模拟指令执行。当核心模糊测试引擎卡住时，混合模糊测试会调用其concolic执行组件。该组件从种子队列中随机选择一个输入，并标记输入中的每个字节。在跟踪与输入相对应的执行路径之后，concolic执行组件利用其约束求解引擎来识别将强制执行以前未探索过的路径的输入。如果在阈值时间内没有找到新的路径，模糊检测引擎将退出。

通过修剪不必要的路径，Micro Fuzzing忽略输入相关的函数调用(在PatchedFuncset中)并执行nop类指令。另一方面，它直接跳过仿真困难指令，避免标记的条件分支(在PatchedJMPset中)，并在指针引用未初始化内存时分配具体值。仿真困难指令通常与与硬件或HAL(硬件抽象层)模块交互的中断相关(例如，向CPU调度程序发送信号)，并且不影响从输入源开始的数据流。因此，在模拟中跳过这些指令带来很少的副作用。最后，这两种方法使仿真更加稳定，并专注于探索处理目标输入数据的代码片段。

**内存安全策略**。因为裸机[32]和RTOS设备由于成本敏感性和资源限制往往缺乏内存消毒机制。因此，SFuzz需要为模糊引擎提供轻量级的内存安全检查策略，该策略定义了sink函数调用点的内存访问违规。在这里，我们主要关注检测内存缓冲区操作中出现的错误。我们将内存缓冲区分为两类:可以静态分析确定大小的缓冲区(包括堆栈上的缓冲区，通过类似malloc的函数创建的缓冲区，可以根据相邻变量识别其大小的全局变量等)，以及不能静态确定其大小的缓冲区。对于可以静态识别大小的缓冲区(SFuzz在正向切片器模块中进行分析)，我们在执行sink函数后，通过检测缓冲区边界数据是否被修改来判断是否发生溢出。对于无法确定缓冲区大小的缓冲区，我们直接输出报警，并在后续的concolic分析模块中进一步识别缓冲区大小。

### 3.4 Concolic分析器
当Micro Fuzzing引擎退出时，Concolic Analyzer将检查所有触发违规的崩溃输入。将这些案例作为具体输入，在相应的执行路径上进行concolic执行，求解约束。

由于经过修剪的函数调用指令(在PatchedFuncset中)和条件分支(在PatchedJMPset中)可能会误导原始执行树中的控制流，因此我们需要检查崩溃输入是否会触发原始RTOS中的真正漏洞。为了进行检查，Concolic Analyzer首先恢复这些分支，并在这些补丁的函数调用点中标记参数和返回值，然后进行基于正向和向后切片的Concolic测试。

工作流如算法1所示。其中，基于前向切片的concolic测试部分以crash输入作为具体值，在该输入触发的路径上执行concolic执行。如果路径中的函数调用位置属于PatchedFuncset，它将对函数的参数和返回值应用新符号。它收集所有约束以及执行路径，直到到达sink函数。对于与其他输入数据入口点或补丁函数相关的约束，基于向后切片的条件验证器每次翻转每个约束一次，并使用给定的反向约束从头开始重新运行符号引擎。对于与其他输入数据入口点或补丁函数相关的约束，基于向后切片的条件验证器每次翻转每个约束一次，并使用给定的反向约束从头开始重新运行符号引擎。如果符号引擎仍然可以到达汇聚函数，则判断当前PoC不需要相应的约束。对于先前模块中没有确定的与接收缓冲区大小相关的约束，验证器将计算其值，并仅在可以确定接收缓冲区大小并被输入数据溢出时发出警报。

![](images/Pasted%20image%2020230907145459.png)

我们使用一个真实的样本(CVE-2021-32186)来展示Concolic分析器是如何工作的。如清单3所示，nvram_set和nvram_get构造了一个数据共享范例。当另一个标记为“LEDStatus”的数据被设置为“2”时，标记为“LEDCloseTime”的数据源被传递到NVRAM (Non-volatile randomaccess memory)，然后在vulnGet中触发堆栈缓冲区溢出。

![](images/Pasted%20image%2020230907150600.png)

**基于前向切片的concolic测试**。在获得崩溃输入后，Micro Fuzzing还输出相应的执行路径，包括输入入口点和sink函数调用点。如清单3所示，入口点在第8行，由于这个切片是由数据共享范式拼接的，所以当前函数vulnSet中的sink点是nvram_set(第17行)。因此，我们从第8行执行concolic测试，并在第17行检查执行路径条件。在这个过程中，符号执行引擎收集路径约束，包括参数的符号表达式和第9行、第10行和第14行其他输入数据读取函数的返回值。最后，路径条件(第17行)包含所有这些其他输入数据，因为它们分别构成第11、13和16行中的分支条件。

**基于向后切片的条件验证器**。虽然执行路径约束可以给出每个输入数据应该满足的特定约束集，但它仍然缺少两部分关键信息:一是对其他输入数据的约束是否必要，这将在bug检测中带来假阴性;其次，由sink函数写入的对象的大小约束，这将带来假阳性和假阴性。据此，我们从两个方面解决问题：
- 如清单3中的vulnSet所示，向后切片从第17行中的sink函数开始，并向后跟踪执行路径。通过检查sink函数中的执行路径条件，我们提取了包含其他输入数据的约束，并在第9行、第10行和第14行中将相应的源位置定位为向后切片的终点。我们反转这些约束并分别重新运行符号执行，从相应的向后切片端点通过符号执行来检查可满足性。如果状态仍然可以到达sink函数，则证明约束对于到达sink点是不必要的。最后，我们可以删除非必要的约束(第11行)并包含必要的条件(第13行和第16行)。
- 如清单3中的vulnGet所示，向后切片从第25行中的sink函数开始，并回溯执行树。在这个过程中，回溯主要关注当前函数作用域，捕获与这个写入对象相关的任何内存处理程序函数，并将最远的调用位置设置为终点(第23行)。最后，符号执行从终点开始，利用相关处理程序的函数语义解决分配大小的约束。

## 4.实现
我们用大约6200行Python代码、4300行C代码和5100行Java代码实现了SFuzz的原型系统。污点分析模块和语义恢复部分基于Ghidra实现[17]。模糊测试引擎基于UnicornAFL和Driller[35]构建，concolic分析器基于Angr[36]实现。我们扩展了Driller，使其适用于RTOS映像，包括基于我们自己设计的RTOS加载器重新实现其跟踪记录器，以跟踪目标代码片段的执行轨迹。我们的系统基于以下几个基本程序:

**镜像提取**。我们利用嵌入固件中的字符串来识别RTOS的类型(例如，VxWorks 5.5.1)，并利用BinWalk来提取RTOS映像的内容。同时，对于内容的反汇编，我们利用图像中机器代码的特征来确定CPU架构的类型(例如，MIPS)。

**基址识别**。由于RTOS系统中许多数据引用或函数调用操作依赖于基址，错误的基址会导致错误的数据引用或控制流跳转。我们实现这一部分的核心思想是，只有正确的基址才能将大多数数据引用指针与预期目标链接起来。该方法在Vxhunter[45]中提出，并在一些相关作品中使用，如FirmXRay[37]。该模块包含两个步骤来识别基址。首先从系统中识别并提取数据引用指针;其次，它将数据指针的绝对地址与预期目标相匹配。应该声明:(i)我们只使用字符串指针来帮助识别基于地址，这已经足够好了(如§5.4所示);(ii)我们基于PCode实现该方法，PCode是Ghidra对汇编语言指令的中间表示，而不是特定架构的指令。因此，它可以支持更多的体系结构。

**功能语义重构**。如§3.1所述，我们需要函数语义来指导污点分析并定位敏感片段。SFuzz主要恢复三种函数的语义和功能:(i)接收、解析或共享外部输入数据(即用户输入)的函数;(ii)sink函数(如memcpy);(iii)设置或获取全局数据的函数。我们实现了四种方法来自动恢复函数的函数语义和识别敏感函数。

- **符号文件和日志功能**。根据我们的分析，一些供应商(例如TP-Link和MERCURY)会发布标记函数名称的符号文件;同时，用于输出运行时错误的日志函数也可以用于恢复函数名。根据我们的分析，一些供应商(例如TP-Link和MERCURY)保留了可以标记固件中功能名称的符号文件。同时，一些厂商使用日志函数输出运行时错误，这也可以帮助恢复函数名，如语句logOutput(ostream， "devDiscover: error, ret = %d"， retcode)中的devDiscover。
- **虚拟执行**。首先，该方法将目标函数的参数和返回值的数量与标准库函数进行比较，以找到潜在的匹配函数，例如strcpy。其次，它分配内存空间，初始化寄存器的状态，并设置函数参数的初始值。最后在函数体中对代码进行仿真，通过分析输出值和仿真对内存空间的影响来确定匹配的函数。我们利用这个方法来识别标准库函数，比如memcpy和printf。
- **Web服务语义**。我们在前端文件(例如HTML、PHP和JavaScript)和后端文件中利用用于标记用户输入的共享字符串来恢复与web服务相关的一些函数的语义。我们基于SaTC[9]中提出的方法实现了该方法。
- **开源固件**。一些供应商选择开源的RTOS项目来构建他们的系统，比如eCos和FreeRTOS。对于这些类型的系统，在预处理固件时确定其版本后，我们可以利用B2SFinder[42]和其他一些工具[41]，根据代码中嵌入的字符串、即时和其他显式特性，将固件中的功能与开源项目中的功能进行匹配。

## 5.评估
为了评估我们的方法，我们应该回答以下研究问题：

RQ1.SFuzz能在嵌入式设备的RTOS中发现真实世界的漏洞吗?(§5.1)

RQ2.SFuzz的每个部分对于有效发现RTOS中的bug是否都是必要的?与最先进的工具相比，我们的工具表现如何?(§5.2和§5.3)

RQ3.SFuzz在每个步骤中是否都能准确有效地发现漏洞?(§5.4)

**数据集**。如表1所示，我们从11家供应商的17个系列中收集了35个固件样本。这些设备涵盖三种RTOS类型，提供各种服务，包括23台路由器、7台打印机、2台防火墙、2台交换机和1台脑机接口(BCI)。在这些样本中，7个器件采用MIPS-BE架构，13个器件采用MIPS-LE架构，1个器件采用ARM-BE架构，另外14个器件采用ARM-LE架构。每个固件平均为9兆字节，而SFuzz总共处理了314兆字节。

**环境设置**。我们的实验运行在一台Ubuntu 18.04主机上，它的RAM为256GB, 32核Intel Xeon处理器的频率为2.4 GHz。特别是，我们将每个实验的模糊处理部分的时间限制为处理一个数据入口时的6小时，并且每个实验使用一个CPU内核进行操作。根据我们的观察，在这个时间线之后，没有任何实验可以找到新的路径或崩溃。

**实验设计**。为了回答RQ2，我们设计了5个实验，对选择的RTOS进行不同配置的测试，如表2所示。SFuzz是一个功能齐全的模糊器，它利用函数调用和条件跳转指令的处理程序，以及符号执行引擎来增强模糊器。SFuzz-Handler不使用控制流节点处理程序(§3.2)来处理与控制流相关的关键节点。SFuzz-FHandler只处理条件分支语句，而SFuzz-CHandler只处理函数调用指令。最后一个实验是使用现有的最先进的代码片段模糊器UnicornAFL[25]进行的，我们改进了它的程序加载器，使其适用于我们数据集中的各种RTOS固件。注意，普通的灰盒模糊器(例如，UnicornAFL)和其他方法(例如，SFuzz)从一开始就部署在相同的原始执行树上。然后，每种方法根据各自的原则应用量身定制的策略。

![](images/Pasted%20image%2020230913154655.png)

**错误确认**。SFuzz生成的每个警报都包含来自源点的唯一崩溃输入和路径约束的符号表达式，路径约束可能包括其他数据源或全局变量。我们手动验证每个警报，只有它会导致真正的bug我们才认为它是一个漏洞。

### 5.1 真实世界漏洞
SFuzz在20个不同设备的固件样本中发现了77个新Bug，包括路由器、打印机、防火墙和BCI。截止提交时，68个漏洞已被厂商确认，67个漏洞已被分配CVE或CNVD ID (CVE 46个，CNVD 21个，重度漏洞64个);9个bug仍在等待供应商的回复。图3显示了与这些bugs相对应的数据接收点和代码片段的任务类型。详细地说，这些Bugs存在于许多不同的任务中，例如HTTP、UDP和蓝牙。此外，输入数据来自多个数据源，例如Web解析器、NVRAM处理程序和Socket处理程序。此外，我们还列出了数据集中已发现bug的详细案例研究。

### 5.2 现有方法对较
为了了解SFuzz的每个组件对模糊测试结果和性能的贡献，并分析我们的工具与其他“类似”工具相比的实际性能，我们设计了这个实验。由于所有这些工作都不能直接应用于RTOS，并且很难迁移到RTOS，因此我们对这些工作进行了模拟，如实验设置部分所示。SFuzz-FHandler中使用的策略是T-Fuzz中使用的策略的超集[26]，T-Fuzz不是完全开源的，不能用于RTOS的代码片段。因此，这里我们使用SFuzz-FHandler来表示T-Fuzz。同时，SFuzz-FHandler相当于执行代码片段的Driller[35]的一个版本。我们为所有这些工具提供从五个设备收集的相同的执行树，并从读取数据包的相同源点启动它们。通过对五种工具的实验，从有效性、稳定性和效率三个方面对其性能进行了比较。

**有效性**。如表3所示，5种工具都能在一定程度上发现真实设备中的漏洞，数量从4个到34个不等。UnicornAFL和SFuzz-Handler都只能从4棵执行树中找到bug，它们只探索了1390条和1366条执行路径。当我们在SFuzz-Handler的基础上应用Cbranch补丁时(即SFuzz-FHandler或T-Fuzz)，我们可以看到，尽管探索路径的数量增加了149%，达到3397条，但实际可以发现的Bug数量基本相同。当我们在SFuzz-Handler的基础上应用FuncCall补丁时(即SFuzz-CHandler)，虽然路径探索只增加了23%，但在19棵执行树上发现了17个bug。我们的完整方法结合了上述模式，最终可以在5个模型的105个执行树上触发多达134个独特的崩溃，并发现34个bug。SFuzz的性能优于所有的比较工具。

![](images/Pasted%20image%2020230908082749.png)

**稳定性**。为了比较这些工具之间的稳定性，我们检查了五个设备上所有模糊执行的成功模拟比率。如结果所示9，不同的设备在不同的工具之间有不同的稳定性变化，但我们仍然发现FHandler(处理函数调用指令)大大提高了稳定性。其中，Tenda AC11的稳定性从6.02% (SFuzzHandler)提高到97.69% (SFuzz-CHandler)， TP-Link WDR7660从27.98% (SFuzz-Handler)提高到64.62% (SFuzz-CHandler)。另一方面，CHandler(处理条件分支)带来了一些轻微的不利影响。因此，SFuzz同时应用了FHandler和CHandler，并能保持令人满意的稳定性。

**效率**。在检查这五种工具的时间消耗时，我们发现应用的方法越复杂，用于测试的时间就越多。实验结果10显示了不同工具在每个设备上花费的平均模糊时间。具体来说，UnicornAFL、SFuzz-Handler、SFuzz-FHandler、SFuzz-CHandler和SFuzz在对一台设备的一个执行树进行模糊测试时，平均耗时分别为29s、723s、909s、1006 s和1049 s。这表明SFuzz花费更多的时间，但保持一个可接受的范围。

### 5.3 与符号执行比较
我们进行了全面的实验来比较SFuzz与传统的符号执行(SE)技术。由于没有现有的SE工具可以直接测试RTOS，我们基于Angr[36]自己实现了一个原型，Angr是一个流行且维护良好的SE工具。我们在表4中列出了结果。结果表明，切片方法显著提高了bug发现效率。我们还将SFuzz的控制流节点处理程序添加到SE工具中。结果表明，该处理程序可以提高SE在bug发现和路径探索方面的性能。

**Bug数量**。SFuzz可以在5个供应商的样本中找到34个bug。符号执行(SE)只显示了8个bug。在控制流节点处理程序的帮助下，SE+Handler可以发现19个错误。

**暴露时间**。与其他方法相比，SFuzz可以在更短的时间内发现bug。对于Tenda样本，SFuzz在33分钟内发现一个bug, SE+Handler需要52分钟，SE需要72分钟;对于TPLink, SFuzz发现一个bug用时27分钟，SE+Handler用时204分钟，SE没有发现任何bug;对于RICOH样品，SFuzz在16分钟内发现一个错误，SE+Handler需要97分钟，SE需要178分钟;对于FAST, SFuzz发现一个bug需要27分钟，SE+Handler需要79分钟，SE需要213分钟;对于MERCURY，SFuzz在38分钟内找到一个bug, SE+Handler需要47分钟，SE需要226分钟。

**路径探索**。我们的切片方法有助于获取比其他方法更多的路径，并且更适合于模糊场景而不是符号执行。对于Tenda示例，SFuzz可以探索2,484条路径，SE+Handler执行389条路径，SE运行491条路径;对于TP-Link, SFuzz可以浏览235条路径，SE+Handler可以浏览83条路径，SE只能浏览40条路径;对于RICOH，SFuzz可以探索122,SE+Handler可以探索38,SE可以探索95;对于Fast, SFuzz可以探索815,SE+Handler运行411，而SE只执行143;对于MERCURY, SFuzz可以探索53,SE+Handler运行72,SE运行107。在这些示例中，SFuzz总共探索了3709条路径，SE+Handler执行了993条路径，SE只运行了876条路径。应该注意的是，SFuzz在MERCURY中运行的路径更少，因为它比其他程序在更短的时间内找到bug。

![](images/Pasted%20image%2020230913165416.png)

### 5.4 准确率和效率
在本节中，我们评估了SFuzz的每个部分的准确性和效率，包括前向切片器(即语义重构和前向切片)，微模糊和Concolic Analyzer。

**语义重建**。在我们的数据集中，有31个样本可以通过SFuzz进行分析。该基址识别模型能够正确识别25个固件样本的基址。其中FAST FW325R、FAST FW313R、MERCURY MW325R、TP-Link WDR5660、腾达AC5、腾达AC6V2 6种型号无法自动识别，其基址由人工分析确定。通过符号表和人工验证，我们发现SFuzz自动恢复的语义大部分都是准确的，交叉验证准确率在90%以上。通过符号文件恢复方法对七个模型的语义进行了恢复。Web服务语义恢复方法对7台腾达设备的Web输入功能进行语义识别。虚拟执行方法可以恢复24个样本的语义。8个模型使用日志函数模式来恢复它们的函数语义。特别是在RICOH-SP330(一台打印机)中，SFuzz只找到一个用户输入数据读取函数(即os_file_get)。因此，它只提取一个相应的敏感调用图。此外，我们还提供了数据集中所有显示的输入源和接收函数的列表。

**前向切片器**。为了了解切片方法的准确性，我们需要检查该方法是否会导致丢失基于全局变量的敏感数据流影响，这些全局变量在控制流代码处理程序处理的补丁函数的范围内引用。因此，我们测量对数据流和控制流的可能影响，具体来说，我们计算补丁函数可以通过全局变量影响输入数据和分支条件的程度。最后，我们将每个比例计算到补丁函数中。如表6所示，这两个模型的比值都保持在一个较低的范围内(4.67%和4.33%)，这意味着敏感数据流通过全局变量泄露的可能性是可持续的。

![](images/Pasted%20image%2020230908085709.png)

为了检查切片方法的效率，我们需要将切片的大小与整个二进制文件进行比较，并检查在切片中处理了多少函数调用指令和条件分支，以及在这些处理过的位置中，将在下面的模糊处理过程中触发多少个站点。如表5所示，切片呼叫图中函数数占总函数数的比例平均为1.52%。因此，它表明我们的切片足够小，可以节省分析工作。在这些调用图中，处理函数调用指令和条件分支的比例平均为89.32%和18.02%。此外，24.71%的处理呼叫指令和13.9%的条件分支在随后的模糊处理过程中被触发。由此证明，这些修剪过的部位是必要的，在接下来的过程中确实做出了努力。

![](images/Pasted%20image%2020230908085731.png)

微模糊测试。在表7中，我们工具的Forward Slicer可以找到340个独特的执行树，这些树可能在11个不同的模型中引入bug。Micro Fuzzing引擎识别245个易受攻击的接收函数，并构建与这些潜在漏洞相对应的崩溃输入。对一个执行树的平均分析时间从不到7分钟到超过半小时不等。一个模型的总分析时间从20分钟到21小时不等，这取决于要探索的执行树的复杂性。

![](images/Pasted%20image%2020230908085838.png)

Concolic Analyzer。Micro Fuzzing模块忽略了其他可能影响bug执行路径的输入数据，补丁后的控制流节点可能会影响我们改变的输入。因此，从sink函数调用点的模糊测试中获得的唯一崩溃的数量通常大于实际的bug。如表8所示，SFuzz可以在302个唯一崩溃中找到115个警报，并在PoC结果中捕获67个其他输入。通过人工努力，我们在这些警报中找到了16个假阳性病例和8个SFuzz无法显示的假阴性病例。由于页面限制，我们在Github上给出了原因和如何确定这些情况。最后，SFuzz可以发现99个真正的bug(一个bug可能存在于一个供应商的多个设备中)。因此，在这些设备的107个漏洞(唯一漏洞数为75个)中，唯一漏洞总数为69个(准确地说，DLink有3个重复，RICOH有2个重复，Tenda有25个重复)。

![](images/Pasted%20image%2020230908090151.png)

## 6.相关工作
**RTOS安全**。Armis Labs[2]揭示了可以远程危害最流行的实时操作系统Vxworks[33]的关键零日漏洞，并演示了如何利用这些发现的漏洞接管整个工厂[18]。Zhu等人[45]介绍了如何通过模糊测试和调试VxWorks设备来发现漏洞。然而，目前的方法不是通用的，需要依靠设备进行调试[45]，或者需要大量的人工进行分析[33]。

**符号执行**。欠约束符号执行[28]和组合符号执行[1,27]可以分析UNIX操作系统中的程序，如UC-KLEE[28]、RWSet[3]及其改进方法[4,22,40]。它们识别影响新代码可达性的关键数据(例如，读写集[3]，相关位置集[4])，并在探索代码空间时检测和消除冗余状态和路径。我们的切片方法根据当前函数是否与处理外部输入相关来修剪路径。探索这些不相关的函数无助于发现bug，但可能会使指令模拟失败或使测试卡住。因此，在SFuzz中消除路径被设计为启动RTOS中的模糊测试，并且在原理和目标上独立于这些工作。UC-KLEE[28]执行功能范围分析，但缺少过程间数据流。此外，这些高级方法[1,3,4,27,28]都是为检查源代码或IR而设计的，这在成熟的操作系统中很流行，但在RTOS中很少。因此，这些方法需要在RTOS的二进制上进行大量的扩展，并且在低级指令上运行时具有很高的计算复杂度。注意，无论在Micro Fuzzing引擎还是Concolic Analyzer模块中，SFuzz都是基于对具体输入进行符号化来执行符号执行的。因此，它们在由这个具体值(例如，崩溃输入)触发的路径中迭代分支，并缓解路径爆炸问题。

**灰盒模糊和动态测试**。AFLGo[5]提出了定向灰盒模糊，它使模糊器生成输入以有效地到达一组给定的目标程序位置(即易受攻击的功能)。Hawkeye[8]基于静态信息和执行轨迹对运动过的种子进行评估，生成动态指标，帮助Hawkeye获得更好的触点性能。然而，定向模糊测试的目标是到达敏感位置，而不考虑执行路径中的障碍，这些障碍阻碍了RTOS中有效的模糊测试和稳定的仿真。同样，IntelliDroid[39]可以直接生成触发目标Android api的输入，作为恶意行为的过度近似，并允许动态分析来确定它们是否恶意。然而，它必须与全系统动态分析工具(例如TaintDroid)一起工作，这在RTOS中很难满足。HARVESTER[29]将程序切片与动态执行集成在一起，从高度混淆的Android恶意软件中自动提取运行时值。这些先进的测试方法在成熟的操作系统上运行良好。然而，由于缺乏用于RTOS的稳定的系统范围仿真解决方案，如果没有灰盒环境来动态检查目标程序的上下文，它们就无法成功。请注意，我们的切片确定了受污染数据的粗略范围，并定制了阻碍RTOS二进制文件中有效模糊和稳定仿真的障碍。它们使随后的模糊测试过程在指令流方面的代码片段上流畅有效地工作，而无需系统范围的仿真。应用定向模糊策略可以提高效率，我们将在未来的工作中整合它们。

**代码片段执行**。已经提出了几种方法来直接测试隐藏在“深层”代码中的易受攻击的函数。Ispoglou等人[19]提出了一种工具FuzzGen，它可以自动合成fuzzers，用于在给定环境中触发库中的深层代码。然而，FuzzGen需要编译目标库及其consumers的源代码来推断库的接口。Voss[25]设计了将基于consumers的测试consumers添加到正常AFL的UnicornAFL。因此，它可以模糊二进制代码与许多CPU架构，包括ARM, X86等。然而，UnicornAFL只模拟指令，不能模拟外设交互和过程间调度，并且通常也不能执行相关指令(例如中断)。

## 7.总结
我们提出了一种新的基于切片的模糊检测方法SFuzz来检测RTOS中的安全漏洞。基于RTOS单片系统可以被分割成有意义的代码片的洞见，SFuzz利用前向切片来构建一个定制的执行树，该树足够小，可以在模拟器上驱动灰盒模糊测试，并利用前向和后向切片来执行concolic测试，以验证来自模糊测试的独特崩溃。SFuzz在20个RTOS设备中成功发现了77个零日软件漏洞，并为67个设备分配了CVE或CNVD ID。我们的评估结果表明，SFuzz的每个部分都帮助它在发现RTOS中的错误方面优于最先进的工具(例如，UnicornAFL)。
