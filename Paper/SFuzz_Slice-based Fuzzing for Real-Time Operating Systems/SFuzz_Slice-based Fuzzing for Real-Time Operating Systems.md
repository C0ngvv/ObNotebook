

# 翻译
SFuzz:针对实时操作系统的基于片的模糊测试
## 摘要
实时操作系统(RTOS)已成为嵌入式系统的主要类别。它被广泛用于支持需要实时响应的任务，如打印机和交换机。由于RTOS运行在与攻击者隔离的特殊环境中，其安全性长期以来一直被忽视。然而，随着物联网设备的快速发展，大量的RTOS设备接入了公共网络。由于缺乏安全机制，这些设备极易受到各种攻击。更糟糕的是，RTOS的单片设计将各种任务和服务合并到一个二进制文件中，这阻碍了当前在RTOS上工作的程序测试和分析技术。

在本文中，我们提出了一种新的基于切片的模糊器SFuzz来检测RTOS中的安全漏洞。我们的见解是，RTOS通常将复杂的二进制文件分成许多独立但单一的任务。每个任务以确定的方式完成一个特定的事件，其控制流通常是直接和独立的。因此，我们从单片RTOS二进制文件中识别出这样的代码，并合成一个切片进行有效的测试。具体来说，SFuzz首先识别处理用户输入的函数，构造从这些函数的调用者开始的调用图，并利用前向切片来基于调用图构建执行树，并修剪独立于外部输入的路径。然后，它在粗粒度范围内检测并处理阻碍有效模糊测试的障碍，例如与用户输入无关的指令。然后，它对这些代码片段进行覆盖引导的模糊测试。最后，SFuzz利用前向和后向切片来跟踪和验证每个路径约束，并确定在fuzzer中发现的错误是否是真正的漏洞。SFuzz在35个RTOS样本中成功发现了77个零日漏洞，其中67个已被分配CVE或CNVD id。我们的经验评估表明，SFuzz在测试RTOS方面优于最先进的工具(例如，UnicornAFL)。

关键字：RTOS；基于片的模糊测试；污点分析；混合执行

## 1.引言
实时操作系统(RTOS)是为实时应用程序服务而设计的。它已被广泛部署在嵌入式微控制器和cpu之上，安装数量甚至超过了成熟的操作系统。例如，VxWorks，业界领先的RTOS[38]，运行在超过20亿台设备上[33]。RTOS的许多行业场景不仅需要实时、确定性的性能，而且还需要安全认证，如NASA的InSight航天器[24]

然而，由于各种发展限制，将传统的安全机制应用到RTOS中是具有挑战性的。例如，为了支持对实时任务的即时响应，RTOS放弃了内核和用户空间之间的隔离[20]，以平面模式运行所有任务，以避免频繁的上下文切换。在这种情况下，所有软件模块都可以不受限制地访问内存空间中的所有数据和指令[11]，这给RTOS带来了更多的潜在威胁。这种单片设计是可以接受的，因为RTOS主要在本地网络中运行，并且与外部威胁隔离。

如今，物联网(IoT)将更多的RTOS设备直接连接到互联网，这为外部攻击者打开了RTOS设备的大门。在攻击者破坏这些薄弱设备之前，发现RTOS系统中的漏洞是当务之急。尽管许多研究者提出了各种针对嵌入式设备的漏洞检测机制[7,9,21,31,44]，但能够直接应用于RTOS的机制很少。主要原因是RTOS通常以blob-firmware格式呈现，并且在单个单片执行中几乎不运行在微控制器和cpu上，包括内核模块、调度模块和其他任务模块。这个特性给传统的bug检测机制带来了困难。

对于静态分析[9,31]，考虑到单片RTOS二进制文件的大容量，经典的静态方法(例如符号执行[6,10,34])存在路径爆炸问题。此外，由于缺乏显式的函数符号和RTOS的复杂性，很难在二进制级别上揭示函数的语义。因此，我们无法轻易识别与敏感数据相关的模块，也无法对这些模块进行分析。动态解决方案[7,21,37,44]，如模糊测试，要么需要实际设备，要么依赖于正确和稳定的仿真来测试目标固件和基本服务。由于来自不同供应商的RTOS[15,16,38]采用具有不同接口的各种外设，因此用可管理的努力模拟所有现实世界场景是具有挑战性的。

随着RTOS得到越来越多的关注，一些工作开发了定制的工具来检测RTOS中的错误。Zhu等人[45]介绍了一种调试方法来检测基于vxworks的物联网设备的漏洞。Wen等[37]提出在BLE设备上检查裸机固件的配置错误。然而，这些方法要么只能在特定设备上工作，要么依赖于真实设备[45]，要么只能检测到有限的漏洞类型[37]。Salehi等人[32]插桩裸机固件二进制文件来观察内存损坏。Clements等[12]扩展了HALucinator[13]以与VxWorks一起工作。然而，这些工具需要手工分析和领域知识，因此很难应用于不同的RTOS系统。这些工作中的许多甚至需要RTOS的源代码来获得更多的硬件细节[12,13]，或者需要大量的扩展开发来进行有效的模糊测试[32]。因此，它们都受到可伸缩性的限制。总的来说，缺乏一种灵活和通用的方法来有效地发现RTOS中的漏洞。

尽管困难重重，但我们注意到，特定的RTOS特性为绕过测试障碍提供了独特的机会，比如多任务机制。具体来说，RTOS通常将复杂的应用程序划分为许多独立但单一的任务。每个任务以确定的方式完成一个特定的事件。每个原子任务的控制流通常是直接和独立的。更重要的是，如果这些任务属于同一类别，它们的数据流可能具有相似的模式。因此，我们搜索从各种外部数据条目开始到潜在sink函数(例如，memcpy)的数据流，并在RTOS任务之间切片相应的代码片段。这些片段足够小，可以使用现有的模糊测试逻辑进行测试。此外，它们提供了更小但更关键的控制流范围。它可以大大减轻仿真难度和分析复杂性，这将允许我们执行更有效和高效的测试，如灰盒模糊和符号执行。

基于我们的见解，我们提出了SFuzz，这是一种新颖的模糊测试方法，它利用前向切片来构建定制的代码空间，从而在模拟器上驱动灰盒模糊测试。然后，SFuzz结合向后切片来执行concolic执行，以验证来自模糊的崩溃输入。我们设计的SFuzz有四个主要组件:

切片器。我们的代码切片器首先识别处理用户输入的函数。由于RTOS二进制文件没有函数名，我们定义了一组启发式方法来定位这些函数。之后，我们构造一个从这些函数的一个调用者开始的调用图。通过粗粒度传播，我们通过修剪独立于外部输入的路径，在该调用图中执行前向切片。我们还修改了与输入无关的条件分支，以确保控制流达到潜在的sink函数。由于覆盖了直接物理内存访问的数据共享范式(在RTOS中经常使用)，我们的前向切片器可以灵活地跨不同的任务扩展，并在执行中动态地缝合路径。

控制流节点处理程序。如果直接执行代码片段，模糊测试引擎将缺乏RTOS的完整上下文和运行时状态。因此，使用控制流节点处理程序来指导模糊器确定如何处理与用户输入无关的函数调用和条件分支，帮助模糊引擎提高路径探索的效率和稳定性。

微模糊测试。我们的模糊测试引擎专注于修剪过的执行树中的指令。从输入源开始，它通过指令级仿真更新执行上下文。模糊测试引擎将执行与输入相关的代码片段，并忽略大量不必要的路径，包括其他输入处理程序。为了检查危险行为，它监视接收函数调用的上下文，并在上下文违反预定义的安全策略时报告潜在的错误。

Concolic分析器。为了从剪枝后的调用图中获取遗漏的上下文信息，我们恢复了修改后的条件分支，并对被忽略的函数的上下文进行了符号化。然后，我们基于前向切片执行concolic执行，并使用bug触发输入来提供具体值。我们执行向后切片，从sink函数开始到写入的对象分配位置和其他输入引用位置。然后，我们从向后切片的结尾开始执行符号执行，以获得对象大小的约束，并迭代其他输入的每个谓词，以检查相应的条件是否必要。最后，我们可以实现一个完整而准确的路径条件来评估漏洞。

我们基于Ghidra[17]和UnicornAFL[25]实现了我们的SFuzz原型，其中包含大约6200行Python代码、4300行C代码和5100行Java代码。为了了解SFuzz在检测RTOS安全漏洞方面的有效性，我们将我们的工具应用于来自11家供应商的35个固件样本。SFuzz在这些最新版本的固件样本中成功发现了77个未知漏洞。我们还将SFuzz与最先进的工具进行了比较，SFuzz优于所有被比较的工具。

综上所述，我们做出了以下贡献:

- 我们提出了一种基于切片的RTOS测试方法，该方法利用前向切片来修剪控制流以进行有效的模糊测试，并结合后向切片来验证来自模糊测试的警报。
- 我们设计并实现了SFuzz，它通过跨平台CPU仿真执行基于切片的模糊测试，有效检测RTOS固件中的漏洞。
- 我们在来自11家供应商的35个真实RTOS固件样本上对SFuzz进行了评估，发现了77个未知bug。已经为68个bug分配了CVE/CNVD id。

## 2.问题和方法概述
在本节中，我们首先提供RTOS漏洞的背景。然后，我们概述了我们的方法并讨论了相关的挑战。

### 2.1 RTOS和嵌入式设备
实时操作系统(RTOS)旨在提供确定性的执行模式。它专注于任务的及时执行，适用于具有实时需求的嵌入式设备，如打印机、交换机和路由器。由于内存空间的限制以及对快速任务调度和快速响应的要求(即性能约束)[20,31]，一些供应商将其RTOS编译为具有所有功能的单个二进制文件。同时，它们还剥离系统符号以减小二进制文件的大小。这些因素给以RTOS为操作系统的嵌入式设备的全系统仿真或安全性分析带来了挑战。

然而，这些设备(如打印机、路由器等)通常会接收来自外部(如网络、蓝牙等)的数据包，并对其进行解析以完成各种任务，从而为攻击者提供劫持它们的方法。同时，这些设备通常是家庭网络或局域网(LAN)的关键点。没有最先进的防御机制，如可执行空间保护[23]和堆栈金丝雀[14]，攻击者会非常关注它们，并喜欢通过它们的数据入口（data entries）来攻击它们。因此，安全研究人员有必要克服这些挑战，提出一种合适的方法，通过易于接触的嵌入式设备的数据入口来检测漏洞。

### 2.2 动机案例
清单1显示了一个简化的代码片段，在第40行中包含一个缓冲区溢出错误。我们使用我们的工具SFuzz在TP-Link WDR7660的RTOS中发现了这个错误，并向其供应商报告了它。该漏洞已被修复，并分配了一个CVE编号CVE-2020-28877。这个代码片段的功能是从外部接收数据(第7行)并调用相应的函数集来处理数据包(第9-44行)。详细地说，它首先进入函数protocol_handler(第9行)，检查包头的基本格式和大小(第15行)，匹配魔术字节(第16行)，并检查整个包的完整性(第17行)。如果输入包满足所有约束，则执行将进入函数msg_handler(第18行)，根据包的版本(第23行)调用相应的处理程序(第24行)。函数parse_advertisement解析并提取结构元素的头(第35-36行)，它是包负载中的基本数据单元，并将元素复制到内存空间(第40行)。因为structure元素中数据部分的长度记录在len字段中，攻击者可以通过精确构造一个包并将len的值设置为大于用于存储数据部分的缓冲区的长度来触发堆栈溢出漏洞。

![](images/Pasted%20image%2020230906105908.png)

不幸的是，目前用于嵌入式系统的bug查找技术无法有效地检测到此漏洞。动态解决方案，如模糊测试和仿真，不能保证模拟具有封闭硬件功能的整个RTOS并覆盖所有程序状态，特别是对于解析自定义数据格式的特定代码。例如，假设我们有一个设备，并希望使用最近的工作SRFuzzer[43]来识别这个bug。在这种情况下，我们必须利用逆向工程来分析设备可以处理的所有数据格式，然后生成和发送请求来触发处理逻辑代码。它需要很高的人工成本，并且对分析人员的要求非常高。静态方法如KARONTE[31]和SaTC[9]不能有效地定位单片RTOS二进制文件中的数据入口。例如，KARONTE只关注与进程间通信相关的数据，而SaTC则使用用于标记用户输入的关键字来查找数据入口。此外，代码段中复杂的代码逻辑(我们简化了动机样本中代码段的控制流图)使他们很难进行静态污点分析或符号执行，以有效地找到从数据入口点(例如recvfrom)到sink函数(例如memcpy)的敏感路径。

### 2.3 SFuzz的必要性和合理性
根据以上分析和比较，动态方法比静态分析方法更适用于检测RTOS漏洞。然而，如果没有大量的人工分析和健壮的全系统仿真方法，我们如何通过动态的方法有效地检测各种嵌入式设备实时操作系统中的这些漏洞?









