## CVE-2018-5657
程序：tdhttpd
漏洞点：R7WebsSecurityHandler:89
```c
char v33[128]; // [sp+304h] [bp-1C0h] BYREF
char *v40; // [sp+498h] [bp-2Ch]
sscanf(v40, "%*[^=]=%[^;];*", v33);
```

能跑出。

## CVE-2018-16333
漏洞点：form_fast_setting_wifi_set:33
```c
char s[64]; // [sp+200h] [bp-7Ch] BYREF
char *src; // [sp+260h] [bp-1Ch]
strcpy(s, src);
```

可以捕获
```bash
hit point:  0x6707c
r11 value:  0x40800284
r0 value:  0x40800208
r1 value:  0x127020
r2 value:  0x40800208
distance between r2 and r11 is: 0x7c
strcpy
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaaf
512
{'func_name': 'strcpy', 'param0_name': 's', 'param0_size': 64, 'param0_bp_off': -124}
124
root cause site at 0x6707c !!
```

## CVE-2021-27239
程序：upnpd
漏洞点：sub_24B74:24

```c
int v3; // r5
int v6[36]; // [sp+0h] [bp-90h] BYREF
strncpy((char *)v6, (const char *)(v3 + 3), v4 - (v3 + 3));
```

可以捕获
```bash
hit point:  0x24bd0
r11 value:  0xc4584
r0 value:  0x407fdda8
r1 value:  0x407fe504
r2 value:  0x202
distance between r2 and r11 is: 0xc4382
strncpy
 aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaaf \r\n
518
144
root cause site at 0x24bd0 !!
```

遇到新的问题，这个函数没有用到push指令：
```c
.text:0002497C ; char *__fastcall sub_2497C(char *result, const char *)
.text:0002497C sub_2497C                               ; CODE XREF: sub_24DE4+94↓p
.text:0002497C                                         ; sub_24DE4+A0↓p ...
.text:0002497C                 CMP             R0, #0
.text:00024980                 MOV             R2, R1
.text:00024984                 BXEQ            LR
.text:00024988                 LDR             R1, =aUuidS ; "uuid:%s"
.text:0002498C                 B               sprintf
```

## CVE-2022-28972
程序：tdhttpd
漏洞点：form_fast_setting_wifi_set:159
```c
const char *v3; // r0
const char *v5; // r7
char s[64]; // [sp+30h] [bp-80h] BYREF
char v32[64]; // [sp+130h] [bp+80h] BYREF
...
if ( _isoc99_sscanf(v16, "%[^:]:%s", v35, &v35[1]) == 2 )
```


## CVE-2022-45645
程序：httpd
漏洞点：formSetPPTPServer:72
```c
char v9; // [sp+140h] [bp-1A4h] BYREF
char v10; // [sp+148h] [bp-19Ch] BYREF
char v11; // [sp+150h] [bp-194h] BYREF
char v12[8]; // [sp+158h] [bp-18Ch] BYREF
char v13[8]; // [sp+160h] [bp-184h] BYREF
char v14[8]; // [sp+168h] [bp-17Ch] BYREF
char v15[16]; // [sp+170h] [bp-174h] BYREF
char *v19; // [sp+2C0h] [bp-24h]
char *v20; // [sp+2C4h] [bp-20h]

v20 = (char *)sub_2B794(a1, "startIp", &unk_EFE14);
v19 = (char *)sub_2B794(a1, "endIp", &unk_EFE14);
if(sscanf(v20, "%[^.].%[^.].%[^.].%s", v13, v14, v15, &v15[8]) != 4 || sscanf(v19, "%[^.].%[^.].%[^.].%s", &v9, &v10, &v11, v12) != 4 )
	...
```

已识别

## CNVD-2022-89236
危险函数：strcpy 
漏洞点：sub_6B5D8:79
```c
    v9 = (const char *)sub_4F4F4(a1, "wpapsk_crypto", "aes");
      if ( !strcmp(v9, "tkip&aes") )
        v12 = "tkip+aes";
      else
        v12 = v9;
    strcpy(v22, v12);
```

已识别。root cause: 0x6b854

## PSV-2020-0211
Netgear R8300 UPnP strcpy

为了调试，将daemon进行了patch

sub_25E04 strcpy
```c
  v41 = v39;
  strcpy(v39, a1);
```
root cause: 0x25e70

在这个案例中，找到的最后的函数与溢出的函数不一致，而是溢出函数调用的一个函数。在方法中添加，如果在找到的最后的函数中没有相关的危险调用，就继续寻找当前找到的最后函数的上一个函数重新进行相同分析。

## CVE-2018-18708
Tenda AC15 httpd
```c
int __fastcall sub_C24C0(const char *a1, char *a2)
{
	src = strchr(a1, '\r');
	*src++ = 0;
	strcpy(a2 + 32, a1);
	strcpy(a2, src);
}
```

root cause: 0xc2728

这个案例strcpy溢出的是上层函数的栈上变量，所以需要上层函数保存的栈帧值进行比较。

在方法中，获取最后溢出的函数地址，然后将该函数包含的所有危险调用都提取出来，包括包含的 函数内的，不管该危险函数调用位于哪个函数，都只比较最后溢出的函数的栈帧值就好。

## CVE-2020-13394
Tenda AC15 httpd

sub_7DD20:77
```c
int __fastcall formSetQosBand(int a1)
	v8 = (char *)sub_2BA8C(a1, "list", &unk_E250C);
	sub_7DD20(v8, (int)"bandwidth.mode", 0xAu);

int __fastcall sub_7DD20(char *a1, int a2, unsigned __int8 a3)
	src = a1;
	strcpy(dest, src);
```

root cause: 0x7e0d8

## CVE-2020-13392
Tenda AC15 httpd

```c
int __fastcall formSetCfm(int a1)
	v15 = (char *)sub_2BA8C(a1, "funcname", &unk_DFA30);
	if ( !strcmp(v15, "save_list_data") )
		v14 = (const char *)sub_2BA8C(a1, "funcpara1", &unk_DFA30);
	    v13 = (char *)sub_2BA8C(a1, "funcpara2", &unk_DFA30);
		sub_4EC58(v14, v13, 0x7Eu);

int __fastcall sub_4EC58(const char *a1, char *a2, unsigned __int8 a3)
	sprintf(s, "%s.listnum", a1);
```

root cause: 0x4ecf4
## cve_20231101_netgearR1450
程序：httpd

品牌：Netgear

漏洞位置：sub_17134:31
```c
size_t v2; // r7
char s[124]; // [sp+4h] [bp-7Ch] BYREF
memcpy(s, src, v2);
```

Program terminated with signal SIGILL, Illegal instruction.
The program no longer exists.
