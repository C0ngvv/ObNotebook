## CVE-2018-5657
程序：tdhttpd
漏洞点：R7WebsSecurityHandler:89
```c
char v33[128]; // [sp+304h] [bp-1C0h] BYREF
char *v40; // [sp+498h] [bp-2Ch]
sscanf(v40, "%*[^=]=%[^;];*", v33);
```

```json
{'last_func_info': {'func_addr': '0x2d7e4', 'push_skip': 0, 'push_addr': '0x2d7e4', 'lr_index': 2}, 'in_func_list': ['0x2d7e4'], 'last_func_addr': '0x2d7e4', 'filter_call_sites': {'0x2dcb8': '0x2d7e4', '0x2dd44': '0x2d7e4', '0x2eb44': '0x2d7e4'}, 'not_filter_call_sites': {'0xf5e4': '0xf560', '0x181d0': '0x181a8', '0x18ad4': '0x18a18', '0xf544': '0xf4d4', '0x2c414': '0x2c1dc'}}
```
能跑出root cause: 0x2dd44。

## CVE-2018-16333
漏洞点：form_fast_setting_wifi_set:33
```c
char s[64]; // [sp+200h] [bp-7Ch] BYREF
char *src; // [sp+260h] [bp-1Ch]
strcpy(s, src);
```

可以捕获 root cause: 0x6707c
```json
{'last_func_info': {'func_addr': '0x66ee0', 'push_skip': 0, 'push_addr': '0x66ee0', 'lr_index': 3}, 'in_func_list': ['0x66ee0'], 'last_func_addr': '0x66ee0', 'filter_call_sites': {'0x6707c': '0x66ee0'}, 'not_filter_call_sites': {}}
```

## CVE-2021-27239
程序：upnpd
漏洞点：sub_24B74:24

```c
int v3; // r5
int v6[36]; // [sp+0h] [bp-90h] BYREF
strncpy((char *)v6, (const char *)(v3 + 3), v4 - (v3 + 3));
```

遇到新的问题，这个函数没有用到push指令：
```c
.text:0002497C ; char *__fastcall sub_2497C(char *result, const char *)
.text:0002497C sub_2497C                               ; CODE XREF: sub_24DE4+94↓p
.text:0002497C                                         ; sub_24DE4+A0↓p ...
.text:0002497C                 CMP             R0, #0
.text:00024980                 MOV             R2, R1
.text:00024984                 BXEQ            LR
.text:00024988                 LDR             R1, =aUuidS ; "uuid:%s"
.text:0002498C                 B               sprintf
```

```json
{'last_func_info': {'func_addr': '0x24b74', 'push_skip': 0, 'push_addr': '0x24b74', 'lr_index': 1}, 'in_func_list': ['0x24b74'], 'last_func_addr': '0x24b74', 'filter_call_sites': {'0x24bd0': '0x24b74'}, 'not_filter_call_sites': {}}
```

root cause: 0x24bd0
## CVE-2022-28972
程序：tdhttpd
漏洞点：form_fast_setting_wifi_set:159
```c
const char *v3; // r0
const char *v5; // r7
char s[64]; // [sp+30h] [bp-80h] BYREF
char v32[64]; // [sp+130h] [bp+80h] BYREF
...
if ( _isoc99_sscanf(v16, "%[^:]:%s", v35, &v35[1]) == 2 )
```

```json
{'last_func_info': {'func_addr': '0x42b08', 'push_skip': 0, 'push_addr': '0x42b08', 'lr_index': 2}, 'in_func_list': ['0x42b08'], 'last_func_addr': '0x42b08', 'filter_call_sites': {'0x42c44': '0x42b08', '0x42c78': '0x42b08', '0x42ccc': '0x42b08', '0x42d4c': '0x42b08', '0x42d64': '0x42b08', '0x42e70': '0x42b08', '0x42f94': '0x42b08', '0x43170': '0x42b08'}, 'not_filter_call_sites': {'0x2dc08': '0x2dbd4', '0x2e93c': '0x2e370', '0x2e96c': '0x2e370', '0x2e478': '0x2e370', '0x2ed94': '0x2ed48', '0x1c1ec': '0x1c1b0', '0x20cec': '0x20ce8', '0x21270': '0x211f0'}}
```

root cause: 0x43170
## CVE-2022-45645
程序：httpd
漏洞点：formSetPPTPServer:72
```c
char v9; // [sp+140h] [bp-1A4h] BYREF
char v10; // [sp+148h] [bp-19Ch] BYREF
char v11; // [sp+150h] [bp-194h] BYREF
char v12[8]; // [sp+158h] [bp-18Ch] BYREF
char v13[8]; // [sp+160h] [bp-184h] BYREF
char v14[8]; // [sp+168h] [bp-17Ch] BYREF
char v15[16]; // [sp+170h] [bp-174h] BYREF
char *v19; // [sp+2C0h] [bp-24h]
char *v20; // [sp+2C4h] [bp-20h]

v20 = (char *)sub_2B794(a1, "startIp", &unk_EFE14);
v19 = (char *)sub_2B794(a1, "endIp", &unk_EFE14);
if(sscanf(v20, "%[^.].%[^.].%[^.].%s", v13, v14, v15, &v15[8]) != 4 || sscanf(v19, "%[^.].%[^.].%[^.].%s", &v9, &v10, &v11, v12) != 4 )
	...
```

已识别
```json
{'last_func_info': {'func_addr': '0xb3560', 'push_skip': 0, 'push_addr': '0xb3560', 'lr_index': 2}, 'in_func_list': ['0xb3560'], 'last_func_addr': '0xb3560', 'filter_call_sites': {'0xb38cc': '0xb3560'}, 'not_filter_call_sites': {'0x107cc': '0x10748', '0x193b8': '0x19390', '0x19cbc': '0x19c00'}}
```

root cause: 0xb38cc

## CNVD-2022-89236
危险函数：strcpy
漏洞点：sub_6B5D8:79
```c
    v9 = (const char *)sub_4F4F4(a1, "wpapsk_crypto", "aes");
      if ( !strcmp(v9, "tkip&aes") )
        v12 = "tkip+aes";
      else
        v12 = v9;
    strcpy(v22, v12);
```

已识别，root cause: 0x6b854
```json
{'last_func_info': {'func_addr': '0x6b5d8', 'push_skip': 0, 'push_addr': '0x6b5d8', 'lr_index': 2}, 'in_func_list': ['0x6b5d8'], 'last_func_addr': '0x6b5d8', 'filter_call_sites': {'0x6b828': '0x6b5d8', '0x6b854': '0x6b5d8'}, 'not_filter_call_sites': {}}
```

## PSV-2020-0211
Netgear R8300 UPnP strcpy

为了调试，将daemon进行了patch

sub_25E04 strcpy
```c
  v41 = v39;
  strcpy(v39, a1);
```

在这个案例中，找到的最后的函数与溢出的函数不一致，而是溢出函数调用的一个函数。在方法中添加，如果在找到的最后的函数中没有相关的危险调用，就继续寻找当前找到的最后函数的上一个函数重新进行相同分析。

```
{'last_func_info': {'func_addr': '0x25e04', 'push_skip': 0, 'push_addr': '0x25e04', 'lr_index': 1}, 'in_func_list': ['0x25e04'], 'last_func_addr': '0x25e04', 'filter_call_sites': {'0x25e70': '0x25e04'}, 'not_filter_call_sites': {}}
```

root cause: 0x25e70

## CVE-2018-18708
Tenda AC15 httpd
```c
int __fastcall sub_C24C0(const char *a1, char *a2)
{
	src = strchr(a1, '\r');
	*src++ = 0;
	strcpy(a2 + 32, a1);
	strcpy(a2, src);
}
```

这个案例strcpy溢出的是上层函数的栈上变量，所以需要上层函数保存的栈帧值进行比较。

在方法中，获取最后溢出的函数地址，然后将该函数包含的所有危险调用都提取出来，包括包含的 函数内的，不管该危险函数调用位于哪个函数，都只比较最后溢出的函数的栈帧值就好。

```json
{'last_func_info': {'func_addr': '0xc17a0', 'push_skip': 0, 'push_addr': '0xc17a0', 'lr_index': 2}, 'in_func_list': ['0xc17a0'], 'last_func_addr': '0xc17a0', 'filter_call_sites': {'0xc1a24': '0xc17a0', '0xc1a44': '0xc17a0'}, 'not_filter_call_sites': {'0xc2714': '0xc24c0', '0xc2728': '0xc24c0'}}
```

root cause: 0xc2728

## CVE-2020-13394
Tenda AC15 httpd

sub_7DD20:77
```c
int __fastcall formSetQosBand(int a1)
	v8 = (char *)sub_2BA8C(a1, "list", &unk_E250C);
	sub_7DD20(v8, (int)"bandwidth.mode", 0xAu);

int __fastcall sub_7DD20(char *a1, int a2, unsigned __int8 a3)
	src = a1;
	strcpy(dest, src);
```

root cause: 0x7e0d8
```json
{'last_func_info': {'func_addr': '0x7dd20', 'push_skip': 0, 'push_addr': '0x7dd20', 'lr_index': 2}, 'in_func_list': ['0x7dd20'], 'last_func_addr': '0x7dd20', 'filter_call_sites': {'0x7e0d8': '0x7dd20', '0x7e174': '0x7dd20'}, 'not_filter_call_sites': {}}
```

## CVE-2020-13392
Tenda AC15 httpd

```c
int __fastcall formSetCfm(int a1)
	v15 = (char *)sub_2BA8C(a1, "funcname", &unk_DFA30);
	if ( !strcmp(v15, "save_list_data") )
		v14 = (const char *)sub_2BA8C(a1, "funcpara1", &unk_DFA30);
	    v13 = (char *)sub_2BA8C(a1, "funcpara2", &unk_DFA30);
		sub_4EC58(v14, v13, 0x7Eu);

int __fastcall sub_4EC58(const char *a1, char *a2, unsigned __int8 a3)
	sprintf(s, "%s.listnum", a1);
```

root cause: 0x4ecf4
```json
{'last_func_info': {'func_addr': '0x4ec58', 'push_skip': 0, 'push_addr': '0x4ec58', 'lr_index': 2}, 'in_func_list': ['0x4ec58'], 'last_func_addr': '0x4ec58', 'filter_call_sites': {'0x4ecf4': '0x4ec58', '0x4ed60': '0x4ec58'}, 'not_filter_call_sites': {}}
```

## cve_20231101_netgearR1450
程序：httpd

品牌：Netgear

漏洞位置：sub_17134:31
```c
size_t v2; // r7
char s[124]; // [sp+4h] [bp-7Ch] BYREF
memcpy(s, src, v2);
```

Program terminated with signal SIGILL, Illegal instruction.
The program no longer exists.
