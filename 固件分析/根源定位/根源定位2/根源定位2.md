### 问题1.栈上变量距bp偏移获取
对arm架构，单纯的r11并不总是执行栈上保存pc的地址，所以原来的方法并不总是有效，还是得通过静态分析确定栈上变量距离bp的偏移。

在ida反编译界面中，有关于局部缓冲区变量距离sp和bp的偏移的注解，我尝试通过api来获取这个值，但尝试寻找了很久都没有找到如何获取距离bp的偏移，只能够获得距离sp的偏移。

我注意到，距离sp的偏移+距离bp的偏移似乎总等于一个定值，在ida api中存在一个函数`get_frame_size()`可以获得栈帧大小，经过观察发现，大部分情况下这个定值与获取的栈帧大小一样，但是依然存在一些情况这两个值不同，这可能是静态分析并不总是准去的问题，因此用这种方法依然不能总是准确的获取bp偏移。

最终只能使用最简单的方法，通过python正则表达式从IDA反编译结果字符串中直接搜素提取出关于sp和bp的偏移。

```python
import idaapi
import re
func = 0x24B74
lvar_name = 'v6'

confidence = 0
cfunc = idaapi.decompile(func)
lvars = cfunc.get_lvars()
for var in lvars:
    if var.name == lvar_name:
        lvar = var
print(lvar.name)
print(lvar.type())
print(lvar.width)
stkoff = lvar.get_stkoff()
print('stkoff:', stkoff)
# print(dir(lvar))

frame_size = get_frame_size(func)
print('frame size:', frame_size)
pattern = r"\[sp\+(\d+)h\] \[bp\-(\d+)h\]"
dec_list = str(cfunc).split('\n')
for line in dec_list:
    if lvar_name in line and '//' in line:
        print(line)
        matches = re.search(pattern, line)
        sp_off = int(matches.group(1), 16)
        bp_off = int(matches.group(2), 16)
        print(sp_off, hex(bp_off))
        if sp_off == stkoff:
            confidence += 1
        if sp_off + bp_off == frame_size:
            confidence += 1
        print('confidence: ', confidence)
        break
```

### 问题2.危险函数调用点位置获取
单纯的使用trace中危险函数调用地址的下一个地址-4并不能得到危险函数调用点地址。存在两种特殊情况：
1. 在第一次调用危险函数时，由于延迟加载，会再跳到plt某地址处，因此trace中是plt节地址，而不是危险函数调用点的下一个指令地址
2. 当危险函数指令调用位于函数末尾时，它的下一条指令地址是函数调用处的下一条指令地址，而不是危险函数调用处的下一条指令地址。

针对第2种情况，如下图所示。在0x26410位置跳到了sub_1E834去执行。

![](根源定位2/image-20231212194641728.png)

而sub_1E834的最后一条指令是B strncpy

![](根源定位2/image-20231212194757042.png)

当执行完危险函数strncpy的调用后，程序会返回到sub_1E834调用处的下一条指令地址，即0x26414，而不是我们所希望的strncpy调用的+4的地址(0x1E88C+4)。

```
0001e878  # strncpy调用前未跳转块起始地址
0000af80  # strncpy函数plt地址
00026414  # 另一个函数调用点后地址
```

通过直接下一条地址直接减4的方法并不总是能够得到危险函数调用地址。

对于情况1，可以设置从危险函数调用点开始向下遍历到第一个.text节地址（向下不超过2个）再进行类似减4的操作。

对于情况2，我们首先获取危险函数调用点后的.text的地址处-4（即函数调用点）的操作数（即调用的函数），判断其是否为危险函数，若是则直接保存；若不是，则获取该调用函数的最后一条指令地址，并判断操作数是否为危险函数地址，若是则保存最后一条指令地址为调用点。

最终代码如下：
```python
import idautils

trace_file = r'E:\项目\根因分析\filter_trace.txt'

danger_func_lists = [['strcpy'], ['strncpy', 'memcpy'], ['ssprintf'], ['sscanf']]
danger_func_addr_list = []

with open(trace_file, 'r') as fr:
    trace_data = fr.read().splitlines()

si_addr = int(trace_data[-1], 16)
trace_data = [int(x, 16) for x in trace_data[:-1]]

for danger_func_list in danger_func_lists:
    for danger_func_name in danger_func_list:
        func_addr = idc.get_name_ea(idc.BADADDR, danger_func_name)
        if func_addr != idc.BADADDR:
            danger_func_addr_list.append(func_addr)
print('danger func addr list: {}'.format([hex(x) for x in danger_func_addr_list]))

for seg in idautils.Segments():
    if SegName(seg) == ".text":
        text_start = SegStart(seg)
        text_end = SegEnd(seg)
        break

print("plt section between {} and {}".format(hex(plt_start), hex(plt_end)))

index = 0
trace_len = len(trace_data)
danger_func_call_sites = []
while index < trace_len:
    if trace_data[index] not in danger_func_addr_list:
        index += 1
        continue
    # 调用了危险函数，寻找它的text段下一条指令地址从而-4推断它的调用地址
    i = 1
    while i<=2:
        if index+i >= trace_len:
            break
        cur_addr = trace_data[index + i]
        if cur_addr < text_start and cur_addr >= text_end:
            continue
        # .text段地址
        last_call_addr = cur_addr - 4
        call_addr = get_operand_value(last_call_addr, 0)
        if call_addr in danger_func_addr_list:
            if last_call_addr not in danger_func_call_sites:
                danger_func_call_sites.append(last_call_addr)
        else:
            # 获取调用函数的最后一条地址并判断是否为危险调用
            callee_func_last_addr = find_func_end(call_addr) - 4
            if get_operand_value(callee_func_last_addr, 0) in danger_func_addr_list:
                if callee_func_last_addr not in danger_func_call_sites:
                    danger_func_call_sites.append(callee_func_last_addr)
        break
        i += 1
    index += i + 1
    
    
print([hex(x) for x in danger_func_call_sites])

```

### 问题3.工具静态分析部分识别结果不准确
memcpy会反汇编为strcpy(Target's Ea会为无效，Is helper会为True)

字符串没有识别为"string"，而是"ref"

#### 案例1.未识别的字符串
upnpd的0x24694位置存在`memcpy(&a2[v11], "\r\n", 3u);`，该处的汇编代码如下图所示。

![](根源定位2/image-20231213152310660.png)

第二个参数字符串保存在R1中，即表示为(aExt+4)。当使用FIDL进行识别时，识别的内容如下：

```
Ea: 24694
Target's Name: memcpy
Target's Ea: AAE8
Target's ret: void *
Is helper: False
Is indirect: False
Args:
 - 0: Rep(type='ref', val=<ida_hexrays.cexpr_t; proxy of <Swig Object of type 'cexpr_t *' at 0x0000021936A40630> >)
 - 1: Rep(type='ref', val=<ida_hexrays.cexpr_t; proxy of <Swig Object of type 'cexpr_t *' at 0x0000021936A40840> >)
 - 2: Rep(type='number', val=3)
```

它将第二个参数识别为ref类型，val是ida_hexrays.cexpr_t对象。

```python
import FIDL.decompiler_utils as du
import ida_hexrays

addr = 0x24694
cf = du.controlFlowinator(ea=addr, fast=False)

for cf_call in cf.calls:
    if cf_call.ea == addr:
        scall = cf_call
        break

print(scall)

params = scall.args
expr = params[1].val
print(expr)  # <ida_hexrays.cexpr_t; proxy of <Swig Object of type 'cexpr_t *' at 0x0000021936546580> >
print(expr.op)  # 58 ida_hexrays.cot_idx  索引类型
print(expr.x.op)  # 64 ida_hexrays.cot_obj  索引对象
print(expr.y.op)  # 61 ida_hexrays.cot_num  索引值
print(expr.y.n)  # <ida_hexrays.cnumber_t; proxy of <Swig Object of type 'cnumber_t *' at 0x000002193B451830> >
print(expr.y.n._value)  # 4
print(expr.y.type) # int
print(expr.x.type)  # char[7]

string_val = idc.get_strlit_contents(expr.x.obj_ea + expr.y.n._value)
print(string_val) # '\r\n'  ('EXT:\r\n'第4位开始)
'''
ida_hexrays.cot_ref 52
ida_hexrays.cot_idx 58
ida_hexrays.cot_num 61
ida_hexrays.cot_obj 64
ida_hexrays.cot_var 65
'''
```

