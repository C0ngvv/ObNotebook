# Fuzztruction: Using Fault Injection-based Fuzzing to Leverage Implicit Domain Knowledge

# Translation
## 摘要
今天的数字通信依赖于复杂的协议和规范来交换结构化的消息和数据。通信自然涉及两个端点:一个生成数据，另一个消费数据。传统的模糊测试方法用模糊器代替一个端点，即生成器，快速测试被测目标程序上的许多突变输入。虽然这种完全自动化的方法适用于松散的结构化格式，但不适用于高度结构化的格式，特别是那些经过复杂转换(如压缩或加密)的格式。

在这项工作中，我们提出了一种新的视角，可以在不依赖重量级程序分析技术、粗粒度语法近似或人工领域专家的情况下，生成高度复杂格式的输入。我们不改变目标程序的输入，而是在数据生成程序中注入错误，这样数据就几乎符合预期的格式。这样的数据绕过了消费者程序中的初始解析阶段，并运用了更深层次的程序状态，在这些状态中，它触发了更有趣的程序行为。为了实现这个概念，我们提出了一组编译时和运行时分析，以一种有目标的方式改变生成器，使其保持完整，并生成满足复杂格式约束的半有效输出。我们已经在一个名为Fuzzstruction的原型中实现了这种方法，并表明它的性能优于最先进的fuzzers AFL++、SYMCC和WEIZZ。FUZZTRUCTION发现比现有方法有更大的覆盖范围，特别是在使用加密原语的目标上。在我们的评估过程中，FUZZTRUCTION发现了151个独特的崩溃(在自动重复数据删除之后)。到目前为止，我们手工进行了分类并报告了27个bug，并分配了4个CVE。

## 1.引言
我们的现代数字基础设施基于定义良好的消息和数据格式，包括数据交换的标准和规范。这些系统至少有两个端点，它们都对处理通信所需的领域知识进行编码：一个应用程序生成数据(以下称为生成器generator)，而另一个应用程序消费数据(称为消费者consumer)。例如，各种程序生成PDF文档作为输出，相应的PDF查看器显示结果。另一个例子是加密库，它生成加密消息，对应的库可以处理这些消息。从安全的角度来看，消费者扮演着关键的角色，因为它处理潜在的不可信数据，因此暴露于攻击之下。模糊测试(简称fuzzing)是随机测试的一种形式，事实证明它有助于在消费者程序的输入处理中有效地发现软件错误。过去模糊方法的进展主要集中在吞吐量[1-3]、有效性[4-6]和对新目标领域的适用性[7-12]。即使经过多年的研究，一个尚未解决的挑战是如何有效地生成复杂格式的有效输入，包括密码原语、压缩和其他类型的复杂转换。

先前的工作和行业最佳实践尝试了两种方法来应对这一挑战。 首先，重量级程序分析技术，如符号执行和污点分析，或手动变通方法，已被建议来解决障碍（例如，校验和或散列）[5,6,13-20]。 不幸的是，这些方法不能扩展到复杂的程序。 其次，基于语法的模糊化[21-29]被用来生成特定句法结构的输入。 然而，语法的使用并不能解决使用复杂类型转换的应用程序的复杂性，尤其是加密原语和压缩。 

我们提出了一种新的通用方法，以自动的方式生成高度结构化和复杂的模糊输入，而不是使用繁重的技术、语法或手动绕过这些模糊障碍。 更具体地说，我们建议利用在生成数据的应用程序中已经编码的领域知识：在传统的模糊化方法中，生成器被直接将输入传递给消费者（表示测试中的系统）的模糊器所取代。 相反，我们设计了一种机制来变异生成器，然后将其输出传递给消费者。 其核心思想是，这种变异生成器产生的输入大多符合所需的数据格式，但引入了细微的偏差，这可能会引发消费者处理逻辑中的错误。 例如，对加密证书进行签名的应用程序知道如何生成有效的签名，该签名可以由任何旨在验证此类签名的应用程序（例如，浏览器或加密库）进行解析和验证。 为了实现签名验证逻辑的模糊化，我们利用了生成器隐式知道如何计算有效签名的事实。 我们通过稍微改变生成器的代码来利用这些知识，这样产生的输出可能违反规范，但在技术上是有效的（即，有效的签名或加密）。 

随机翻转生成器中的指令位可能不会影响其输出，更糟糕的是，在大多数情况下，它会导致生成器崩溃。 为了避免这种不希望的情况，我们设计了一个编译时分析来识别对数据的操作，并过滤掉当它们发生突变时会使生成器崩溃的操作。 我们还分析数据流依赖关系以避免冗余突变。 然后，我们确定生成器的哪些部分实际上影响了剩余候选突变的输出，并将我们的突变集中在最有希望的候选突变上。 基于这些见解，我们将生成器和实时(JIT)编译跟踪和变异机制纳入其中，促进有效的模糊化。 

为了证明所提方法的实际可行性，我们实现了一个称为FuzzTruction的工具。 我们的方法可以作为一个独立的工具或增强现有的模糊器。 在一个全面的评估中，我们表明，我们的方法不仅避免了传统方法对于消耗复杂输入格式的目标的缺点，而且优于symcc[6]、weizz[30]和afl++[1]:平均而言，我们发现对于大量使用密码原语的目标（高达70%的覆盖率）和对于经过广泛测试的目标（高达23%的Objdump覆盖率）的覆盖率都增加了21%。 除了覆盖范围，我们发现与这些模糊器相比，（重复数据删除）崩溃输入的数量是五倍多。 在我们的评估中，我们发现了151个独特的崩溃（在自动重复数据删除之后）。 我们手动分类并以协调的方式向开发人员报告了27个bug。 到目前为止，共分配了4个CVE。 

概括而言，我们作出以下主要贡献： 

- 我们提出了一种新的模糊化方法，它自动地利用生成器应用程序中的领域知识来改善模糊化，而不依赖于先进的昂贵的程序分析技术。 
- 我们通过对甚至复杂的加密过程(如对加密的RSA密钥的解析和验证)进行模糊处理，演示了该方法的通用功能，这些过程无需定制的种子即可自动完成。
- 我们针对最先进的模糊器AFL++、SYMCC和Weizz来实现和评估我们的原型FuzzTrucion。 我们的结果表明，我们的方法在覆盖和发现的软件错误数量方面取得了显著的进步。 

为了促进对这个主题的进一步研究，我们在https://github.com/fuzztruction/fuzztruction发布了FuzzTruction的源代码和评估构件。 

## 2.对复杂输入格式模糊测试
一般来说，Fuzzing是指我们执行一个目标程序，其中包含大量变异的输入，以触发意想不到的行为，从而揭示故障。 为了深入到被测程序的状态空间，模糊器通常需要生成结构良好的输入。 除了结构良好之外，这些输入还需要考虑校验和、压缩算法或保护更深入处理的加密原语。 在实践中，有效地识别输入格式中的逻辑单元以及随后有效地解决这些单元中的障碍都是一个主要的挑战。 模糊者目前试图通过不同的方法来解决这些挑战，我们将在下面概述这些方法。 

执行反馈。 对于给定的输入，收集目标程序执行的反馈是现代Fuzzers的一项成熟技术[1,31,32]。 这种反馈提供了输入质量的度量，并允许模糊器识别探索新程序行为的输入。 通过保持和进一步改变这些结构越来越好的输入，模糊器得到的输入随着时间的推移在更大程度上与预期格式匹配。 收集执行反馈（最突出的是覆盖率反馈）很有吸引力，因为它普遍适用，并引入了低运行时开销。 事实上，在AFL[31]中引入这种覆盖引导技术后，Fuzzers已经能够探索常见的、结构更松散的二进制文件格式，并因此识别出大量的bug[33]。 即使模糊器不能直接使用它，执行反馈也为被测程序中编码的领域知识提供了一个侧通道。 





## 3.设计
### 生成器
### 消费者
### 调度器
### 联合的模糊测试
## 4.实现
## 5.评估
## 6.讨论
## 7.相关工作
## 8.结论
本文提出了一种新的基于软件故障注入的模糊化方法FuzzTruction。 基于使用输入的程序有一个（或多个）对应程序生成该输入的观点，我们建议对该生成器进行插桩和变异。 通过注入轻微的软件错误，我们可以利用应用程序中编码的隐式领域知识，并生成几乎与规范匹配的输入。 使用这些输入进行模糊化，FuzzTrucion产生高质量的输入，从而产生高代码覆盖率并运行深入的程序状态。 我们的方法是轻量级的，不需要昂贵的分析或手动准备的执行环境。 在评估中，我们发现我们的方法显示了它的力量，通常优于最先进的模糊方法，特别是在具有复杂约束的目标上，通常是以密码学原语或压缩的形式应用于输入。 

## 9.致谢
## 分配的CVE
## 目标描述
## 种子描述