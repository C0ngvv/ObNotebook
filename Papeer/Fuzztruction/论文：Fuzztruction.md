# Fuzztruction: Using Fault Injection-based Fuzzing to Leverage Implicit Domain Knowledge

# Translation
## 摘要
今天的数字通信依赖于复杂的协议和规范来交换结构化的消息和数据。通信自然涉及两个端点:一个生成数据，另一个消费数据。传统的模糊测试方法用模糊器代替一个端点，即生成器，快速测试被测目标程序上的许多突变输入。虽然这种完全自动化的方法适用于松散的结构化格式，但不适用于高度结构化的格式，特别是那些经过复杂转换(如压缩或加密)的格式。
在这项工作中，我们提出了一种新的视角，可以在不依赖重量级程序分析技术、粗粒度语法近似或人工领域专家的情况下，生成高度复杂格式的输入。我们不改变目标程序的输入，而是在数据生成程序中注入错误，这样数据就几乎符合预期的格式。这样的数据绕过了消费者程序中的初始解析阶段，并运用了更深层次的程序状态，在这些状态中，它触发了更有趣的程序行为。为了实现这个概念，我们提出了一组编译时和运行时分析，以一种有目标的方式改变生成器，使其保持完整，并生成满足复杂格式约束的半有效输出。我们已经在一个名为Fuzzstruction的原型中实现了这种方法，并表明它的性能优于最先进的fuzzers AFL++、SYMCC和WEIZZ。FUZZTRUCTION发现比现有方法有更大的覆盖范围，特别是在使用加密原语的目标上。在我们的评估过程中，FUZZTRUCTION发现了151个独特的崩溃(在自动重复数据删除之后)。到目前为止，我们手工进行了分类并报告了27个bug，并分配了4个CVE。
## 1.引言
我们的现代数字基础设施基于定义良好的消息和数据格式，包括数据交换的标准和规范。这些系统至少有两个端点，它们都对处理通信所需的领域知识进行编码：一个应用程序生成数据(以下称为生成器generator)，而另一个应用程序消费数据(称为消费者consumer)。例如，各种程序生成PDF文档作为输出，相应的PDF查看器显示结果。另一个例子是加密库，它生成加密消息，对应的库可以处理这些消息。从安全的角度来看，消费者扮演着关键的角色，因为它处理潜在的不可信数据，因此暴露于攻击之下。模糊测试(简称fuzzing)是随机测试的一种形式，事实证明它有助于在消费者程序的输入处理中有效地发现软件错误。过去模糊方法的进展主要集中在吞吐量[1-3]、有效性[4-6]和对新目标领域的适用性[7-12]。即使经过多年的研究，一个尚未解决的挑战是如何有效地生成复杂格式的有效输入，包括密码原语、压缩和其他类型的复杂转换。
先前的工作和行业最佳实践尝试了两种方法来应对这一挑战。 首先，重量级程序分析技术，如符号执行和污点分析，或手动变通方法，已被建议来解决障碍（例如，校验和或散列）[5,6,13-20]。 不幸的是，这些方法不能扩展到复杂的程序。 其次，基于语法的模糊化[21-29]被用来生成特定句法结构的输入。 然而，文法的使用并不能解决使用复杂类型转换的应用程序的复杂性，尤其是加密原语和压缩。 


## 2.对复杂输入格式模糊测试
## 3.设计
### 生成器
### 消费者
### 调度器
### 联合的模糊测试
## 4.实现
## 5.评估
## 6.讨论
## 7.相关工作
## 8.结论
## 致谢
## 分配的CVE
## 目标描述
## 种子描述