# Fuzztruction: Using Fault Injection-based Fuzzing to Leverage Implicit Domain Knowledge

# Translation
## 摘要
今天的数字通信依赖于复杂的协议和规范来交换结构化的消息和数据。通信自然涉及两个端点:一个生成数据，另一个消费数据。传统的模糊测试方法用模糊器代替一个端点，即生成器，快速测试被测目标程序上的许多突变输入。虽然这种完全自动化的方法适用于松散的结构化格式，但不适用于高度结构化的格式，特别是那些经过复杂转换(如压缩或加密)的格式。

在这项工作中，我们提出了一种新的视角，可以在不依赖重量级程序分析技术、粗粒度语法近似或人工领域专家的情况下，生成高度复杂格式的输入。我们不改变目标程序的输入，而是在数据生成程序中注入错误，这样数据就几乎符合预期的格式。这样的数据绕过了消费者程序中的初始解析阶段，并运用了更深层次的程序状态，在这些状态中，它触发了更有趣的程序行为。为了实现这个概念，我们提出了一组编译时和运行时分析，以一种有目标的方式改变生成器，使其保持完整，并生成满足复杂格式约束的半有效输出。我们已经在一个名为Fuzzstruction的原型中实现了这种方法，并表明它的性能优于最先进的fuzzers AFL++、SYMCC和WEIZZ。FUZZTRUCTION发现比现有方法有更大的覆盖范围，特别是在使用加密原语的目标上。在我们的评估过程中，FUZZTRUCTION发现了151个独特的崩溃(在自动重复数据删除之后)。到目前为止，我们手工进行了分类并报告了27个bug，并分配了4个CVE。

## 1.引言
我们的现代数字基础设施基于定义良好的消息和数据格式，包括数据交换的标准和规范。这些系统至少有两个端点，它们都对处理通信所需的领域知识进行编码：一个应用程序生成数据(以下称为生成器generator)，而另一个应用程序消费数据(称为消费者consumer)。例如，各种程序生成PDF文档作为输出，相应的PDF查看器显示结果。另一个例子是加密库，它生成加密消息，对应的库可以处理这些消息。从安全的角度来看，消费者扮演着关键的角色，因为它处理潜在的不可信数据，因此暴露于攻击之下。模糊测试(简称fuzzing)是随机测试的一种形式，事实证明它有助于在消费者程序的输入处理中有效地发现软件错误。过去模糊方法的进展主要集中在吞吐量[1-3]、有效性[4-6]和对新目标领域的适用性[7-12]。即使经过多年的研究，一个尚未解决的挑战是如何有效地生成复杂格式的有效输入，包括密码原语、压缩和其他类型的复杂转换。

先前的工作和行业最佳实践尝试了两种方法来应对这一挑战。 首先，重量级程序分析技术，如符号执行和污点分析，或手动变通方法，已被建议来解决障碍（例如，校验和或散列）[5,6,13-20]。 不幸的是，这些方法不能扩展到复杂的程序。 其次，基于语法的模糊化[21-29]被用来生成特定句法结构的输入。 然而，语法的使用并不能解决使用复杂类型转换的应用程序的复杂性，尤其是加密原语和压缩。 

我们提出了一种新的通用方法，以自动的方式生成高度结构化和复杂的模糊输入，而不是使用繁重的技术、语法或手动绕过这些模糊障碍。 更具体地说，我们建议利用在生成数据的应用程序中已经编码的领域知识：在传统的模糊化方法中，生成器被直接将输入传递给消费者（表示测试中的系统）的模糊器所取代。 相反，我们设计了一种机制来变异生成器，然后将其输出传递给消费者。 其核心思想是，这种变异生成器产生的输入大多符合所需的数据格式，但引入了细微的偏差，这可能会引发消费者处理逻辑中的错误。 例如，对加密证书进行签名的应用程序知道如何生成有效的签名，该签名可以由任何旨在验证此类签名的应用程序（例如，浏览器或加密库）进行解析和验证。 为了实现签名验证逻辑的模糊化，我们利用了生成器隐式知道如何计算有效签名的事实。 我们通过稍微改变生成器的代码来利用这些知识，这样产生的输出可能违反规范，但在技术上是有效的（即，有效的签名或加密）。 

随机翻转生成器中的指令位可能不会影响其输出，更糟糕的是，在大多数情况下，它会导致生成器崩溃。 为了避免这种不希望的情况，我们设计了一个编译时分析来识别对数据的操作，并过滤掉当它们发生突变时会使生成器崩溃的操作。 我们还分析数据流依赖关系以避免冗余突变。 然后，我们确定生成器的哪些部分实际上影响了剩余候选突变的输出，并将我们的突变集中在最有希望的候选突变上。 基于这些见解，我们将生成器和实时(JIT)编译跟踪和变异机制纳入其中，促进有效的模糊化。 

为了证明所提方法的实际可行性，我们实现了一个称为FuzzTruction的工具。 我们的方法可以作为一个独立的工具或增强现有的模糊器。 在一个全面的评估中，我们表明，我们的方法不仅避免了传统方法对于消耗复杂输入格式的目标的缺点，而且优于symcc[6]、weizz[30]和afl++[1]:平均而言，我们发现对于大量使用密码原语的目标（高达70%的覆盖率）和对于经过广泛测试的目标（高达23%的Objdump覆盖率）的覆盖率都增加了21%。 除了覆盖范围，我们发现与这些模糊器相比，（重复数据删除）崩溃输入的数量是五倍多。 在我们的评估中，我们发现了151个独特的崩溃（在自动重复数据删除之后）。 我们手动分类并以协调的方式向开发人员报告了27个bug。 到目前为止，共分配了4个CVE。 

概括而言，我们作出以下主要贡献： 

- 我们提出了一种新的模糊化方法，它自动地利用生成器应用程序中的领域知识来改善模糊化，而不依赖于先进的昂贵的程序分析技术。 
- 我们通过对甚至复杂的加密过程(如对加密的RSA密钥的解析和验证)进行模糊处理，演示了该方法的通用功能，这些过程无需定制的种子即可自动完成。
- 我们针对最先进的模糊器AFL++、SYMCC和Weizz来实现和评估我们的原型FuzzTrucion。 我们的结果表明，我们的方法在覆盖和发现的软件错误数量方面取得了显著的进步。 

为了促进对这个主题的进一步研究，我们在https://github.com/fuzztruction/fuzztruction发布了FuzzTruction的源代码和评估构件。 

## 2.对复杂输入格式模糊测试
一般来说，Fuzzing是指我们执行一个目标程序，其中包含大量变异的输入，以触发意想不到的行为，从而揭示故障。 为了深入到被测程序的状态空间，模糊器通常需要生成结构良好的输入。 除了结构良好之外，这些输入还需要考虑校验和、压缩算法或保护更深入处理的加密原语。 在实践中，有效地识别输入格式中的逻辑单元以及随后有效地解决这些单元中的障碍都是一个主要的挑战。 模糊者目前试图通过不同的方法来解决这些挑战，我们将在下面概述这些方法。 

**执行反馈**。 对于给定的输入，收集目标程序执行的反馈是现代Fuzzers的一项成熟技术[1,31,32]。 这种反馈提供了输入质量的度量，并允许模糊器识别探索新程序行为的输入。 通过保持并进一步改变这些结构越来越好的输入，模糊器得到的输入随着时间的推移在更大程度上与预期格式匹配。 收集执行反馈（最突出的是覆盖率反馈）很有吸引力，因为它普遍适用，并引入了低运行时开销。 事实上，在AFL[31]中引入这种覆盖引导技术后，Fuzzers已经能够探索常见的、结构更松散的二进制文件格式，并因此识别出大量的bug[33]。 即使模糊器不能直接使用它，执行反馈也为被测程序中编码的领域知识提供了一个侧通道。 

**语法**。与试图从目标程序中提取领域知识不同，人类专家可以向模糊器提供预先存在的领域知识。在这些方法中，要么为模糊器提供有关目标程序的输入结构的信息(例如，语法)，要么在模糊器中集成用于输入生成的结构感知逻辑[21-29]。这种关于目标格式的精确知识允许模糊器生成满足目标对输入结构的要求的输入。这些方法的主要缺点在于，尽管它们允许生成高质量的输入，但它们需要预先了解被测程序。

**自动语法近似**。不需要先验的语法形式的领域知识，有一些技术可以自动生成嵌入到目标中的语法的近似。针对基于文本的[34]或二进制格式存在不同的方法[30,35]。两者的共同之处在于，它们试图通过识别数据格式中的逻辑单元来推断所提供的输入的结构，例如，块、标记或字段。这支持结构感知的突变，允许模糊器修改、插入、删除或替换这些逻辑单元。尽管这些技术回避了手工加工语法和成功定位逻辑单元的需求，但近似过程本身就是粗粒度的。

**重量级反馈和分析**。除了上述改进模糊器生成高度结构化输入的能力的努力之外，一项正交的研究还集中在解决典型的模糊障碍，如校验和或密码原语，而不需要语法。作为提取目标程序中编码的领域知识的一种更直接的方法，最近的方法采用了复杂的程序分析和更重量级的反馈类型。这些方法通过帮助模糊器解决数据结构中的约束来解决(轻量级)反馈驱动的模糊器的缺陷，例如，通过污点跟踪[17-19]或concolic/符号执行[5,6,13 - 15]。利用污染跟踪，模糊器可以回溯跟踪输入的哪些部分影响特定的分支条件。有了这种语义洞察力，模糊者就可以把精力集中在改变与克服特定约束相关的输入部分上。使用符号执行或冲突执行，模糊器可以计算出解决条件或完整性检查所需的值，或者更一般地说，在给定的程序中执行所有路径。虽然重量级的反馈驱动模糊器已被证明能够有效地生成结构良好的输入，但它们面临着新的挑战和限制。主要的限制是它们相对较慢，不能扩展到大型目标程序，并且需要运行时环境来指定，例如，库函数[4]的副作用。此外，由于计算复杂性，由hash函数或签名等加密原语施加的复杂约束无法解决。

综上所述，我们发现当前生成复杂、高度结构化输入的方法要么依赖于人类专家提供的语法(这种方法有效但代价高昂)，要么依赖于近似语法(成本较低但效率较低)。注意，它们都不能处理复杂数据的突变。其他方法使用重量级技术，它们不需要语法，但效率很低，而且不能伸缩。没有一种最先进的方法能够以自动化和有效的方式利用现有的领域知识。

## 3.设计
在这项工作中，我们通过改变模糊化的视角来采用正交方法：我们建议把重点放在为被测目标程序产生输入的生成器应用程序上。我们的方法使用了一个简单而强大的理念：我们不是直接改变输入来创建新的测试用例，而是改变发生器应用程序并使用其输出作为测试目标的模糊测试用例。这样，我们可以（隐式地）利用领域知识并克服复杂的约束，而不会受到重量级技术或手动方法的缺点的影响。

我们的观察是，生成器程序通常产生格式良好的输出，这对于确保互操作性是不可或缺的。 通过有选择地向这些生成器程序中注入错误，它们产生几乎格式良好的输出，即他们可能会以微妙的方式违反规范， 这允许我们为各自的消费者程序生成高质量的测试用例。 例如，假设我们将错误注入到操作（即，读或写）部分处理的数据的指令中，这些数据随后将被加密签名。 在这种情况下，我们可以产生关于包络签名的变异但有效的输入。 至关重要的是，这些输入不会在签名验证期间早期丢弃，而是到达消费者中更深层次的程序逻辑。 

图1给出了我们方法的高层级概述，并显示了我们设计的各个组件是如何交互的。 在高层，我们希望生成器应用程序产生不同的测试用例，我们可以提供给我们实际的模糊目标消费者。 为此，1模糊调度程序为生成器应用程序选择一个或多个变异（例如，改变MOV指令存储的值），如果需要，还选择生成器处理的种子文件。 接下来，2选择的变异被应用到生成器。 变异的生成器现在3处理输入4并产生略微变异的输出。 最后，5调度器将生成的输出传递给使用者，6并收集复盖反馈。 如果测试用例触发了有趣的行为（新的复盖范围），则在随后的轮中，对变异的生成器程序和输入文件进行排队以进行进一步的变异。 

![](images/Pasted%20image%2020230312103636.png)

### 3.1 生成器
本质上，生成器可以被认为是一个种子生成器，用于产生针对模糊目标消费者的量身定制的输入。 当常见的模糊化方法通过位级突变来动态突变输入时，我们通过向生成器程序中注入错误来间接突变输入。 更准确地说，我们识别和变异生成器用来产生输出的数据操作。 

**生成器需求**。 为了方便我们的方法，我们需要一个程序来生成与模糊目标期望的输入格式匹配的输出。 大多数生成器应用程序（如图像转换器）要求可以被转换为目标格式的文件。 因此，与传统的模糊化方法不同，初始种子文件是生成器的而不是消费器的输入。 根据生成器的类型，可能不需要种子输入。 例如，这适用于加密密钥的生成器。

**数据操作**。 变异生成器的一个核心挑战是识别和变异数据操作。 我们把从内存中读取或写入任何指令都看作是一种数据操作。 潜在的洞察力是，在几乎所有情况下，程序生成的输出都在某个点存储在内存中，尤其是对于我们在本文中针对的复杂数据格式类型。 对于程序的特定输入，我们说它在执行相应操作时涵盖了数据操作（这是变异产生任何效果的基本要求）。 此外，我们说当底层数据相对于原始程序被修改时，数据操作就会发生变异。 

为了可靠地识别程序中的所有数据操作，我们设计了一个编译器通道，允许我们检测所有加载和存储操作。 这些操作在程序中普遍存在，从而产生许多潜在的有趣操作。 因此，我们不能对每一个实例进行分析。 相反，我们必须确定一个数据操作子集，使我们能够最大限度地控制已处理的数据，同时最小化运行时的不利影响，如崩溃。 除了它们的数量之外，还有几个因素决定指令的相关性：

- 影响：此特定指令是否修改相关数据。 即对产出有明显影响的数据？ 修改与生成的数据无关的指令对为模糊目标生成有趣的输入文件的目标没有好处。 
- 类型：修改后的数据是否表示一个值，如果该值发生突变，则可能导致生成器崩溃。 例如因为它是函数指针？ 修改指针而不是实际值容易使应用程序崩溃，而不是产生有趣的值。 
- 数据流依赖性：数据是否依赖于已被早期指令修改的值？ 直观地说，不希望多次修改相同的数据，因为最初的修改已经可以产生任何可能的值； 在最坏的情况下，第二个更改可能取消第一个的更改。 这不适用于部分依赖项。 

为了解决这些问题，我们设计编译器通道只插桩加载或存储值类型的指令，并且避免指针类型。 此外，我们使用编译器可用的数据流信息只插桩被修改的数据值的第一个实例。 不幸的是，编译时的静态分析无法确定特定指令是否会对应用程序的输出产生重大影响（如果有的话）。 因此，在开始实际的模糊化过程之前，我们的设计预算用于运行时的轻量级识别和剪枝阶段，我们将在下面描述这一过程。 

**插桩点修剪及影响分析**。我们观察到，允许模糊器在所有可能的插桩位置注入故障会导致许多无效突变。例如，给定的输入文件只执行(可能发生变化的)生成器代码中的特定路径，这通常只包含所有插桩点的一部分。我们称这些站点为死w.r.t.，即生成器的特定输入和(突变)版本。即使是活的(即，不是死的)插桩站点也可能没有实际的影响。这意味着，对于给定的输入和生成器版本组合，向该插桩点注入错误不会导致使用者中的任何覆盖率变化。

直观地说，为了最大限度地增加有效错误注入的数量，我们希望避免变异死的插桩点和没有明显影响的插桩点。 因此，我们的修剪和影响分析阶段的目标是双重的：对于种子输入和（潜在的）突变生成器的每个组合，我们首先旨在识别和移除死的插桩位置，然后分析剩余的插桩位置的影响。 为此，我们跟踪执行并只保留活动的插桩站点。 此外，为了分析活动的插桩站点的影响，我们观察向底层数据操作注入错误是否会在使用者中产生不同的代码覆盖率。 这个阶段导致每个种子文件和（潜在的）变异生成器应用程序都有一个活的和有影响的插桩点列表。 此外，我们还会记录额外的信息，如插桩点的执行次数，以供以后使用。如当生成突变时。 

**变异**。 为了生成稍微损坏的输入，我们对生成器进行变异：我们为生成器随机选择一个输入和一个或多个插桩点。 然后，我们将位级别变异应用于在各个插桩点处理的数据值。 由于这些站点在程序执行期间可以被多次访问，例如，在循环中，我们可以总是应用相同的突变，也可以选择更细粒度的控制，其形式是独立的突变，每次访问都不同。 对于后者，我们需要一个特定输入访问插桩点的频率的先验知识。 这些信息可以从我们的修剪和影响分析通道中方便地获得。 这允许我们为每个插桩点指定一个突变列表。 每一次对突变位点的访问都会消耗一个突变，直到一个给定的插桩点的所有突变都消耗掉为止。 在极少数情况下，变异会修改控制流，以至于在影响分析期间访问插桩点的次数多于观察到的次数，我们不能应用任何进一步的变异，而是返回未修改的数据值。 

### 3.2 消费器
生成器的对应方是消费者：作为我们模糊测试活动的目标，它使用生成器生成的输入。与典型的模糊测试目标类似，我们不对消费者施加任何具体限制。由于我们使用覆盖率反馈来指导生成器中的突变，因此消费者必须提供一个接口来检索覆盖率信息（通过源代码插桩或从仿真中获取）。

### 3.3 调度器
最后一个组件是调度程序，它协调生成器和消费者的交互。它管理模糊测试活动，其主要任务是组织模糊测试循环。调度器包含以下组件：

**队列**。调度程序维护一个包含队列条目的队列。 每个条目由传递到生成器（如果有）的种子输入和应用到生成器的所有突变组成。每个这样的队列条目表示单个测试用例。在传统的Fuzzing中，这样的测试用例将被表示为单个文件。

**阶段**。主要的模糊循环被分成多个阶段，见算法1。 根据阶段类型的不同，一个阶段内的步骤对于每个新队列条目（校准阶段）执行一次，或者在模糊过程中执行几次。 在启动Fuzzing活动时，所有种子文件都被添加到队列中，并因此进行校准。 

![](images/Pasted%20image%2020230313160617.png)

1. **校准阶段**：我们将输入传递给（潜在的突变）生成器，并记录执行过程中访问的插桩点（插桩点修剪）。对于目标的每个插桩点，我们进一步评估其对消费者覆盖范围的影响（影响分析）。 这些信息与输入和突变一起存储在队列条目中。 重要的是，这个阶段是常规模糊迭代的一部分。

在主模糊循环期间，我们然后重复地选择一个队列条目，并选择以下阶段之一： 

2. **添加阶段**：我们选择多个插桩点并应用突变。 我们更喜欢以前在消费者中成功产生新代码覆盖率的点。 此阶段向队列条目添加新的突变，扩展突变数据操作的实例。 
3. **变异阶段**：我们对所选队列条目的所有变异数据操作应用固定数量的变异。 与添加阶段不同，此阶段不添加任何新的数据操作，而是修改现有的数据操作。 
4. **组合阶段**：对于每个变异的数据操作，我们检查其他队列条目是否也变异了它。 如果是这样，我们尝试他们的突变。这类似于剪接，从传统的模糊认识，并允许受益于已经证明影响覆盖率的突变。

如果我们在主模糊循环期间观察到新的代码覆盖率，那么我们需要为新的队列条目执行校准阶段，创建该条目是为了表示产生新覆盖率的输入和突变的组合。

我们的队列实体选择算法类似于AFL所使用的算法。 两者都使用了新颖搜索的概念，即我们根据输入是否产生新的代码覆盖率来保留输入。 此外，我们应用了一个类似的偏好方案，该方案优先考虑消费者中覆盖最多代码的最小输入集。与AFL的主要区别在于，我们更喜欢包含很少观察到的数据操作的队列条目； AFL没有类似的概念，因为该方法根本不观察数据操作。 

### 3.4联合的模糊测试
与传统的模糊设计相比，我们的输入生成方法要慢一些:不是翻转一个字节，而是对生成器程序进行变异并执行以产生输入。此外，基于afl的模糊器能够拼接或分割输入操作——生成器通常不会暴露这些操作。为了弥补这些缺失的操作和性能影响，我们的方法可以与传统的模糊器(如AFL++)串联使用。这种方法类似于QSYM[5]、SYMCC[6]或DRILLER[14]等fuzzers，这些fuzzers使用AFL进行常规fuzzing，并通过提供解决普通变异无法解决的fuzzing障碍的新输入来增强fuzzing。同样，我们提出了一种方法，专注于生成器应用程序，以产生有趣的输入，为传统的模糊器解锁新的、更深的状态空间。

## 4.实现
我们在一个名为FUZZTRUCTION的原型中实现了我们的设计，这个原型包含了大约14000行Rust代码。接下来我们讨论实现方面。





## 5.评估
## 6.讨论
## 7.相关工作
## 8.结论
本文提出了一种新的基于软件故障注入的模糊化方法FuzzTruction。 基于使用输入的程序有一个（或多个）对应程序生成该输入的观点，我们建议对该生成器进行插桩和变异。 通过注入轻微的软件错误，我们可以利用应用程序中编码的隐式领域知识，并生成几乎与规范匹配的输入。 使用这些输入进行模糊化，FuzzTrucion产生高质量的输入，从而产生高代码覆盖率并运行深入的程序状态。 我们的方法是轻量级的，不需要昂贵的分析或手动准备的执行环境。 在评估中，我们发现我们的方法显示了它的力量，通常优于最先进的模糊方法，特别是在具有复杂约束的目标上，通常是以密码学原语或压缩的形式应用于输入。 

## 9.致谢
## 分配的CVE
## 目标描述
## 种子描述