## RTOS固件与基于Linux固件分析的区别
RTOS固件是一个单个二进制文件，里面缺乏符号信息，所有的函数库也包含在固件文件中。

基于Linux的固件由多个二进制文件组成文件系统，如httpd程序还需要包含很多lib文件才能运行，具有系统函数符号。

## 针对Linux固件网络程序的模糊测试方法
### 1.基于黑盒的模糊测试

如通过类似boofuzz或自己实现的模糊器，通过网络socket的方式向网络程序发送数据请求，根据响应信息（是否有响应）来判断是否崩溃。

现有问题：

1.变异数据的生成。基于生成的boofuzz需要定义输入语法结构，这需要手工努力，拓展性差。现有方法可以基于一定模式通过脚本生成语法结构，但需要有输入数据种子。

2.崩溃检测。基于boofuzz的黑盒模糊测试原本是对不可获取源码且程序比较大的网络系统进行测试，只能通过响应来作为崩溃的验证条件。而针对固件的模糊测试程序可获得不太大的二进制程序，并且常通过仿真的方式，这种情况下我们可以尝试向黑盒注入一点光，增强崩溃检测技术，从而及时发现异常输入。

### 2.基于AFL的灰盒模糊测试
通过AFL的Qemu等模式可以实现对固件二进制程序的灰盒模糊测试，然而AFL只能通过标准IO进行输入的程序进行测试，无法直接对网络程序进行测试。

现有的方法有：

1.hook socket fd. 将socket的文件描述符替换为某个文件的描述符，从而程序在读取网络数据流时直接从文件中读取。同时还可以hook启动的函数，跳过前面直接从感兴趣的函数开始运行测试。

这种方法的局限性是需要定位socket fd的位置，并需要确定程序的范围，能够仿真运行。

2.替换存储输入的内存内容。这种方法寻找到用户外部输入数据在内存中的存储位置，然后用变异数据替换。

局限也是需要定位内存中存储用户输入的位置，然后需要对内容进行替换。

3.修改AFL。修改AFL使得其能够对网络程序进行模糊测试，如AFLNET。

## 对网络程序模糊测试的挑战
**1.需要对固件网络程序进行仿真运行**。仿真是测试固件的一个重大挑战，大部分固件都难以仿真起来或不稳定。

据此可能的研究点：

a.能够满足测试要求的固件仿真技术。研究如何能够使固件成功仿真起来，达到安全研究的目的。

b.程序部分运行技术。通过切片或其他方法使固件程序中的一部分进行运行，避开前面难以运行的部分，达到对运行的这一部分程序进行测试的效果。

**2.缺乏有效的内存检测技术**。固件通常为二进制程序，没有源码，不同于桌面二进制程序，缺乏有效内存检测技术支持。如boofuzz是黑盒模糊测试，只能通过网络响应来对程序状态进行判断，而固件的程序是可获取的且相对来说比较小，因此可以尝试思考如何给模糊测试增加危险检测手段，从而能及时发现错误。可能的方法：

a.二进制代码插桩

b.通过仿真的一些手段，如检测进程是否存在、仿真日志信息。

**3.缺乏结构和语义信息**。针对网络程序的数据请求通常是具有结构的，并包含一些关键字。如果采用随机变异的AFL工具进行测试，就会破坏语义，这样程序解析的时候就会直接结束，难以进行高效的模糊测试。如何遵从程序的语义结构并进行高效的模糊测试是可以研究的一个点：

a.加入静态分析的方法，通过静态分析获取程序的一些语义信息，driller是将符号执行与模糊测试联合起来。

b.尝试基于生成的（针对语义）和基于变异的模糊测试方法结合起来。

**4.变异策略**。或许可以研究针对固件网络程序研究专门的变异策略，收集固件网络程序漏洞主要的触发原因，从而避免其他效率比较低的变异策略，进行有效的探索。如针对缓冲区溢出错误就应该先通过超长字符串进行验证，设计的策略有助于发现具有现有漏洞模式的漏洞，而随机变异的方法则有助于发现新的未知漏洞，如果通过一定比例将二者结合起来，可以提高效率并维持一定探索性。

## 静态分析方法
有一些工作通过静态的方法来帮助发现一些危险路径，如SaTC和SFuzz，前者通过静态污点分析找到可能的危险路径（误报率高），后者针对RTOS固件通过静态分析构建包含危险路径的执行树（程序切片）然后让模糊测试测试该路径。

静态分析可以对程序进行语义分析，相比模糊测试的盲目性来说可以更精确的找到漏洞的可能位置。然而在确定是否存在漏洞方面，静态分析由于没有实际运行固件，并不能确定分析结果确实存在漏洞，只能说它可能存在漏洞，具有大量误报。而动态分析会实际运行固件，因此它发现的漏洞一般不会误报。

单纯采用静态分析和动态分析都是有局限的，静态分析无法确定漏洞，动态分析盲目性太大，二者如果能有机结合是更高效的一种方法。现有常见的静态分析有符号执行、污点分析。

SaTC通过启发式方法对输入函数位置进行定位，作为污点分析的source点，而将危险函数作为sink点执行污点传播找到危险路径。污点分析我个人觉得其本身误报率会更高，因为污点分析携带的信息很少，只包含是否是污点的属性，没有更加详细的信息，无法判断是否污点传播到sink点就真的有漏洞，污点分析引擎的算法有待提高，然而比较精细的复杂度又很高。

SFuzz针对RTOS固件，也是先定位输入点为source点，危险函数为sink点，然后寻找危险路径切片，随后它切片程序进行了模糊测试，最后又通过符号执行等技术验证在原始程序上是否存在漏洞。基于Linux固件的程序分析也可借鉴此思路，先寻找可能的危险路径（提高精确度），然后启动模糊测试（也可开发针对部分函数的模糊测试）。

Driller将符号执行和模糊测试结合起来，在模糊测试遇到障碍时就调用符号执行进行处理。此外符号执行技术也常用于解决RTOS仿真困难，通过符号执行求解所需的硬件值。

## 研究思路
1.针对动静态结合做。

在现有静态分析技术SaTC、SFuzz的基础上进行静态分析，然后与动态模糊测试结合。

2.基于固件仿真做 + 基于模糊器做。

现有仿真技术时间消耗长，且仿真率低，可拓展的模糊测试技术依赖于仿真技术，并影响效率。首先做有效固件仿真，然后设计模糊器和内存检测方法，二者相结合。

3.多种方法结合，形成多阶段固件分析框架。

固件提取仿真技术对固件进行patch，使其能运行起来且更快的-->静态分析，提取信息-->有针对性的模糊测试-->报告生成。


