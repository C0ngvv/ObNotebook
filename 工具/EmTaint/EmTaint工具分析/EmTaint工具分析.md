## 使用方法
### 环境安装
其中EmTaint.tar.gz位于其上传的谷歌云中。
```
docker pull doneme123/emtaint:v1.1
tar -zxvf EmTaint.tar.gz
cd EmTaint
docker run -ti --rm -v `pwd`:/work doneme123/emtaint:v1.1
cd /work
workon EmTaint
```

### 使用--案例1
运行一个新的固件方法，我这里添加的dlink dir-815v1.01固件。

#### 1.二进制提取
使用binwalk从固件中提取分析的二进制文件
#### 2.IDA pro脚本分析
用ida pro打开分析的二进制，然后运行dataflow/ida_plugin文件夹下的parse_mips_binary.py或parse_arm_binary.py，注意修改文件里面的save_path参数为保存的位置，结果会生成四个文件。

![](images/Pasted%20image%2020231123105157.png)

将`{binary-name}_cfg.json`和`{binary-name}_block_info.json`文件拷贝到./data/ida_data/{name}\_{version}目录下（即dir815_v1.01）。

#### 3.执行分析
```
python main.py -f {binary} -n {name} -v {version} -t
```

即：
```
python main.py -f ./binaries/dir815-v1.01/cgibin -n dir815 -v v1.01 -t
```

主要用法参数
```
# python main.py 
usage: main.py [-h] [-f BINARY_FILE] [-i] [-t] [--switch_check]
               [-n FIRMWARE_NAME] [-v FIRMWARE_VERSION]
               [--resolve_icall RESOLVE_ICALL] [-a] [--infer_source] [--debug]
               [--load_ida_bytes]

Firmware Binary Static Analysis Tool.

optional arguments:
  -h, --help            show this help message and exit
  -f BINARY_FILE, --binary_file BINARY_FILE
                        single binary file in firmware
  -i, --icall_check     check and resolve the switch jmp
  -t, --taint_check     check and resolve the switch jmp
  --switch_check        check and resolve the switch jmp
  -n FIRMWARE_NAME, --firmware_name FIRMWARE_NAME
                        the firmware name, used for binary info generated by
                        Ida Pro
  -v FIRMWARE_VERSION, --firmware_version FIRMWARE_VERSION
                        the firmware version, used for different binary path
  --resolve_icall RESOLVE_ICALL
                        If reolve indirect call while doing taint analysis
  -a, --alias_check     find alias
  --infer_source        Infer taint sources to do taint analysis
  --debug               check and resolve the switch jmp
  --load_ida_bytes      whether load binary bytes from IDA Pro
```

#### 4.结果分析
```
data-path: /work/data/
ida-data-path: /work/data/ida_data/
result-save-path: /work/data/result_data/
firmware info path: /work/data/ida_data/dir815_v1.01/
firmware info path: /work/data/ida_data/dir815_v1.01/
cfg-info-file: /work/data/ida_data/dir815_v1.01/cgibin_cfg.json
block-info-file: /work/data/ida_data/dir815_v1.01/cgibin_block_info.json
switch-info-file: /work/data/ida_data/dir815_v1.01/cgibin_switch.json

Results-path: /work/data/result_data/

Analyzed all functions number: 290
Result-statistics-path: /work/data/result_data/dir815_v1.01.json

Start-filter-fake-source
Result-statistics-path: /work/dataflow/data/basic_alias_result_new.json
```

最后的结果生成/work/data/result_data/dir815_v1.01.json和/work/dataflow/data/basic_alias_result_new.json两个文件，但分析的这个它似乎没有分析出来任何结果。
```
{
    "taint_1": {
        "time": "0.200035",
        "all_functions": 278,
        "analyzed_functions": 0,
        "all_blocks": 0,
        "tainted_blocks": 0,
        "tainted_sinks": 0,
        "buffer_overflow_num": 0,
        "command_exec_num": 0,
        "buffer_overflow": {},
        "command_exec": {},
        "tained_length": {},
        "sink_info": {
            "strcpy": 0,
            "strncpy": 0,
            "memcpy": 0,
            "memmove": 0,
            "sprintf": 0,
            "sscanf": 0,
            "strcat": 0,
            "strncat": 0,
            "system": 0,
            "popen": 0,
            "execve": 0,
            "_system": 0
        }
    },
    "source_sink": {},
    "param_cons": {}
}
```

## 问题分析
后来发现应该是IDA Pro脚本分析的时候，分析结果有问题，我在其分析结果中没有找到getenv。

看的时候遇到一个问题，对于下面这个指令，使用`GetOpnd(ea, 0)`和`GetDisasm(ea)`得到的结果不同，`GetOpnd(ea, 0)`按理应该得到`$t9`，可实际却得到`$ra`，很奇怪。因为这个原因，所以没找到getenv或者说函数调用。
```
jalr $t9 ; getenv

GetOpnd(ea, 0) ：$ra
GetDisasm(ea)：jalr    $t9 ; fopen
```

修改代码如下（get_block_info_mips函数 375行）：
```python
while ea != BADADDR and ea < block_end:
        # print("Analysis: 0x%x" % (ea))
        mnem = GetMnem(ea)
        opnd0_name = GetOpnd(ea, 0)
        ins = GetDisasm(ea)
        call_mnems = ['jalr', 'jr', 'j', 'jal']
        # if mnem in call_mnems and opnd0_name == '$t9':
        if mnem in call_mnems and opnd0_name in ['$t9', '$ra']:
            # print("Call: 0x%x %s" % (ea, ins))
            # ins_list = ins.split(" ;")
            ins_list = list(filter(None, re.split(r'[; \s]\s*', ins)))
            # print(ins_list)
            # if len(ins_list) >= 3 and ins_list[1] == opnd0_name:
            if len(ins_list) >= 3 and ins_list[1] == '$t9':
                func_name = ins_list[2]
```

这样生成出来的cfg.json就有getenv调用信息了。但是在执行的时候又遇到错误了。
```bash
4221768
4220212
{4221768: <Block 0x406b48 (0x406b48)>, 4221769: <Block 0x406b49->0x40614c (0x406b48)>, 4219212: <Block 0x40614c (0x406b48)>, 4219284: <Block 0x406194 (0x406b48)>, 4219308: <Block 0x4061ac (0x406b48)>, 4219276: <Block 0x40618c->0x40f560 (0x406b48)>, 4219300: <Block 0x4061a4->0x40f560 (0x406b48)>, 4221688: <Block 0x406af8->0x404b00 (0x406b48)>, 4221636: <Block 0x406ac4->free (0x406b48)>, 4221612: <Block 0x406aac->free (0x406b48)>, 4221584: <Block 0x406a90->free (0x406b48)>, 4221528: <Block 0x406a58->0x40e724 (0x406b48)>, 4221500: <Block 0x406a3c->0x40e724 (0x406b48)>, 4221472: <Block 0x406a20->free (0x406b48)>, 4219336: <Block 0x4061c8->getenv (0x406b48)>, 4219384: <Block 0x4061f8->strcasecmp (0x406b48)>, 4219740: <Block 0x40635c->0x40362c (0x406b48)>, 4219416: <Block 0x406218->0x403204 (0x406b48)>, 4219764: <Block 0x406374->0x405550 (0x406b48)>, 4219812: <Block 0x4063a4->0x405550 (0x406b48)>, 4220100: <Block 0x4064c4->getenv (0x406b48)>, 4220140: <Block 0x4064ec->0x405550 (0x406b48)>, 4220192: <Block 0x406520->0x4088d4 (0x406b48)>, 4220264: <Block 0x406568->0x408754 (0x406b48)>, 4220292: <Block 0x406584->fopen (0x406b48)>, 4221432: <Block 0x4069f8->free (0x406b48)>, 4220328: <Block 0x4065a8->fgets (0x406b48)>, 4220416: <Block 0x406600->fclose (0x406b48)>, 4220440: <Block 0x406618->0x402768 (0x406b48)>, 4220636: <Block 0x4066dc->stat (0x406b48)>, 4220992: <Block 0x406840->0x406024 (0x406b48)>, 4221016: <Block 0x406858->0x40e1cc (0x406b48)>, 4221060: <Block 0x406884->0x4048b8 (0x406b48)>, 4220668: <Block 0x4066fc->open (0x406b48)>, 4220700: <Block 0x40671c->lockf (0x406b48)>, 4220944: <Block 0x406810->close (0x406b48)>, 4220972: <Block 0x40682c->unlink (0x406b48)>, 4220728: <Block 0x406738->0x40e6b8 (0x406b48)>, 4220740: <Block 0x406744->0x4055f8 (0x406b48)>, 4220752: <Block 0x406750->0x406024 (0x406b48)>, 4220796: <Block 0x40677c->0x40e1cc (0x406b48)>, 4220820: <Block 0x406794->0x40e1cc (0x406b48)>, 4220856: <Block 0x4067b8->0x4048b8 (0x406b48)>, 4220896: <Block 0x4067e0->sprintf (0x406b48)>, 4220920: <Block 0x4067f8->0x40d6d0 (0x406b48)>, 4221084: <Block 0x40689c->0x40e6b8 (0x406b48)>, 4221108: <Block 0x4068b4->system (0x406b48)>, 4221132: <Block 0x4068cc->fopen (0x406b48)>, 4221192: <Block 0x406908->0x40362c (0x406b48)>, 4221400: <Block 0x4069d8->fclose (0x406b48)>, 4221160: <Block 0x4068e8->stat (0x406b48)>, 4221228: <Block 0x40692c->puts (0x406b48)>, 4221252: <Block 0x406944->puts (0x406b48)>, 4221280: <Block 0x406960->printf (0x406b48)>, 4221304: <Block 0x406978->printf (0x406b48)>, 4221332: <Block 0x406994->fgetc (0x406b48)>, 4221356: <Block 0x4069ac->fputc (0x406b48)>, 4220492: <Block 0x40664c->0x40e6b8 (0x406b48)>, 4220504: <Block 0x406658->0x4055f8 (0x406b48)>, 4220516: <Block 0x406664->0x406024 (0x406b48)>, 4220560: <Block 0x406690->0x40e1cc (0x406b48)>, 4220584: <Block 0x4066a8->0x40e1cc (0x406b48)>, 4220388: <Block 0x4065e4->0x4048b8 (0x406b48)>, 4220168: <Block 0x406508->atoi (0x406b48)>, 4219844: <Block 0x4063c4->0x40e8f0 (0x406b48)>, 4219868: <Block 0x4063dc->getenv (0x406b48)>, 4219892: <Block 0x4063f4->0x40e8f0 (0x406b48)>, 4219916: <Block 0x40640c->getenv (0x406b48)>, 4219940: <Block 0x406424->strcasecmp (0x406b48)>, 4220040: <Block 0x406488->0x40eb08 (0x406b48)>, 4220064: <Block 0x4064a0->0x40e8f0 (0x406b48)>, 4219968: <Block 0x406440->0x40eb08 (0x406b48)>, 4219992: <Block 0x406458->getenv (0x406b48)>, 4220016: <Block 0x406470->0x40e8f0 (0x406b48)>, 4219796: <Block 0x406394->strcasecmp (0x406b48)>, 4219708: <Block 0x40633c->0x40362c (0x406b48)>, 4219452: <Block 0x40623c->0x405550 (0x406b48)>, 4219580: <Block 0x4062bc->getenv (0x406b48)>, 4219604: <Block 0x4062d4->atoi (0x406b48)>, 4219632: <Block 0x4062f0->sprintf (0x406b48)>, 4219660: <Block 0x40630c->sprintf (0x406b48)>, 4219472: <Block 0x406250->0x406024 (0x406b48)>, 4219496: <Block 0x406268->0x40e1cc (0x406b48)>, 4219540: <Block 0x406294->0x4048b8 (0x406b48)>}
Traceback (most recent call last):
  File "main.py", line 811, in <module>
    main()
  File "main.py", line 797, in main
    perform_analysis(args.binary_file,
  File "main.py", line 692, in perform_analysis
    FastSearch(proj, binary_parser, ida_object, accurate_dataflow, fast_dataflow, collector,
  File "/work/EmTaint/dataflow/data_trace.py", line 159, in __init__
    self._analyze()
  File "/work/EmTaint/dataflow/data_trace.py", line 396, in _analyze
    self._analyze_binary(do_recursive_call=True)
  File "/work/EmTaint/dataflow/data_trace.py", line 524, in _analyze_binary
    self._execute_function(function, execute_flag=0x1)
  File "/work/EmTaint/dataflow/data_trace.py", line 620, in _execute_function
    self._push_callee_exprs_to_callsite(function)
  File "/work/EmTaint/dataflow/data_trace.py", line 2344, in _push_callee_exprs_to_callsite
    self._push_callee_arg_exprs_to_callsite(function)
  File "/work/EmTaint/dataflow/data_trace.py", line 2371, in _push_callee_arg_exprs_to_callsite
    self._pre_process_function(pre_function)
  File "/work/EmTaint/dataflow/data_trace.py", line 3567, in _pre_process_function
    self._pre_process_function_vex(function)
  File "/work/EmTaint/dataflow/data_trace.py", line 741, in _pre_process_function_vex
    backward_trace_variable_type(function, block)
  File "/work/EmTaint/dataflow/variable_type.py", line 545, in backward_trace_variable_type
    curr_block = cfg.get_node_by_addr(def_loc.block_addr) if def_loc.block_addr != block.addr else block
  File "/work/EmTaint/dataflow/generate_cfg.py", line 35, in get_node_by_addr
    return self._nodes[addr]
KeyError: 4220212

```

1.cfg如何定义的（self.\_nodes）
2.调用的地址如何获取的？

cfg生成位于/work/EmTaint/dataflow/data_trace.py:3541
```python
cfg = FunctionCFG(funcea, self._ida_object, self.proj)
cfg.generate_function_cfg(function, start_ida_blocks)
function.cfg = cfg
```

## IDA Pro脚本分析
脚本main函数主要调用四个函数：
```python
    functions = get_all_functions()
    recognise_functions(functions)
    recognise_functions_v2(functions)
    get_cfg_block_info()
```

get_all_functions()主要是遍历所有段并分析其中的函数，加入funcs集合中。

recognise_functions(functions)是通过交叉引用读取.data节恢复函数。

recognise_functions_v2(functions)是通过遍历.text节来恢复函数。

get_cfg_block_info()用于解析二进制并或偶去每个函数的cfg和块信息。

### get_cfg_block_info()



## /data/ida_data/router/文件分析
### httpd_block_info.json
没完全看懂
```
{
	函数块地址1:{},
	函数块地址2:{
		"块地址？？？":[
			[
				LDR地址|变量间接引用地址,
				解析变量地址,
				类型(func_ptr, iCall, ext_data, )
			],
			...
		]
	},
	...
}
```

### httpd_cfg.json
```
{
	函数块地址：{
		"jmp调用图":[
			[
				前一个块地址，
				后一个块地址
			],
			[
				前一个块地址，
				后一个块地址
			],
			...
		],
		"call函数调用":[
			[
				所在块地址,
				调用函数处地址,
				调用的函数名
			],
			...
		],
		"name函数名": "sub_372EC",
		"block自上到下函数块":[
			[
				函数块1地址,
				函数块2地址
			],
			[
				函数块2地址,
				函数块3地址
			],
			...
		]
	}
}
```

## /data/result_data/router_version.json
对结果文件进行分析
```
{
	"buffer_overflow":{
		"危险调用位置地址":{
			"name调用的危险函数": "sprintf",
			"offset危险参数栈上偏移":[
				90
			],
			"info": [
				?,
				?,
				?,
				?
			],
			"func所在的函数":462088
		}
	}
}
```


## 漏洞分析
在web目录下建立cgibin的软连接soap.cgi
```
ln -s /htdocs/cgibin soap.cgi
```

创建var/run目录

两个问题：
1. 可能存在漏洞的点难以到达，手工分析不知道该怎么触发
2. 对于一个已知漏洞，当从网页发送请求时，没有显示的影响