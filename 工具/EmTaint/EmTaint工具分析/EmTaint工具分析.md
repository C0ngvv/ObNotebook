## 使用方法
### 环境安装
其中EmTaint.tar.gz位于其上传的谷歌云中。
```
docker pull doneme123/emtaint:v1.1
tar -zxvf EmTaint.tar.gz
cd EmTaint
docker run -ti --rm -v `pwd`:/work doneme123/emtaint:v1.1
cd /work
workon EmTaint
```

### 使用--案例1
运行一个新的固件方法，我这里添加的dlink dir-815v1.01固件。

#### 1.二进制提取
使用binwalk从固件中提取分析的二进制文件
#### 2.IDA pro脚本分析
用ida pro打开分析的二进制，然后运行dataflow/ida_plugin文件夹下的parse_mips_binary.py或parse_arm_binary.py，注意修改文件里面的save_path参数为保存的位置，结果会生成四个文件。

![](images/Pasted%20image%2020231123105157.png)

将`{binary-name}_cfg.json`和`{binary-name}_block_info.json`文件拷贝到./data/ida_data/{name}\_{version}目录下（即dir815_v1.01）。

#### 3.执行分析
```
python main.py -f {binary} -n {name} -v {version} -t
```

如：
```
python main.py -f ./firmware-binaries/rv130_v44/httpd -n rv130 -v 1_0_3_44 -t
```

主要用法参数
```
# python main.py 
usage: main.py [-h] [-f BINARY_FILE] [-i] [-t] [--switch_check]
               [-n FIRMWARE_NAME] [-v FIRMWARE_VERSION]
               [--resolve_icall RESOLVE_ICALL] [-a] [--infer_source] [--debug]
               [--load_ida_bytes]

Firmware Binary Static Analysis Tool.

optional arguments:
  -h, --help            show this help message and exit
  -f BINARY_FILE, --binary_file BINARY_FILE
                        single binary file in firmware
  -i, --icall_check     check and resolve the switch jmp
  -t, --taint_check     check and resolve the switch jmp
  --switch_check        check and resolve the switch jmp
  -n FIRMWARE_NAME, --firmware_name FIRMWARE_NAME
                        the firmware name, used for binary info generated by
                        Ida Pro
  -v FIRMWARE_VERSION, --firmware_version FIRMWARE_VERSION
                        the firmware version, used for different binary path
  --resolve_icall RESOLVE_ICALL
                        If reolve indirect call while doing taint analysis
  -a, --alias_check     find alias
  --infer_source        Infer taint sources to do taint analysis
  --debug               check and resolve the switch jmp
  --load_ida_bytes      whether load binary bytes from IDA Pro
```

#### 4.结果分析
```
data-path: /work/data/
ida-data-path: /work/data/ida_data/
result-save-path: /work/data/result_data/
firmware info path: /work/data/ida_data/dir815_v1.01/
firmware info path: /work/data/ida_data/dir815_v1.01/
cfg-info-file: /work/data/ida_data/dir815_v1.01/cgibin_cfg.json
block-info-file: /work/data/ida_data/dir815_v1.01/cgibin_block_info.json
switch-info-file: /work/data/ida_data/dir815_v1.01/cgibin_switch.json

Results-path: /work/data/result_data/

Analyzed all functions number: 290
Result-statistics-path: /work/data/result_data/dir815_v1.01.json

Start-filter-fake-source
Result-statistics-path: /work/dataflow/data/basic_alias_result_new.json
```

最后的结果生成/work/data/result_data/dir815_v1.01.json和/work/dataflow/data/basic_alias_result_new.json两个文件，但分析的这个它似乎没有分析出来任何结果。
```
{
    "taint_1": {
        "time": "0.200035",
        "all_functions": 278,
        "analyzed_functions": 0,
        "all_blocks": 0,
        "tainted_blocks": 0,
        "tainted_sinks": 0,
        "buffer_overflow_num": 0,
        "command_exec_num": 0,
        "buffer_overflow": {},
        "command_exec": {},
        "tained_length": {},
        "sink_info": {
            "strcpy": 0,
            "strncpy": 0,
            "memcpy": 0,
            "memmove": 0,
            "sprintf": 0,
            "sscanf": 0,
            "strcat": 0,
            "strncat": 0,
            "system": 0,
            "popen": 0,
            "execve": 0,
            "_system": 0
        }
    },
    "source_sink": {},
    "param_cons": {}
}
```

## 问题分析
后来发现应该是IDA Pro脚本分析的时候，分析结果有问题，我在其分析结果中没有找到getenv。

## IDA Pro脚本分析
脚本main函数主要调用四个函数：
```python
    functions = get_all_functions()
    recognise_functions(functions)
    recognise_functions_v2(functions)
    get_cfg_block_info()
```

get_all_functions()主要是遍历所有段并分析其中的函数，加入funcs集合中。

recognise_functions(functions)是通过交叉引用读取.data节恢复函数。

recognise_functions_v2(functions)是通过遍历.text节来恢复函数。

get_cfg_block_info()用于解析二进制并或偶去每个函数的cfg和块信息。

### get_cfg_block_info()





## /data/ida_data/router/文件分析
### httpd_block_info.json
没完全看懂
```
{
	函数块地址1:{},
	函数块地址2:{
		"块地址？？？":[
			[
				LDR地址|变量间接引用地址,
				解析变量地址,
				类型(func_ptr, iCall, ext_data, )
			],
			...
		]
	},
	...
}
```

### httpd_cfg.json
```
{
	函数块地址：{
		"jmp调用图":[
			[
				前一个块地址，
				后一个块地址
			],
			[
				前一个块地址，
				后一个块地址
			],
			...
		],
		"call函数调用":[
			[
				所在块地址,
				调用函数处地址,
				调用的函数名
			],
			...
		],
		"name函数名": "sub_372EC",
		"block自上到下函数块":[
			[
				函数块1地址,
				函数块2地址
			],
			[
				函数块2地址,
				函数块3地址
			],
			...
		]
	}
}
```

## /data/result_data/router_version.json
对结果文件进行分析
```
{
	"buffer_overflow":{
		"危险调用位置地址":{
			"name调用的危险函数": "sprintf",
			"offset危险参数栈上偏移":[
				90
			],
			"info": [
				?,
				?,
				?,
				?
			],
			"func所在的函数":462088
		}
	}
}
```